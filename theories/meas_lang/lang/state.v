Set Warnings "-hiding-delimiting-key".
From HB Require Import structures.
From Coq Require Export ssrfun.
From stdpp Require Import binders gmap.
From mathcomp Require Import eqtype choice boolp functions classical_sets.
From mathcomp.analysis Require Import measure lebesgue_measure sequences.
From clutch.common Require Export locations.
From clutch.meas_lang.lang Require Export prelude types tapes.
Import Coq.Logic.FunctionalExtensionality.

Require Import mathcomp.reals_stdlib.Rstruct.
Require Import mathcomp.reals.reals.
Set Warnings "hiding-delimiting-key".

Local Open Scope classical_set_scope.

Set Default Proof Using "Type*".

(** Removed. We directly prove measurability of max (dom...)*)
(* Section heapdom. *)
(*   Context {d} {T : measurableType d}. *)

(*   (**  Sets  *) *)
(*   Structure MeasHeapDom := { v : set T }. *)

(*   (** Measure space on sets *) *)
(*   HB.instance Definition _ := gen_eqMixin MeasHeapDom. *)
(*   HB.instance Definition _ := gen_choiceMixin MeasHeapDom. *)
(*   HB.instance Definition _ := isPointed.Build MeasHeapDom {| v := set0 |}. *)

(*   (* Generated by singleton sets, so all countable (and finite) sets are measurable. *) *)
(*   Definition measheapdom_generators := *)
(*     [set [set (Build_MeasHeapDom x)] | x in measurable ]. *)

(*   Definition measheapdom_measurable := <<s measheapdom_generators>>. *)

(*   Lemma mhd_meas0 : measheapdom_measurable set0. *)
(*   Proof. by apply sigma_algebra0. Qed. *)

(*   Lemma mhd_measC X : (measheapdom_measurable  X) -> measheapdom_measurable  (~` X). *)
(*   Proof. by apply sigma_algebraC. Qed. *)

(*   Lemma mhd_measU (F : sequences.sequence (set MeasHeapDom)) : (forall i,measheapdom_measurable  (F i)) -> measheapdom_measurable (\bigcup_i F i). *)
(*   Proof. by apply sigma_algebra_bigcup. Qed. *)

(*   HB.instance Definition _ := *)
(*     @isMeasurable.Build (sigma_display measheapdom_measurable) MeasHeapDom *)
(*       measheapdom_measurable mhd_meas0 mhd_measC mhd_measU. *)
(* End heapdom. *)

Section hp_measure.
  Local Open Scope classical_set_scope.
  Context {d} {T : measurableType d}.
  (** Measurable functions out of <<discr loc>> (TODO: Generalize with the seq_measure).
      Will need to pick the right Countable class so that it works with the shapes proof
      but also the countability part of the measurability argument.

      Also will need to deal with the fact that nat does not have a <<discr _>> strucutre,
      which messes up my typeclasses for SA's generated by singletons.
   *)

  Definition hp : Type := gmap <<discr loc>> T.

  HB.instance Definition _ := gen_eqMixin hp.
  HB.instance Definition _ := gen_choiceMixin hp.
  HB.instance Definition _ := isPointed.Build hp inhabitant.


  Definition hp_generators : set (set hp) :=
    (\bigcup_i (preimage_set_system setT (fun f => f !! i) measurable)).

  Definition hp_measurable : set (set hp) := <<s hp_generators>>.

  Lemma hp_meas0 : hp_measurable set0.
  Proof. by apply sigma_algebra0. Qed.

  Lemma hp_measC X : (hp_measurable X) -> hp_measurable (~` X).
  Proof. by apply sigma_algebraC. Qed.

  Lemma hp_measU (F : sequences.sequence (set hp)) : (forall i, hp_measurable (F i)) -> hp_measurable (\bigcup_i F i).
  Proof. by apply sigma_algebra_bigcup. Qed.

  HB.instance Definition _ :=
    @isMeasurable.Build (sigma_display hp_measurable) hp hp_measurable hp_meas0 hp_measC hp_measU.

  Lemma hp_sigma_algebra_singleton (s:set (option T)) (i:loc):
    measurable s -> 
    measurable (preimage (λ (f:hp), f!!i) s).
  Proof.
    intros H.
    apply sub_sigma_algebra.
    exists i; first done.
    exists s; first done. by rewrite setTI.
  Qed.

  Lemma hp_ext (f g: hp):
    (forall i, f !! i = g!!i) -> f=g.
  Proof.
    intros H. 
    replace f with (filter (λ _, True) f); last by apply map_filter_id.
    replace g with (filter (λ _, True) g); last by apply map_filter_id.
    apply map_filter_strong_ext_1.
    intros. by rewrite H.
  Qed. 

  Lemma hp_meas_singleton (f:hp): (∀ t:T, measurable [set t]) -> measurable [set f].
  Proof.
    intros H.
    assert (set1 f = \bigcap_i (preimage (λ (f:hp), f!!(loc_enum i)) (set1 (f!!(loc_enum i)))) ) as Hrewrite; last rewrite Hrewrite.
    { rewrite eqEsubset; split; intros ?; simpl.
      - by intros -> i _.
      - intros H'.
        apply: hp_ext.
        intros i.
        pose proof loc_enum_surj i as [n Hn].
        unshelve epose proof H' n _ as H''; first done.
        simpl in *. by subst.
    } 
    apply: bigcapT_measurable.
    intros k.
    apply hp_sigma_algebra_singleton.
    destruct (f !! loc_enum k); apply: sub_sigma_algebra; rewrite /option_cyl/=.
    - eexists (Some _); last apply image_set1.
      naive_solver.
    - exists None; naive_solver.
  Qed. 
  Hint Resolve hp_meas_singleton: measlang.

  Definition hp_eval (i : <<discr loc>>) : hp -> option T := fun f => (gmap_lookup i f).

  Lemma hp_eval_meas_fun (i : <<discr loc>>) : measurable_fun setT (hp_eval i).
  Proof.
    intros _ Y HY.
    rewrite /hp_measurable.
    suffices H : hp_generators (setT `&` hp_eval i @^-1` Y).
    { by apply ((@sub_gen_smallest _ _ hp_generators) _ H). }
    exists i; [done|].
    rewrite /hp_eval.
    rewrite /preimage_set_system//=.
    exists Y; [done|].
    rewrite setTI.
    done.
  Qed.
  Hint Resolve hp_eval_meas_fun : measlang.

  Lemma uncurry_loc_measurable {d1 d2} {T1 : measurableType d1} {T2 : measurableType d2}
          (f : <<discr loc>> -> T1 -> T2) (Hf : forall i, measurable_fun setT (f i)) :
        measurable_fun setT (uncurry f).
   Proof.
    intros _ Y HY.
    have -> : ((uncurry f) @^-1` Y) = \bigcup_i ((setX [set loc_enum i] ((f $ loc_enum i) @^-1` Y)) : set (<<discr loc>> * _)%type).
    { rewrite /uncurry/preimage/setX//=.
      apply /predeqP =>[[l ]] /=.
      split.
      { intros H.
        destruct (loc_enum_surj l) as [i Hi].
        exists i; [done|].
        by rewrite Hi //=. }
      { move=>[x ?]//=. by move=>[-> ?]//=. }
    }
    rewrite setTI.
    apply bigcup_measurable.
    intros i ?.
    apply measurableX.
    { by rewrite /measurable//=. }
    rewrite <-(setTI (preimage _ _)).
    by eapply (Hf _ _ Y HY).
    Unshelve. by apply @measurableT.
  Qed.

  (* The uncurry is measurable becuase nat is discrete and countable *)
  Definition hp_evalC : (<<discr loc>> * hp)%type -> option T := uncurry hp_eval.
  Lemma hp_evalC_meas_fun : measurable_fun setT hp_evalC.
  Proof. by apply (@uncurry_loc_measurable _ _ _ _ hp_eval), hp_eval_meas_fun. Qed.
  Hint Resolve hp_evalC_meas_fun : measlang.


  Definition hp_update (i : <<discr loc>>) : ((option T) * hp)%type -> hp :=
    fun x => gmap_partial_alter (cst (fst x)) i (snd x).

  Lemma hp_update_meas_fun (i : <<discr loc>>) : measurable_fun setT (hp_update i).
  Proof.
    into_gen_measurable.
    rewrite /preimage_set_system/=.
    intros ?. simpl.
    rewrite /hp_generators/preimage_set_system//=.
    intros H. destruct!/=. destruct H as [l ? [s ? H]].
    rewrite setTI in H. subst.
    rewrite setTI.
    destruct (decide (i=l)); subst.
    - assert ((hp_update l) @^-1` ((lookup l) @^-1` s) = (s`*` setT)) as Hrewrite; last rewrite Hrewrite; ms_solve.
      rewrite eqEsubset; split; intros []; simpl; rewrite /hp_update/=lookup_partial_alter/=; naive_solver.
    - assert ((hp_update i @^-1` ([eta lookup l] @^-1` s))= setT `*`(setT `&` preimage (hp_eval l) s)) as Hrewrite; last rewrite Hrewrite; ms_solve; last apply hp_eval_meas_fun.
      rewrite eqEsubset; split; intros []; simpl; rewrite /hp_update/=lookup_partial_alter_ne/hp_eval/=; naive_solver.
  Qed.
  Hint Resolve hp_update_meas_fun : measlang.

  Definition hp_updateC : (<<discr loc>> * (option T * hp))%type -> hp := uncurry hp_update.
  Lemma hp_updateC_meas_fun : measurable_fun setT hp_updateC.
  Proof. by apply (@uncurry_loc_measurable _ _ _ _ hp_update), hp_update_meas_fun. Qed.
  Hint Resolve hp_updateC_meas_fun : measlang.

End hp_measure.

Global Arguments hp {_} _.
(* Global Arguments MeasHeapDom {_} _. *)

(* Section dom. *)
(*   Local Open Scope classical_set_scope. *)
(*   (** domain of a heap function hpf *) *)
(*   Context {d} {T : measurableType d}. *)

(*   (* Function which takes a heap to the set of all elements which are Some *) *)
(*   Definition dom (m : hp T) : MeasHeapDom <<discr loc>> := *)
(*     {| v := [set l | is_Some (hp_eval l m) ] |}. *)

(*   Lemma dom_meas_fun : measurable_fun setT dom. *)
(*   Proof. *)
(*     (* Suffices to show that the preimages of generators of (MeasHeapDom <<discr loc>>) are measurable *)
(*        Suffices to show that forall (S : set <<discr loc>>), preimage [set S] dom is measurable *)
(*        Suffices to show that forall (S : set <<discr loc>>), the set of hpfs which *)
(*           assign l to Some _ iff l is in S is measurable *)
(*        This set is the countable intersection of preimages of (image Some setT) or [None] *)
(*           under (eval l); so is measurable. *)
(*      *) *)
(*   Admitted. *)
(*   Hint Resolve dom_meas_fun : measlang. *)

(* End dom. *)

Definition loc_lt (l1 l2 : <<discr loc>>) : Prop :=
  (l1.(loc_car) < l2.(loc_car))%Z.

(* A set has a maximum *)
(* Definition hasMax : MeasHeapDom <<discr loc>> -> Prop := *)
(*   fun S => exists (l : <<discr loc>>), forall l' : <<discr loc>>, S.(v) l -> loc_lt l' l. *)

Section hp.
  Local Open Scope classical_set_scope.
  Context {d} (T : measurableType d).

  (* (* The set of MeasHeapDom's that have a maximum is measurable. *) *)
  (* Lemma hasMax_meas_set : measurable hasMax. *)
  (* Proof. *)
  (*   (* hasMax = U_(i in i) [set S | |S| = i ] *)
  (*             = U_(i in i), U(S : set <<discr loc>>, |S| = i), [set S] *)
  (*       Because <<discr loc>> is discrete, each S is measurable, so each [set S] is measurable. *)
  (*       So this set is measurable. *) *)
  (* Admitted. *)
  (* Hint Resolve hasMax_meas_set : measlang. *)

  (* (** A heap (hp) is a map from <<discr loc>> to some type, whose domain is finite. *) *)
  (* Definition hp_finite : set (hp T) := preimage dom hasMax. *)

  (* Lemma hp_finite_meas_set : measurable hp_finite. *)
  (* Proof. *)
  (*   unfold hp_finite. *)
  (*   rewrite <- (setTI (preimage _ _)). *)
  (*   apply dom_meas_fun; try by eauto. *)
  (*   by apply hasMax_meas_set. *)
  (* Qed. *)
  (* Hint Resolve hp_finite_meas_set : measlang. *)

  (* Definition get_fresh (m : hp T) : <<discr loc>>:= *)
  (* fresh_loc m. *)
    (* The minimum loc that is greater than every element of ... *)
  (*      Exists because of H. *)
  (*    *)

  Definition fresh : hp T -> <<discr loc>> :=
    fun m => (fresh_loc m).
  Local Transparent fresh_loc.

  Local Ltac fresh_unfold :=
    rewrite /fresh/fresh_loc/base.fresh/set_fresh/=/base.fresh/infinite_fresh/=/base.fresh/infinite_fresh/=.

  Local Lemma fresh_meas_fun_lemma1 l:
    (0<=foldr (Z.max ∘ Z.succ) 0 l)%Z.
  Proof.
    induction l; first done.
    simpl.
    rewrite Z.max_le_iff. right. lia.
  Qed.

  
  Local Lemma fresh_meas_fun_lemma2 i l:
    i∈l ->
    (i<foldr (Z.max ∘ Z.succ) 0 l)%Z.
  Proof.
    induction l as [|a l IHl]; simpl; first by rewrite elem_of_nil.
    rewrite elem_of_cons.
    intros [->|H].
    - apply Z.max_lt_iff. left. lia.
    - apply IHl in H.
      apply Z.max_lt_iff. right. lia.
  Qed. 

  Local Lemma fresh_meas_fun_lemma3 l bound:
    (0<=bound)%Z-> 
    (forall i, bound<=i -> i∉l)%Z <->
    (foldr (Z.max ∘ Z.succ) 0%Z l <= bound)%Z.
  Proof.
    intros H.
    induction l as [|a l IHl]; split.
    - simpl. lia.
    - intros. apply not_elem_of_nil.
    - intros H'. simpl.
      apply Z.max_lub.
      + apply Z.nlt_ge.
        intros ?.
        assert (bound <= a)%Z by lia.
        apply H' in H1. apply H1. rewrite elem_of_cons. naive_solver.
      + apply IHl.
        intros ? H''. apply H' in H''. intros H1. apply H''. rewrite elem_of_cons. naive_solver.
    - simpl. rewrite Z.max_lub_iff.
      intros [H1 H2].
      intros i H0.
      rewrite elem_of_cons.
      intros [->|H']; first lia.
      rewrite -IHl in H2. apply H2 in H0. naive_solver.
  Qed. 

  Local Lemma fresh_meas_fun_lemma4 l:
    (0<foldr (Z.max ∘ Z.succ) 0%Z l)%Z-> 
    (foldr (Z.max ∘ Z.succ) 0%Z l-1)%Z ∈ l.
  Proof.
    induction l as [|a l IHl]; simpl; first lia.
    intros H.
    destruct (decide (Z.succ a <= foldr (Z.max ∘ Z.succ) 0 l))%Z as [Heqn|Heqn].
    - rewrite Z.max_r; last lia.
      rewrite elem_of_cons. right.
      apply IHl.
      rewrite Z.max_lt_iff in H. destruct H; lia.
    - rewrite Z.max_l; last lia.
      rewrite elem_of_cons. left. lia.
  Qed.
  
  Lemma fresh_meas_fun : measurable_fun setT fresh.
  Proof.
    apply: measurability; first apply discr_generated_by_singletons.
    rewrite /preimage_set_system/=. intros s. simpl.
    rewrite /function_spaces.singletons/=.
    elim.
    intros ?.
    elim.
    intros l. intros. subst.
    destruct l as [z].
    rewrite setTI.
    destruct (Z.lt_total z 0) as [H'|[H'|H']].
    { assert (fresh @^-1` [set Loc z] = set0) as Hrewrite; last by rewrite Hrewrite.
      rewrite eqEsubset; split; intros ?; last done.
      fresh_unfold.
      intros Heq. simplify_eq.
      revert H'.
      apply Zle_not_lt.
      apply fresh_meas_fun_lemma1.
    } 
    { subst.
      assert ((fresh @^-1` [set Loc 0]) =
              \bigcap_i (preimage (λ (f:hp T), f !! (Loc (Z.of_nat i) )) (set1 None))
             ) as Hrewrite; last rewrite Hrewrite; last first.
      - apply: bigcapT_measurable.
        intros k.
        apply hp_sigma_algebra_singleton.
        apply: sub_sigma_algebra.
        exists None; naive_solver.
      - rewrite eqEsubset; split; intros t; simpl; rewrite /bigcap/=; fresh_unfold.
        + intros H'. simplify_eq. 
          intros i _.
          apply: not_elem_of_dom_1.
          rewrite -elem_of_elements.
          intros H2.
          symmetry in H'.
          revert H'.
          apply Z.lt_neq.
          eapply Z.le_lt_trans; last apply(fresh_meas_fun_lemma2 i); first lia.
          rewrite elem_of_list_omap.
          naive_solver.
        + intros H'.
          f_equal.
          apply Z.le_antisymm; last apply fresh_meas_fun_lemma1.
          apply fresh_meas_fun_lemma3; first done.
          intros.
          rewrite elem_of_list_omap.
          intros [x [H1 H2]].
          rewrite elem_of_elements in H1. simplify_eq.
          destruct x as [x]. simpl in *.
          unshelve epose proof H' (Z.to_nat x) _; first done.
          rewrite Z2Nat.id in H2; last lia.
          rewrite elem_of_dom in H1. rewrite H2 in H1. by destruct H1.
    }
    assert ((fresh @^-1` [set Loc z]) =
            (preimage (λ (f:hp T), f !! (Loc (z-1)%Z )) option_cov_Some)
            `&`
              \bigcap_(i in [set j| (Z.to_nat z<=Z.of_nat j)%Z])  (preimage (λ (f:hp T), f !! (Loc (Z.of_nat i) )) (set1 None))
           ) as Hrewrite; last rewrite Hrewrite; last first.
    { apply: measurable_setI.
      - apply hp_sigma_algebra_singleton.
        ms_solve. apply option_cov_Some_meas_set.
      - apply: bigcap_measurableType.
        intros k ?.
        apply hp_sigma_algebra_singleton.
        apply: sub_sigma_algebra.
        exists None; naive_solver.
    }
    rewrite eqEsubset; split; intros t; simpl; rewrite /bigcap/=; fresh_unfold.
    - intros H1; simplify_eq.
      split.
      + apply fresh_meas_fun_lemma4 in H'.
        rewrite elem_of_list_omap in H'.
        destruct H' as [[x] [H1 H2]].
        simplify_eq. simpl in *. subst.
        by rewrite elem_of_elements elem_of_dom in H1.
      + intros i H1.
        rewrite Z2Nat.id in H1; last apply fresh_meas_fun_lemma1.
        rewrite -fresh_meas_fun_lemma3 in H1; last lia.
        unshelve epose proof H1 (Z.of_nat i) _ as H2; first lia.
        rewrite elem_of_list_omap in H2.
        destruct (t!!Loc (Z.of_nat i)) eqn:Heqn; last done.
        exfalso.
        apply H2. eexists (Loc _); split; last done.
        by rewrite elem_of_elements elem_of_dom Heqn.
    - intros [H1 H2].
      f_equal.
      apply Z.le_antisymm.
      + apply fresh_meas_fun_lemma3; first lia.
        intros ??. rewrite elem_of_list_omap.
        intros [[x][H3 H4]].
        simplify_eq. simpl in *.
        unshelve epose proof H2 (Z.to_nat x) _.
        { rewrite Z2Nat.id; lia. }
        rewrite Z2Nat.id in H4; last lia.
        rewrite elem_of_elements elem_of_dom H4 in H3. by destruct H3.
      + apply Z.lt_succ_r.
        rewrite /Z.succ.
        apply Z.lt_sub_lt_add_r.
        apply fresh_meas_fun_lemma2.
        rewrite elem_of_list_omap.
        eexists (Loc _); split; last done.
        rewrite elem_of_elements elem_of_dom. naive_solver.
  Qed. 
  Hint Resolve fresh_meas_fun : measlang.

End hp.


(* Global Arguments hp_finite {_ _}. *)
Global Arguments fresh {_ _} _.

Section hpfuns.
  Local Open Scope classical_set_scope.
  Context {d} {T : measurableType d}.

  (** Stdpp instances for hp

      Note: These instances are possibly not what you want to use, because they
      uncurry the definitions so are not measurable.

      Could prove that the real definitions are extensionally equal to stdpp-looking ones though,
      to make porting the logic easier.
   *)

  (* Global Instance : PartialAlter <<discr loc>> T (hp T) := { *)
  (*     partial_alter f l h := hp_updateC (l, (f $ hp_evalC (l, h), h)) }. *)

  (* Global Instance : Lookup <<discr loc>> T (hp T) := hp_eval. *)

  (* Definition hp_to_gmap (f :hp T) : gmap loc T := f. *)

  (* Lemma hp_to_gmap_eq f: f= hp_to_gmap f. *)
  (* Proof. *)
  (*   done. *)
  (* Qed.  *)
(*  Global Program Instance hp_insert {d} {T : measurableType d} : Insert (<<discr loc>>) T (hp T) :=
  _. *)

End hpfuns.

(** The state: a [loc]-indexed heap of [val]s, and [loc]-indexed tapes, and [loc]-indexed utapes *)
Record state : Type := {
    state_v : ((hp val) * (hp btape) * (hp utape))%type
}.

Definition prod_of_state (s : state) : ((hp val) * (hp btape) * (hp utape)) :=
  match s with {| state_v := x |} => x end.

Definition state_of_prod (v : (hp val) * (hp btape) * (hp utape)) : state :=
  {| state_v := v |}.

Lemma prod_of_state_of_prod p : prod_of_state (state_of_prod p) = p.
Proof. by rewrite /prod_of_state/state_of_prod//. Qed.

Lemma state_of_prod_of_state s : state_of_prod (prod_of_state s) = s.
Proof. destruct s. by rewrite /prod_of_state/state_of_prod//. Qed.

HB.instance Definition _ := gen_eqMixin state.
HB.instance Definition _ := gen_choiceMixin state.
HB.instance Definition _ := isPointed.Build state (state_of_prod point).

Definition state_measurable : set (set state) :=
  flip image (flip image state_of_prod) measurable.

Lemma state_display : measure_display.
Proof. done. Qed.

Lemma state_measurable_of_prod_measurable S : measurable S -> state_measurable (image S state_of_prod).
Proof.
  move=>HS.
  rewrite /state_measurable/image/flip//=.
  exists S; done.
Qed.

Lemma prod_measurable_of_state_measurable {S} :
  state_measurable S -> measurable (image S prod_of_state).
Proof.
  intro HS.
  destruct HS as [S' HS' <-].
  rewrite image_comp.
  have -> : ssrfun.comp prod_of_state state_of_prod = (fun x => x).
  { apply functional_extensionality; intro x. by rewrite /ssrfun.comp prod_of_state_of_prod. }
  by rewrite image_id.
Qed.

(* State MS is isomorphic to prod *)

Lemma state_meas0 : state_measurable set0.
Proof.
  have -> : (set0 : set state) = (image set0 state_of_prod).
  { apply functional_extensionality; intro x; apply propext.
    rewrite /image/state_of_prod/set0//=.
    split; [by move=>?|by move=>[??]].
  }
  by apply state_measurable_of_prod_measurable, @measurable0.
Qed.

Lemma state_measC X : (state_measurable X) -> state_measurable (~` X).
Proof.
  rewrite /state_measurable.
  rewrite measurable_prod_measurableType.
  simpl. intros H. destruct!/=.
  apply sigma_algebraC in H.
  eexists _; try done.
  rewrite eqEsubset; split; intros [[[]]]; simpl.
  - intros [[[]]? K1][[[]]? K2]. rewrite -K1 in K2.
    rewrite /state_of_prod/= in K2. simplify_eq. naive_solver.
  - intros H'.
    eexists _; last done.
    intros H''.
    apply H'. naive_solver.
Qed. 

Lemma state_measU (F : sequences.sequence (set state)) : (forall i, state_measurable (F i)) -> state_measurable (\bigcup_i F i).
Proof.
  rewrite /state_measurable.
  rewrite measurable_prod_measurableType/=.
  intros H.
  assert (forall i : nat,
  smallest (sigma_algebra setT)
    (image2 measurable measurable
       (fun (A : set (prod (hp val) (hp btape))) (B : set (hp utape)) => setX A B)) (((λ i, image (F i) state_v) i))) as H'.
  { intros i. pose proof H i as [x H1 H2].
    rewrite -H2.
    assert (([set state_v x | x in [set state_of_prod x | x in x]]) = x) as Hrewrite; last by rewrite Hrewrite.
    rewrite eqEsubset; split; intros ?; simpl; intros; destruct!/=; naive_solver.
  }
  apply sigma_algebra_bigcup in H'.
  eexists _; first done.
  rewrite eqEsubset; split; intros s; simpl.
  - intros [[[]][? ? K] ]; subst. simpl in *. destruct K as [[[[]]]]; simpl in *. simplify_eq.
    eexists _; last done. done.
  - intros []. destruct s. eexists _; try done.
    eexists _; last naive_solver. done.
Qed. 

HB.instance Definition _ :=
  @isMeasurable.Build state_display state state_measurable state_meas0 state_measC state_measU.

Global Instance : SigmaAlgebra state_display state :=
  {| axioms := @Measurable.class state_display state |}.

Lemma state_meas_singleton (v : state) : measurable [set v].
Proof.
  rewrite /measurable/=/state_measurable/=.
  exists (set1 (prod_of_state v)); last by rewrite image_set1 state_of_prod_of_state.
  rewrite measurable_prod_measurableType.
  apply: sub_sigma_algebra.
  destruct v as [[[x y] z]]. simpl.
  eexists (set1 (x, y)); last first.
  { exists (set1 z); last by rewrite -prod1.
    apply: hp_meas_singleton.
    intros.
    apply utape_meas_singleton.
  }
  rewrite measurable_prod_measurableType.
  apply: sub_sigma_algebra.
  simpl.
  exists (set1 x); last exists (set1 y);
                     last by rewrite -prod1.
                     - apply: hp_meas_singleton. intros.
                       apply: val_meas_singleton. 
                     - apply: hp_meas_singleton.
                       apply: btape_meas_singleton.
Qed. 
(*
Definition state_lift_fun {d} {T : measurableType d} f : state -> T := ssrfun.comp f prod_of_state.
*)

Definition state_lift_set D : set state := image D state_of_prod.

Lemma prod_of_state_meas_fun D (H : measurable D) : measurable_fun D prod_of_state.
Proof.
  intros HD Y HY.
  have -> : (D `&` prod_of_state @^-1` Y) = (image (setI (image D prod_of_state) Y) state_of_prod).
  { rewrite /setI/image//=.
    apply functional_extensionality; intro y; apply propext; split; rewrite //=.
    { move=>[??].
      eexists (prod_of_state y); last by rewrite state_of_prod_of_state.
      split; [|done].
      eexists _; done. }
    { move=> [? [+ +]]. move=> [? ?] H1 H2 <-.
      rewrite prod_of_state_of_prod.
      split; last done.
      rewrite <-H1.
      rewrite state_of_prod_of_state.
      done. } }
  apply state_measurable_of_prod_measurable.
  apply measurableI.
  { by apply prod_measurable_of_state_measurable. }
  { done. }
Qed.
Hint Resolve prod_of_state_meas_fun : measlang.

Lemma state_of_prod_meas_fun D (H : measurable D) : measurable_fun D state_of_prod.
Proof.
  intros HD Y HY.
  have -> : (D `&` state_of_prod @^-1` Y) = (image (setI (image D state_of_prod) Y) prod_of_state).
  { rewrite /setI/image//=.
    apply functional_extensionality; intro y; apply propext; split; rewrite //=.
    { move=>[??].
      eexists (state_of_prod y); last by rewrite prod_of_state_of_prod.
      split; [|done].
      eexists _; done. }
    { move=> [? [+ +]]. move=> [? ?] H1 H2 <-.
      rewrite state_of_prod_of_state.
      split; last done.
      rewrite <-H1.
      rewrite prod_of_state_of_prod.
      done. } }
  apply prod_measurable_of_state_measurable.
  suffices HM : measurable ([set state_of_prod x | x in D] `&` Y) by done.
  apply measurableI.
  { by apply state_measurable_of_prod_measurable. }
  { done. }
Qed.
Hint Resolve state_of_prod_meas_fun : measlang.


(*
Definition state_lift_fun_meas {d} {T : measurableType d} (f : _ -> T) D (HD : measurable D) (H : measurable_fun D f) :
    measurable_fun (state_lift_set D) (state_lift_fun f).
Proof.
  intros H1 Y HY.
  have -> :  (state_lift_set D `&` state_lift_fun f @^-1` Y) = (image (D `&` f @^-1` Y) state_of_prod).
  { rewrite /image/setI/preimage/state_lift_fun/state_lift_set/state_of_prod//=.
    apply functional_extensionality; intro y; apply propext; split; rewrite //=.
    { move=>[[??]<-].
      rewrite prod_of_state_of_state.
      move=>?. by eexists _. }
    { move=>[?[??]]<-.
      split; [eexists _; done|].
      by rewrite prod_of_state_of_state. }
  }
  by apply state_measurable_of_prod_measurable, (H HD), HY.
Qed.
*)

Definition heap : state -> hp val :=
  fst \o fst \o prod_of_state.

Lemma heap_meas_fun : measurable_fun setT heap.
Proof.
  eapply (@measurable_comp _ _ _ _ _ _ setT (ssrfun.comp fst fst) setT prod_of_state); simpl.
  { by eapply @measurableT. }
  { done. }
  { eapply measurable_comp.
    { by eapply @measurableT. }
    { done. }
    { by apply @measurable_fst. }
    { by apply @measurable_fst. }
  }
  { eapply prod_of_state_meas_fun. by apply @measurableT. }
Qed.
Hint Resolve heap_meas_fun : measlang.

Definition tapes  : state -> hp btape :=
  snd \o fst \o prod_of_state.

Lemma tapes_meas_fun : measurable_fun setT tapes.
Proof.
  eapply (@measurable_comp _ _ _ _ _ _ setT (ssrfun.comp snd fst) setT prod_of_state); simpl.
  { by eapply @measurableT. }
  { done. }
  { eapply measurable_comp.
    { by eapply @measurableT. }
    { done. }
    { by apply @measurable_snd. }
    { by apply @measurable_fst. }
  }
  { eapply prod_of_state_meas_fun. by apply @measurableT. }
Qed.
Hint Resolve tapes_meas_fun : measlang.

Definition utapes : state -> hp utape :=
  snd \o prod_of_state.

Lemma utapes_meas_fun : measurable_fun setT utapes.
Proof.
  eapply (@measurable_comp _ _ _ _ _ _ setT snd setT prod_of_state); simpl.
  { by eapply @measurableT. }
  { done. }
  { by eapply @measurable_snd. }
  { eapply prod_of_state_meas_fun. by apply @measurableT. }
Qed.
Hint Resolve utapes_meas_fun : measlang.

(** Operations on states *)

Definition state_upd_heap (f : hp val -> hp val) : state -> state :=
  state_of_prod \o (f \o heap △ tapes △ utapes).

Lemma state_upd_heap_meas_fun f (H : measurable_fun setT f) : measurable_fun setT (state_upd_heap f).
Proof.
  eapply (@measurable_comp _ _ _ _ _ _ setT state_of_prod  setT _).
  { by eapply @measurableT. }
  { done. }
  { by apply state_of_prod_meas_fun. }
  mcrunch_prod.
  { mcrunch_prod.
    { eapply @measurable_comp; [by eapply @measurableT|done| |].
      { done. }
      { by apply heap_meas_fun.  }
    }
    { by apply tapes_meas_fun. }
  }
  { by apply utapes_meas_fun. }
Qed.
Hint Resolve state_upd_heap_meas_fun : measlang.

Definition state_upd_tapes (f : hp btape -> hp btape) : state -> state :=
  state_of_prod \o (heap △ f \o tapes △ utapes).

Lemma state_upd_tapes_meas_fun f (H : measurable_fun setT f) : measurable_fun setT (state_upd_tapes f).
Proof.
  eapply (@measurable_comp _ _ _ _ _ _ setT state_of_prod  setT _).
  { by eapply @measurableT. }
  { done. }
  { by apply state_of_prod_meas_fun. }
  mcrunch_prod.
  { mcrunch_prod.
    { by apply heap_meas_fun.  }
    { eapply @measurable_comp; [by eapply @measurableT|done| |].
      { done. }
      { by apply tapes_meas_fun. }
    }
  }
  { by apply utapes_meas_fun. }
Qed.
Hint Resolve state_upd_tapes_meas_fun : measlang.

Definition state_upd_utapes (f : hp utape -> hp utape) : state -> state :=
  state_of_prod \o (heap △ tapes △ f \o utapes).

Lemma state_upd_utapes_meas_fun f (H : measurable_fun setT f) : measurable_fun setT (state_upd_utapes f).
Proof.
  eapply (@measurable_comp _ _ _ _ _ _ setT state_of_prod  setT _).
  { by eapply @measurableT. }
  { done. }
  { by apply state_of_prod_meas_fun. }
  mcrunch_prod.
  { mcrunch_prod.
    { by apply heap_meas_fun.  }
    { by apply tapes_meas_fun. }
  }
  { eapply @measurable_comp; [by eapply @measurableT|done| |].
    { done. }
    { by apply utapes_meas_fun. }
  }
Qed.
Hint Resolve state_upd_utapes_meas_fun : measlang.

Lemma state_upd_tapes_twice σ l xs ys :
  state_upd_tapes <[ l := ys ]> (state_upd_tapes <[ l := xs ]> σ) = state_upd_tapes <[ l:= ys ]> σ.
Proof. rewrite /state_upd_tapes/=. do 3 f_equal. rewrite /state_of_prod/tapes/=.
       apply: insert_insert.
Qed.

Lemma state_upd_tapes_same σ σ' l xs ys :
  state_upd_tapes <[l:=ys]> σ = state_upd_tapes <[l:=xs]> σ' -> xs = ys.
Proof.
  rewrite /state_upd_tapes/state_of_prod/tapes/=.
  intros H. simplify_eq.
  rewrite map_eq_iff in H0.
  specialize (H0 l).
  epose proof (lookup_insert (prod_of_state σ).1.2 l ys) as K.
  epose proof (lookup_insert (prod_of_state σ').1.2 l xs) as K'.
  rewrite K K' in H0.
  by simplify_eq.
Qed.

Lemma state_upd_tapes_no_change σ l ys :
  (tapes σ) !! l = Some ys ->
  state_upd_tapes <[l := ys]> σ = σ .
Proof.
  destruct σ as [[[? h0 ]]]. rewrite /tapes. simpl.
  intros Ht. rewrite /state_upd_tapes/state_of_prod/=.
  repeat f_equal.
  rewrite /tapes/=.
  by rewrite insert_id.
Qed. 


(* Lemma state_upd_tapes_same' σ σ' l n m xs (x y : Z) : *)
(*   state_upd_tapes <[l:=((n, (m, xs++[x])))]> σ = state_upd_tapes <[l:=(n, (m, xs++[y]))]> σ' -> x = y. *)
(* Proof. intros H. apply state_upd_tapes_same in H. by simplify_eq. Qed. *)

(* Lemma state_upd_tapes_neq' σ σ' l n xs (x y : stdpp.fin.fin (S n)) : *)
(*   x≠y -> state_upd_tapes <[l:=(fin(n; xs++[x]))]> σ ≠ state_upd_tapes <[l:=(fin(n; xs++[y]))]> σ'. *)
(* Proof. move => H /state_upd_tapes_same ?. simplify_eq. Qed. *)

Fixpoint heap_array (l : <<discr loc>>) (vs : list val) : gmap <<discr loc>> val :=
  match vs with
  | [] => ∅
  | v :: vs' => {[l := v]} ∪ heap_array (l +ₗ 1) vs'
  end.

Lemma heap_array_singleton l v : heap_array l [v] = {[l := v]}.
Proof. by rewrite /heap_array right_id. Qed.

Lemma heap_array_app l vs1 vs2 : heap_array l (vs1 ++ vs2) = (heap_array l vs1) ∪ (heap_array (l +ₗ (length vs1)) vs2) .
Proof.
  revert l.
  induction vs1; intro l.
  - simpl.
    rewrite map_empty_union loc_add_0 //.
  - rewrite -app_comm_cons /= IHvs1.
    rewrite map_union_assoc.
    do 2 f_equiv.
    rewrite Nat2Z.inj_succ /=.
    rewrite /Z.succ
      Z.add_comm
      loc_add_assoc //.
Qed.

Lemma heap_array_lookup l vs v k :
  heap_array l vs !! k = Some v ↔
  ∃ j, (0 ≤ j)%Z ∧ k = l +ₗ j ∧ vs !! (Z.to_nat j) = Some v.
Proof.
  revert k l; induction vs as [|v' vs IH] => l' l /=.
  { rewrite lookup_empty. naive_solver lia. }
  rewrite -insert_union_singleton_l lookup_insert_Some IH. split.
  - intros [[-> ?] | (Hl & j & ? & -> & ?)].
    { eexists 0. rewrite loc_add_0. naive_solver lia. }
    eexists (1 + j)%Z. rewrite loc_add_assoc !Z.add_1_l Z2Nat.inj_succ; auto with lia.
  - intros (j & ? & -> & Hil). destruct (decide (j = 0)); simplify_eq/=.
    { rewrite loc_add_0; eauto. }
    right. split.
    { rewrite -{1}(loc_add_0 l). intros ?%(inj (loc_add _)); lia. }
    assert (Z.to_nat j = S (Z.to_nat (j - 1))) as Hj.
    { rewrite -Z2Nat.inj_succ; last lia. f_equal; lia. }
    rewrite Hj /= in Hil.
    eexists (j - 1)%Z. rewrite loc_add_assoc Z.add_sub_assoc Z.add_simpl_l.
    auto with lia.
Qed.

Lemma heap_array_map_disjoint (h : gmap <<discr loc>> val) (l : loc) (vs : list val) :
  (∀ i, (0 ≤ i)%Z → (i < length vs)%Z → h !! (l +ₗ i) = None) →
  (heap_array l vs) ##ₘ h.
Proof.
  intros Hdisj. apply map_disjoint_spec=> l' v1 v2.
  intros (j&?&->&Hj%lookup_lt_Some%inj_lt)%heap_array_lookup.
  move: Hj. rewrite Z2Nat.id // => ?. by rewrite Hdisj.
Qed.


(* Definition state_upd_hp_N : (<<discr loc>> * <<discr Z>> * val * (hp (option val)))%type -> (hp (option val)). *)
(* Admitted. *)


(* Lemma *)
(*                               (l : loc) (n : nat) (v : val) (σ : state) : state := *)
(*   state_upd_heap (λ h, heap_array l (replicate n v) ∪ h) σ. *)




(* Lemma state_upd_heap_singleton l v σ : *)
(*   state_upd_heap_N l 1 v σ = state_upd_heap <[l:= v]> σ. *)
(* Proof. *)
(*   destruct σ as [h p]. rewrite /state_upd_heap_N /=. f_equiv. *)
(* Admitted. *)
(* (* *)
(*   rewrite right_id insert_union_singleton_l. done. *)
(* Qed. *)
(* *) *)

(* Lemma state_upd_tapes_heap σ l1 l2 xs m v : *)
(*   state_upd_tapes <[l2:=xs]> (state_upd_heap_N l1 m v σ) = *)
(*   state_upd_heap_N l1 m v (state_upd_tapes <[l2:=xs]> σ). *)
(* Proof. *)
(*   by rewrite /state_upd_tapes /state_upd_heap_N /=. *)
(* Qed. *)

Lemma heap_array_replicate_S_end l v n :
  heap_array l (replicate (S n) v) = heap_array l (replicate n v) ∪ {[l +ₗ n:= v]}.
Proof.
  induction n.
  - simpl.
    rewrite map_union_empty.
    rewrite map_empty_union.
    by rewrite loc_add_0.
  - rewrite replicate_S_end
     heap_array_app
     IHn /=.
    rewrite map_union_empty replicate_length //.
Qed.

Global Instance state_inhabited : Inhabited state := populate point.

