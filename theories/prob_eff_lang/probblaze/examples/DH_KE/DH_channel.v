From iris.proofmode Require Import base tactics classes.
From iris.base_logic.lib Require Import  na_invariants.
From iris.algebra Require Import agree excl auth frac excl_auth.
From iris.algebra.lib Require Import dfrac_agree.
From clutch Require Import stdpp_ext.
From clutch.prob_eff_lang.probblaze Require Import logic primitive_laws proofmode
  spec_rules spec_ra 
  class_instances.
From clutch.prob_eff_lang.probblaze Require Import definition.

Import fingroup.

Import fingroup.fingroup.

Import valgroup_notation.
Import valgroup_tactics.

Section handlee_verification.
  Context `{!probblazeRGS Σ}.
  Context (channel1 channel2 getKey1 getKey2 : label).
  Context {vg : val_group}.           (* A group on a subset of values. *)
  Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
  Context {G : clutch_group (vg:=vg) (cg:=cg)}.
  Context {vgg : @val_group_generator vg}.   (* G is generated by g. *)
  Context `{!inG Σ (authR (agreeUR valO)), !inG Σ (exclR unitO), !inG Σ dfracO, !inG Σ (dfrac_agreeR valO), !inG Σ (excl_authR unitO) }.

  #[local] Notation n := (S n'').

  (* Names and resources used in the theories *)
  
  Definition alphaN : namespace := nroot .@ "alpha".
  Definition betaN : namespace := nroot .@ "beta".
  Definition atokN : namespace := nroot .@ "atokN".
  Definition btokN : namespace := nroot .@ "btokN".

  Definition token γ := own γ (Excl ()).

  
  Lemma token_alloc : ⊢ |==> ∃ γ, token γ.
  Proof.
    iApply own_alloc. 
    constructor.
  Qed.

  Lemma token_agree γ : ⊢ token γ -∗ token γ -∗ False.
  Proof.
    iIntros "Ha Hb". 
    iDestruct (own_valid_2 with "Ha Hb") as "%Hvalid".
    done.
  Qed.

  Lemma auth_alloc v : ⊢ |==> ∃ γ, own γ (to_dfrac_agree (DfracOwn 1) v).
  Proof.
    iApply own_alloc.
    constructor; done.
  Qed.
  
  Lemma auth_upd v' γ v : ⊢ own γ (to_dfrac_agree (DfracOwn 1) v) -∗ |==>  own γ (to_dfrac_agree (DfracOwn 1) v').
  Proof.
    iApply own_update.
    apply cmra_update_exclusive.
    constructor; done.
  Qed.

  Lemma auth_agree γ q q' v v' :
    ⊢ own γ (to_dfrac_agree q v) -∗ own γ (to_dfrac_agree q' v') -∗ ⌜ v = v' ⌝.
  Proof.
    iIntros "H1 H2".
    iDestruct (own_op with "[$H1 $H2]") as "H".
    iDestruct (own_valid with "H") as "%H".
    iPureIntro.
    by apply dfrac_agree_op_valid in H as (?&H). 
  Qed.

  Lemma auth_persist γ q v : ⊢ own γ (to_dfrac_agree q v) -∗ |==> own γ (to_dfrac_agree DfracDiscarded v).
  Proof.
    iApply own_update.
    by apply dfrac_agree_persist.
  Qed.

  Lemma dfrac_alloc : ⊢ |==> ∃ γ, own γ (DfracOwn 1).
  Proof.
    iApply own_alloc.
    done.
  Qed.                               
  
  Lemma dfrac_persist γ (q : dfrac) : ⊢ own γ q -∗ |==> own γ DfracDiscarded.
  Proof.
    iApply own_update.
    apply dfrac_discard_update.
  Qed.

  Lemma dfrac_contra γ (q : dfrac) : ⊢ own γ q -∗ own γ (DfracOwn 1) -∗ False.
  Proof.
    iIntros "H1 H2".
    iDestruct (own_op with "[$H1 $H2]") as "H".
    iDestruct (own_valid with "H") as "%H".
    iPureIntro.
    eapply exclusive_r; eauto using dfrac_full_exclusive.
  Qed.


  (* Theories for the client *)
  
  Program Definition GetKey1 : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: getKey1 (InjL #()%V) ⌝%E ∗
                ⌜ e2 = do: getKey2 (InjL #()%V) ⌝%E ∗
                □ (Q NONEV NONEV ∗ ∀ key : vgG, Q (SOMEV key) (SOMEV key) )
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition GetKey2 : iThy Σ :=
     λ e1 e2, (λne Q,
                ⌜ e1 = do: getKey1 (InjR #()%V) ⌝%E ∗
                ⌜ e2 = do: getKey2 (InjR #()%V) ⌝%E ∗
                □ (Q NONEV NONEV ∗ ∀ key : vgG, Q (SOMEV key) (SOMEV key) )
             )%I.
  Next Obligation. solve_proper. Qed.

  Definition T : iThy Σ := iThyTraverse [getKey1] [getKey2] (iThySum GetKey1 GetKey2).

  (* Theories for auth channel interacting with the environment *)
    
  Program Definition SendBob : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : val,
                ⌜ e1 = do: channel1 (SendV (m, bob)) ⌝%E ∗
                  ⌜ e2 = do: channel2 (SendV (m, bob)) ⌝%E ∗
                   □ Q (Val #()%V) (Val #()%V)
             )%I. 
  Next Obligation. solve_proper. Qed.

  Program Definition SendAlice : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : val, 
                  ⌜ e1 = do: channel1 (SendV (m, alice)) ⌝%E ∗
                  ⌜ e2 = do: channel2 (SendV (m, alice)) ⌝%E ∗
                  □ Q (Val #()%V) (Val #()%V)
             )%I. 
  Next Obligation. solve_proper. Qed.

  Program Definition RecvBobAuth : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: channel1 (RecvV bob) ⌝%E ∗
                ⌜ e2 = do: channel2 (RecvV bob) ⌝%E ∗
                □ ((∀ b1 b2 : nat, Q (SOMEV #b1) (SOMEV #b2)) ∧ Q NONEV NONEV)
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition RecvAliceAuth : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: channel1 (RecvV alice) ⌝%E ∗
                ⌜ e2 = do: channel2 (RecvV alice) ⌝%E ∗
                □ ((∀ b1 b2 : nat, Q (SOMEV #b1) (SOMEV #b2)) ∧ Q NONEV NONEV)
             )%I.
  Next Obligation. solve_proper. Qed.

  Definition Y : iThy Σ := iThyTraverse [channel1] [channel2] (iThySum (iThySum SendAlice SendBob) (iThySum RecvAliceAuth RecvBobAuth)).

  (* Theories for the implementations *)
                   
  
  Program Definition SendBobImpl γtok γfrac γauth ι : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : val, ((|={⊤, ⊤ ∖ ↑ι }=> ((own γfrac DfracDiscarded -∗ (|={⊤ ∖ ↑ι, ⊤}=> token γtok ∗ own γauth (to_dfrac_agree DfracDiscarded m))) ∨ |={⊤ ∖ ↑ι , ⊤}=> own γfrac DfracDiscarded)) ∗  
                            (⌜ e1 = do: channel1 (SendV (m, alice)) ⌝%E ∗
                             ⌜ e2 = do: channel2 (SendV (m, alice)) ⌝%E)  ∗ 
                            □ (Q (Val #()%V) (Val #()%V)))
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition RecvAliceImpl γauth : iThy Σ :=
    λ e1 e2, (λne Q,
                 ⌜ e1 = do: channel1 (RecvV alice) ⌝%E ∗
                 ⌜ e2 = do: channel2 (RecvV alice) ⌝%E ∗
                 □ (Q NONEV NONEV ∗ (∀ m, own γauth (to_dfrac_agree DfracDiscarded m) -∗ Q (SOMEV m) (SOMEV m)))
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition SendAliceImpl γtok γfrac γauth ι : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : val, ((|={⊤, ⊤ ∖ ↑ι }=> ((own γfrac DfracDiscarded -∗ (|={⊤ ∖ ↑ι, ⊤}=> token γtok ∗ own γauth (to_dfrac_agree DfracDiscarded m))) ∨ |={⊤ ∖ ↑ι , ⊤}=> own γfrac DfracDiscarded)) ∗  
                             (⌜ e1 = do: channel1 (SendV (m, bob)) ⌝%E ∗
                              ⌜ e2 = do: channel2 (SendV (m, bob)) ⌝%E)  ∗ 
                             □ (Q (Val #()%V) (Val #()%V)))
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition RecvBobImpl γauth : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: channel1 (RecvV bob) ⌝%E ∗
                ⌜ e2 = do: channel2 (RecvV bob) ⌝%E ∗
                □ (Q NONEV NONEV ∗ (∀ m, own γauth (to_dfrac_agree DfracDiscarded m) -∗ Q (SOMEV m) (SOMEV m)))
             )%I.
  Next Obligation. solve_proper. Qed. 

  Definition X γtoka atokN γtokb btokN γfraca γfracb γautha γauthb : iThy Σ := iThyTraverse [channel1] [channel2]
                                                                     (iThySum (iThySum (SendAliceImpl γtoka γfraca γautha atokN) (RecvBobImpl γauthb))
                                                                        (iThySum (SendBobImpl γtokb γfracb γauthb btokN) (RecvAliceImpl γautha))).
 


  (* Verification of DH_KE ≤ C[DH_real] *)

  
  Lemma DH_KE_C_DH_real f1 f2 γtoka γtokb γfraca γfracb γautha γauthb :
    let X' := X γtoka atokN γtokb btokN γfraca γfracb γautha γauthb in
         (∀ s n, val_subst s n f1 = f1) →
         (∀ s n, val_subst s n f2 = f2) →
         token γtoka -∗
         token γtokb -∗
           own γautha (to_dfrac_agree (DfracOwn 1) #()%V) -∗
           own γauthb (to_dfrac_agree (DfracOwn 1) #()%V) -∗
           REL f1 ≤ f2 <|T|> {{ (λ v1 v2, ⌜v1 = #()%V⌝ ∧ ⌜v2 = #()%V⌝) }} -∗
           REL (DH_KE getKey1 channel1 f1) ≤ (C getKey2 channel2 DH_real f2) <|X'|> {{ (λ v1 v2, ⌜ v1 = v2 ⌝) }}.
  Proof using G.
    iIntros (X' Hf1closed Hf2closed) "Htoka Htokb Ha Hb Hff".
    iApply rel_alloctape_l. iIntros (α) "!> Hα". rel_pures_l.
    iApply rel_alloctape_l. iIntros (β) "!> Hβ". rel_pures_l.
    iApply rel_alloc_l. iIntros (la) "!> Hla".
    iApply rel_alloc_l. iIntros (lb) "!> Hlb".
    rel_pures_r. 
    do 3 rewrite Hf1closed.
    iDestruct "Hα" as (ns) "(%Hf & Hα)". apply map_eq_nil in Hf. simplify_eq.
    iApply rel_couple_TU; [done|]. iFrame. simpl. iIntros (a) "Hα".
    iDestruct "Hβ" as (ms) "(%Hf' & Hβ)". apply map_eq_nil in Hf'. simplify_eq.
    iApply rel_couple_TU; [done|]. iFrame "Hβ". simpl. iIntros (b) "Hβ".
   
    rel_pures_r. rewrite -Nat2Z.inj_mul.
    do 3 rel_exp_r.
    rel_pures_r.
    do 3 rewrite Hf2closed.
    rel_pures_l. do 1 rewrite Hf1closed.
    
    iApply fupd_rel.
    iMod (auth_upd (g ^+ a)%g with "Ha") as "Ha".
    iMod (auth_upd (g ^+ b)%g with "Hb") as "Hb".
    iMod (auth_persist with "Ha") as "#Ha".
    iMod (auth_persist with "Hb") as "#Hb".
    iModIntro.

    iApply fupd_rel.
    iMod (inv_alloc atokN _ (token γtoka ∨ own γfraca DfracDiscarded)%I with "[Htoka]") as "#Hinvta".
    { iNext; iLeft;iFrame. }
    iMod (inv_alloc btokN _ (token γtokb ∨ own γfracb DfracDiscarded)%I with "[Htokb]") as "#Hinvtb".
    { iNext; iFrame. }
    iModIntro.
    
    iApply (rel_na_alloc
              ((β ↪ (n; [b]) ∗ lb ↦ NONEV)
               ∨ (β ↪□ (n; [])
                  ∗ lb ↦□ SOMEV #b)
              )%I
              betaN).
    iSplitL "Hβ Hlb"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinvb".
    
    iApply (rel_na_alloc
              ((α ↪ (n; [a]) ∗ la ↦ NONEV)
               ∨ (α ↪□ (n; [])
                  ∗ la ↦□ SOMEV #a))%I
              alphaN).
    iSplitL "Hα Hla"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinva".
    
    
    iApply (rel_exhaustion [_] [_] _ _ with "[$]").
    iLöb as "IH".
    
    iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
    
    iIntros (e1 e2 ?)
      "[%e1' [%e2' [%k1 [%k2 [%S
           (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
          ]]]]] #Hk".
    
    1 : {
          do 2 rel_pures_l; [apply Hk1; set_solver|].
          do 2rel_pures_r; [apply Hk2; set_solver|].
          iApply (rel_na_inv _ _ alphaN ); [set_solver|].
          iFrame "Hinva". 
          iIntros "([(Hα & Hla) | (#Hα & #Hla)] & Hclose)".
          - iApply (rel_load_l_mask [AppRCtx _; CaseCtx _ _]).
            iFrame. iIntros "!> Hla". rel_pures_l.
            iApply (rel_rand_l _ [AppRCtx _; AppRCtx _]).
            iAssert (α ↪N (n; [fin_to_nat a]))%I with "[Hα]" as "Hα".
            { iExists [a]. simpl. iFrame. done. }
            iFrame. iIntros "!>Hα _". rel_pures_l.
            iApply (rel_store_l _ _ _ [AppRCtx _; AppRCtx _] with "Hla").
            iIntros "!> Hla".
            rel_pures_l.
            iApply (rel_exp_l _ [AppRCtx _]). rel_pures_l.
     
            iApply fupd_rel.
            iMod (ghost_map_elem_persist with "Hla") as "#Hla".
            iDestruct "Hα" as (ns) "(%Hf & Hα)". apply map_eq_nil in Hf. simplify_eq.
            iMod (ghost_map_elem_persist with "Hα") as "#Hα".
            iModIntro.
            iApply rel_na_close. iFrame.
            iSplitL; [iNext; iRight; iFrame "#"|].
            
           
     
            (* Send (gA, bob) *)
            iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
            iApply rel_introduction'.
            iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
            iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
            iLeft. iLeft. 
            iExists _.
            iSplitL.
            { iMod (inv_acc with "Hinvta") as "([>Htok | >#Hfrac'] & Hclose)"; try done.
              - iModIntro. iLeft.
                iIntros. iFrame "#". iFrame.
                iApply "Hclose". iNext. by iRight.
              - iModIntro. iRight. iFrame "#".
                iApply "Hclose". iNext.
                by iRight. }
            iSplit; first ( do 2 (iSplit; try (iPureIntro; done))).
            iModIntro.
            
            (* iApply (rel_na_inv _ _ alphaN ); [set_solver|].
               iFrame "Hinva". 
               iIntros "([(_ & Hcontra & Htoka) | [(_ & _ & >Hcontra) | (_ & _ & Hautha)]] & Hclose)". *)
            
            
            iApply rel_value.
            rel_pures_l.
            rel_pures_r.
     
            (* Recv bob (either none or some) *)
            iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
            iApply rel_introduction'.
            iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
            iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
            iLeft. iRight.
            do 2 (iSplit; try (iPureIntro; done)).
            iModIntro.
            iSplitL.
     
            (* Recv bob = None *)
            + iApply rel_value.
              rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
     
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH".
     
            (* Recv bob = Some gB *)
            + iIntros (m) "Ha'".
              iDestruct (auth_agree with "[$Hb] [$Ha']") as "<-".
              iApply rel_value.
              rel_pures_l. rel_exp_l. 
              rel_pures_r.
              rewrite -expgM. rewrite -ssrnat.multE.
              rewrite -Nat.mul_comm.
              
              iDestruct ("HQ" with "Hsome") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH".
              
          - iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
            iApply (rel_load_l with "Hla"). iIntros "!> _". rel_pures_l. rel_exp_l. rel_pures_l.
     
             (* Send (gA, bob) *)
            iApply (rel_bind' [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|].
            iApply rel_introduction'.
            iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
            iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
            iLeft. iLeft.
            iExists _.
            iSplitL.
            { iMod (inv_acc with "Hinvta") as "([>Htok | >#Hfrac'] & Hclose)"; try done.
              - iModIntro. iLeft.
                iIntros. iFrame "#". iFrame.
                iApply "Hclose". iNext. by iRight.
              - iModIntro. iRight. iFrame "#".
                iApply "Hclose". iNext.
                by iRight. }
            iSplit; first ( do 2 (iSplit; try (iPureIntro; done))).

            iModIntro. 
            iApply rel_value.
            rel_pures_l.
            rel_pures_r.
     
            (* Recv bob (either none or some) *)
            iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
            iApply rel_introduction'.
            iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
            iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
            iLeft. iRight.
            do 2 (iSplit; try (iPureIntro; done)).
            iModIntro.
            iSplitL.
     
            (* Recv bob = None *)
            + iApply rel_value.
              rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
     
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH".
     
            (* Recv bob = Some gB *)
            + iIntros (m) "Ha'".
              iDestruct (auth_agree with "[$Hb] [$Ha']") as "<-".
              iApply rel_value.
              rel_pures_l. rel_exp_l. 
              rel_pures_r.
              rewrite -expgM. rewrite -ssrnat.multE.
              rewrite -Nat.mul_comm.
              
              iDestruct ("HQ" with "Hsome") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH". }

    1 : {
           do 2 rel_pures_l; [apply Hk1; set_solver|]. 
           do 2 rel_pures_r; [apply Hk2; set_solver|].
           iApply (rel_na_inv _ _ betaN ); [set_solver|].
           iFrame "Hinvb". 
           iIntros "(>[(Hβ & Hlb) | #(Hβ & Hlb)] & Hclose)". 
           - iApply (rel_load_l_mask [AppRCtx _; CaseCtx _ _]).
             iFrame. iIntros "!> Hlb". rel_pures_l.
             iApply (rel_rand_l _ [AppRCtx _; AppRCtx _]).
             iAssert (β ↪N (n; [fin_to_nat b]))%I with "[Hβ]" as "Hβ".
             { iExists [b]. simpl. iFrame. done. }
             iFrame. iIntros "!>Hβ _". rel_pures_l.
             iApply (rel_store_l _ _ _ [AppRCtx _; AppRCtx _] with "Hlb").
             iIntros "!> Hlb".
             rel_pures_l.
             iApply (rel_exp_l _ [AppRCtx _]). rel_pures_l.
             
             iApply fupd_rel.
             iMod (ghost_map_elem_persist with "Hlb") as "#Hlb".
             iDestruct "Hβ" as (ns) "(%Hf & Hβ)". apply map_eq_nil in Hf. simplify_eq.
             iMod (ghost_map_elem_persist with "Hβ") as "#Hβ".
             iModIntro.
             iApply rel_na_close. iFrame.
             iSplitL; [iRight; iFrame "#"|].
            
             iApply (rel_bind' [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iRight. iLeft.
             iExists _.
             iSplitL.
             { iMod (inv_acc with "Hinvtb") as "([>Htok | >#Hfrac'] & Hclose)"; try done.
               - iModIntro. iLeft.
                 iIntros. iFrame "#". iFrame.
                 iApply "Hclose". iNext. by iRight.
               - iModIntro. iRight. iFrame "#".
                 iApply "Hclose". iNext.
                 by iRight. }
             iSplit; first ( do 2 (iSplit; try (iPureIntro; done))).
             iModIntro.
             
             iApply rel_value.
             rel_pures_l.
             rel_pures_r.
     
             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iRight. iRight.
             do 2 (iSplit; try (iPureIntro; done)).
             iModIntro.
             iSplitL.

            + iApply rel_value.
              rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
     
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH".

            + iIntros (m) "Hb'".
              iDestruct (auth_agree with "[$Ha] [$Hb']") as "<-".
              iApply rel_value.
              rel_pures_l. rel_exp_l. 
              rel_pures_r.
              rewrite -expgM. rewrite -ssrnat.multE.
              rewrite -Nat.mul_comm.
              
              iDestruct ("HQ" with "Hsome") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH".
              
          - iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
            iApply (rel_load_l with "Hlb"). iIntros "!> _". rel_pures_l. rel_exp_l. rel_pures_l.
     
            iApply (rel_bind' [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|].
            iApply rel_introduction'.
            iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
            iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
            iRight. iLeft.
            iExists _.
            iSplitL.
            { iMod (inv_acc with "Hinvtb") as "([>Htok | >#Hfrac'] & Hclose)"; try done.
              - iModIntro. iLeft.
                iIntros. iFrame "#". iFrame.
                iApply "Hclose". iNext. by iRight.
              - iModIntro. iRight. iFrame "#".
                iApply "Hclose". iNext.
                by iRight. }
            iSplit; first ( do 2 (iSplit; try (iPureIntro; done))).

            iModIntro. 
            iApply rel_value.
            rel_pures_l.
            rel_pures_r.
     
            iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
            iApply rel_introduction'.
            iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
            iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
            iRight. iRight.
            do 2 (iSplit; try (iPureIntro; done)).
            iModIntro.
            iSplitL.
     
            + iApply rel_value.
              rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
     
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH".
     
            (* Recv bob = Some gB *)
            + iIntros (m) "Hb'".
              iDestruct (auth_agree with "[$Ha] [$Hb']") as "<-".
              iApply rel_value.
              rel_pures_l. rel_exp_l. 
              rel_pures_r.
              rewrite -expgM. rewrite -ssrnat.multE.
              rewrite -Nat.mul_comm.
              
              iDestruct ("HQ" with "Hsome") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH". }
  Qed.

  (* Verification of F_AUTH ≤ F_AUTH *)

  Lemma F_AUTH_F_AUTH f1 f2 γtoka γtokb γfraca γfracb γautha γauthb :
    let X' := X γtoka atokN γtokb btokN γfraca γfracb γautha γauthb in
    (∀ s n, val_subst s n f1 = f1) →
    (∀ s n, val_subst s n f2 = f2) →
    own γfraca (DfracOwn 1) -∗
    own γfracb (DfracOwn 1) -∗
     REL f1 ≤ f2 <|X'|> {{ (λ v1 v2, ⌜ v1 = v2 ⌝) }} -∗
           REL F_AUTH channel1 f1 ≤ F_AUTH channel2 f2 <|Y|> {{ (λ v1 v2, ⌜ v1 = v2 ⌝) }}.
  Proof using G cg channel1 channel2 inG1 inG2 inG3 probblazeRGS0 vg Σ.
    iIntros (X' Hf1closed Hf2closed) "Hfraca Hfracb Hff".
    iApply rel_alloc_l. iIntros (l1) "!> Hl1".
    iApply rel_alloc_l. iIntros (l2) "!> Hl2".
    rel_pures_l. do 2 rewrite Hf1closed.
    iApply rel_alloc_r. iIntros (l1') "Hl1s".
    iApply rel_alloc_r. iIntros (l2') "Hl2s".
    rel_pures_r. do 2 rewrite Hf2closed.

    iApply (rel_na_alloc
              ((l1 ↦ NONEV ∗ l1'  ↦ₛ NONEV ∗ own γfraca (DfracOwn 1))
               ∨ (∃ gA , l1 ↦□ SOMEV gA∗ l1' ↦ₛ□ SOMEV gA ∗ token γtoka
                         ∗ own γfraca DfracDiscarded
                         ∗ own γautha (to_dfrac_agree DfracDiscarded gA))) alphaN).
    iSplitL "Hl1 Hl1s Hfraca"; [iNext; iLeft; iFrame|].
    iIntros "#Hinva".

    iApply (rel_na_alloc
              ((l2 ↦ NONEV ∗ l2'  ↦ₛ NONEV ∗ own γfracb (DfracOwn 1))
               ∨ (∃ gB , l2 ↦□ SOMEV gB∗ l2' ↦ₛ□ SOMEV gB ∗ token γtokb
                         ∗ own γfracb DfracDiscarded
                         ∗ own γauthb (to_dfrac_agree DfracDiscarded gB))) betaN).
    iSplitL "Hl2 Hl2s Hfracb"; [iNext; iLeft; iFrame|].
    iIntros "#Hinvb".
    
    iApply (rel_exhaustion [_] [_] _ _ with "[$]").
    iLöb as "IH".
    iSplit; [iIntros (v1 v2) "->"; rel_pures_l; by rel_pures_r|].
    iIntros (e1 e2 ?)
              "[%e1' [%e2' [%k1 [%k2 [%S
              (-> & %Hk1 & -> & %Hk2 &
              [[(%m & Hupd & (-> & ->) & #HS) | (-> & -> & #(Hnone & Hsome))]
                     | [(%m & Hupd & (-> & ->) & #HS) | (-> & -> & #(Hnone & Hsome))]]
                         & #HQ)]]]]] #Hk".
    1 : {
      iApply (rel_na_inv _ _ alphaN ); [set_solver|].
      iFrame "Hinva". 
      iIntros "(>[(Hl1 & Hl1s & Hfraca) | (%gA & #Hl1 & #Hl1s & Htoka & #Hfraca & #Hautha)] & Hclose)".
      - iApply fupd_rel. iMod "Hupd" as "[Hupd | Hupd]"; [|iMod "Hupd"; iModIntro].
        2 : { by iDestruct (dfrac_contra with "[Hupd][$]") as "Hcontra". }
        iMod (dfrac_persist with "Hfraca") as "#Hfraca".
        iMod ("Hupd" with "Hfraca") as "Hupd".
        iModIntro.
        rel_pures_l; [apply Hk1; set_solver|].
        rel_pures_r; [apply Hk2; set_solver|].
        iApply (rel_load_l_mask [CaseCtx _ _]). iFrame. iIntros "!> Hl1".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
        rel_pures_l. rel_pures_r.
        iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1"). iIntros "!> Hl1".
        iApply (rel_store_r _ _ _ _ [AppRCtx _] with "Hl1s"). iIntros "Hl1s".
        rel_pures_l. rel_pures_r.
        iApply (rel_bind_mask _ [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|iApply iThy_le_refl|].

        iApply fupd_rel.
        iMod (ghost_map_elem_persist with "Hl1s") as "#Hl1s".
        iMod (ghost_map_elem_persist with "Hl1") as "#Hl1".
        iModIntro.
        iApply rel_na_close. iFrame.
        iSplitL "Hupd"; [iNext; iRight; iExists m; iFrame "#"; iFrame|].

        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iLeft. iRight.
        iExists _.
        do 2 (iSplit; try (iPureIntro; done)).
        iModIntro.
        iApply rel_value.
        rel_pures_l. rel_pures_r.

        iDestruct ("HQ" with "HS") as "HQk".
        iDestruct ("Hk" with "HQk") as "Hrelk".
        iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH".

      - iApply fupd_rel. iMod "Hupd" as "[Hupd | Hupd]"; [|iMod "Hupd"; iModIntro].
        1 : { iMod ("Hupd" with "Hfraca") as "(Hcontra & _)". by iDestruct (token_agree with "[$][$]") as "Hcontra". }
        iApply rel_na_close. iFrame.
        iSplitL "Htoka"; [iNext; iRight; iExists gA; iFrame; iFrame "#"|].
        rel_pures_l; [apply Hk1; set_solver|].
        rel_pures_r; [apply Hk2; set_solver|].
        iApply (rel_load_l_mask [CaseCtx _ _]). iFrame "#". iIntros "!> _".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "_".
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "HS") as "HQk".
        iDestruct ("Hk" with "HQk") as "Hrelk".
        iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH". }

    1 : { rel_pures_l; [apply Hk1; set_solver|].
          rel_pures_r; [apply Hk2; set_solver|].
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iRight. do 2 (iSplit; try (iPureIntro; done)).
          iModIntro.
          iSplit; last first.

          + iApply rel_value.
            iDestruct ("HQ" with "Hnone") as "HQk".
            iDestruct ("Hk" with "HQk") as "Hrelk".
            iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH".

          + iIntros (b1 b2). iApply rel_value.
            rel_pures_l. rel_pures_r.
            iApply (rel_na_inv _ _ betaN); [set_solver|].
            iFrame "Hinvb". 
            iIntros "(>[(Hl2 & Hl2s & Hfracb) | (%gB & #Hl2 & #Hl2s & Htokb & #Hfracb & #Hauthb)] & Hclose)".
            * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
              iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s". rel_pures_l.
              iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame|].
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion_mask _ [_] [_] with "[$]"). iApply "IH".
              
            * iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"; iFrame|].
              iApply (rel_load_l with "Hl2"). iIntros "!> _".
              iApply (rel_load_r with "Hl2s"). iIntros "_". 
              rel_pures_r. rel_pures_l.
              iDestruct ("Hsome" with "Hauthb") as "HS".
              iDestruct ("HQ" with "HS") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH". }
          
    1 : {
      iApply (rel_na_inv _ _ betaN ); [set_solver|].
      iFrame "Hinvb". 
      iIntros "(>[(Hl2 & Hl2s & Hfracb) | (%gB & #Hl2 & #Hl2s & Htokb & #Hfracb & #Hauthb)] & Hclose)".
      - iApply fupd_rel. iMod "Hupd" as "[Hupd | Hupd]"; [|iMod "Hupd"; iModIntro].
        2 : { by iDestruct (dfrac_contra with "[Hupd][$]") as "Hcontra". }
        iMod (dfrac_persist with "Hfracb") as "#Hfracb".
        iMod ("Hupd" with "Hfracb") as "Hupd".
        iModIntro.
        rel_pures_l; [apply Hk1; set_solver|].
        rel_pures_r; [apply Hk2; set_solver|].
        iApply (rel_load_l_mask [CaseCtx _ _]). iFrame. iIntros "!> Hl2".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
        rel_pures_l. rel_pures_r.
        iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl2"). iIntros "!> Hl2".
        iApply (rel_store_r _ _ _ _ [AppRCtx _] with "Hl2s"). iIntros "Hl2s".
        rel_pures_l. rel_pures_r.
        iApply (rel_bind_mask _ [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|iApply iThy_le_refl|].

        iApply fupd_rel.
        iMod (ghost_map_elem_persist with "Hl2s") as "#Hl2s".
        iMod (ghost_map_elem_persist with "Hl2") as "#Hl2".
        iModIntro.
        iApply rel_na_close. iFrame.
        iSplitL "Hupd"; [iNext; iRight; iExists m; iFrame "#"; iFrame|].

        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iLeft. iLeft.
        iExists _.
        do 2 (iSplit; try (iPureIntro; done)).
        iModIntro.
        iApply rel_value.
        rel_pures_l. rel_pures_r.

        iDestruct ("HQ" with "HS") as "HQk".
        iDestruct ("Hk" with "HQk") as "Hrelk".
        iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH".

      - iApply fupd_rel. iMod "Hupd" as "[Hupd | Hupd]"; [|iMod "Hupd"; iModIntro].
        1 : { iMod ("Hupd" with "Hfracb") as "(Hcontra & _)". by iDestruct (token_agree with "[$][$]") as "Hcontra". }
        iApply rel_na_close. iFrame.
        iSplitL "Htokb"; [iNext; iRight; iExists gB; iFrame; iFrame "#"|].
        rel_pures_l; [apply Hk1; set_solver|].
        rel_pures_r; [apply Hk2; set_solver|].
        iApply (rel_load_l_mask [CaseCtx _ _]). iFrame "#". iIntros "!> _".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "_".
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "HS") as "HQk".
        iDestruct ("Hk" with "HQk") as "Hrelk".
        iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH". }

    1 : { rel_pures_l; [apply Hk1; set_solver|].
          rel_pures_r; [apply Hk2; set_solver|].
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iLeft. do 2 (iSplit; try (iPureIntro; done)).
          iModIntro.
          iSplit; last first.

          + iApply rel_value.
            iDestruct ("HQ" with "Hnone") as "HQk".
            iDestruct ("Hk" with "HQk") as "Hrelk".
            iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH".

          + iIntros (b1 b2). iApply rel_value.
            rel_pures_l. rel_pures_r.
            iApply (rel_na_inv _ _ alphaN); [set_solver|].
            iFrame "#". 
            iIntros "(>[(Hl1 & Hl1s & Hfraca) | (%gA & #Hl1 & #Hl1s & Htoka & #Hfraca & #Hautha)] & Hclose)".
            * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl1".
              iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s". rel_pures_l.
              iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame|].
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion_mask _ [_] [_] with "[$]"). iApply "IH".
              
            * iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"; iFrame|].
              iApply (rel_load_l with "Hl1"). iIntros "!> _".
              iApply (rel_load_r with "Hl1s"). iIntros "_". 
              rel_pures_r. rel_pures_l.
              iDestruct ("Hsome" with "Hautha") as "HS".
              iDestruct ("HQ" with "HS") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH". }
  Qed.


  (* Verification of F_AUTH[DH_KE] ≤ F_AUTH[C[DH_real]] *)

  Lemma F_ATUH_DH_KE_FAUTH_C_DH_real f1 f2 :
    (∀ s n, val_subst s n f1 = f1) →
    (∀ s n, val_subst s n f2 = f2) →
    REL f1 ≤ f2 <|T|> {{ λ v1 v2, ⌜ v1 = #()%V ∧ v2 = #()%V ⌝ }} -∗
    REL F_AUTH channel1 (DH_KE getKey1 channel1 f1) ≤ F_AUTH channel2 (C getKey2 channel2 DH_real f2) <|Y|> {{ λ v1 v2, ⌜ v1 = v2 ⌝ }}.
  Proof.
    iIntros (Hf1closed Hf2closed) "Hff".
    
    iApply fupd_rel.
    iMod token_alloc as (γtoka) "Htoka".
    iMod token_alloc as (γtokb) "Htokb".
    iMod (auth_alloc (#()%V)) as (γautha) "Hautha".
    iMod (auth_alloc (#()%V)) as (γauthb) "Hauthb".
    iMod dfrac_alloc as (γfraca) "Hfraca".
    iMod dfrac_alloc as (γfracb) "Hfracb".                         
    iModIntro.

    iApply (F_AUTH_F_AUTH with "[$][$]"); [admit|admit |].
    1 : {
      simpl. 
    iApply (DH_KE_C_DH_real with "[$][$][$][$]"); eauto.

    iApply (rel_wand with "[$]").
    iModIntro. by iIntros (v1 v2 Heq).
  Admitted.                           
    
    
  
End handlee_verification.
