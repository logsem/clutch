From iris.proofmode Require Import base tactics classes.
From iris.base_logic.lib Require Import  na_invariants.
From clutch Require Import stdpp_ext.
From clutch.prob_eff_lang.probblaze Require Import logic primitive_laws proofmode
  spec_rules spec_ra 
  class_instances.
From clutch.prob_eff_lang.probblaze Require Import definition.

Import fingroup.

Import fingroup.fingroup.

Import valgroup_notation.
Import valgroup_tactics.


Section verification.
  Context `{!probblazeRGS Σ}.
  Context (channel1 channel2 getKey1 getKey2 : label).
  Context {vg : val_group}.           (* A group on a subset of values. *)
  Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
  Context {G : clutch_group (vg:=vg) (cg:=cg)}.
  Context {vgg : @val_group_generator vg}.   (* G is generated by g. *)

  (* Theories *)
  (* GetKey theory for client *)
  Program Definition GetKey1 : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: getKey1 (InjL #()%V) ⌝%E ∗
                ⌜ e2 = do: getKey2 (InjL #()%V) ⌝%E ∗
                □ (Q NONEV NONEV ∗ ∀ key : vgG, Q (SOMEV key) (SOMEV key) )
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition GetKey2 : iThy Σ :=
     λ e1 e2, (λne Q,
                ⌜ e1 = do: getKey1 (InjR #()%V) ⌝%E ∗
                ⌜ e2 = do: getKey2 (InjR #()%V) ⌝%E ∗
                □ (Q NONEV NONEV ∗ ∀ key : vgG, Q (SOMEV key) (SOMEV key) )
             )%I.
  Next Obligation. solve_proper. Qed.

  Definition Tf : iThy Σ := iThyTraverse [getKey1] [getKey2] (iThySum GetKey1 GetKey2).

  (* Theories for authenticated channel *)
      
  Program Definition SendBob : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : val,
                ⌜ e1 = do: channel1 (SendV (m, bob)) ⌝%E ∗
                  ⌜ e2 = do: channel2 (SendV (m, bob)) ⌝%E ∗
                   □ Q (Val #()%V) (Val #()%V)
             )%I. 
  Next Obligation. solve_proper. Qed.

  Program Definition SendAlice : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : val, 
                  ⌜ e1 = do: channel1 (SendV (m, alice)) ⌝%E ∗
                  ⌜ e2 = do: channel2 (SendV (m, alice)) ⌝%E ∗
                  □ Q (Val #()%V) (Val #()%V)
             )%I. 
  Next Obligation. solve_proper. Qed.

   Program Definition RecvBobAuth : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: channel1 (RecvV bob) ⌝%E ∗
                ⌜ e2 = do: channel2 (RecvV bob) ⌝%E ∗
                □ ((∀ b1 b2 : nat, Q (SOMEV #b1) (SOMEV #b2)) ∧ Q NONEV NONEV)
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition RecvAliceAuth : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: channel1 (RecvV alice) ⌝%E ∗
                ⌜ e2 = do: channel2 (RecvV alice) ⌝%E ∗
                □ ((∀ b1 b2 : nat, Q (SOMEV #b1) (SOMEV #b2)) ∧ Q NONEV NONEV)
             )%I.
  Next Obligation. solve_proper. Qed.

  Definition Y : iThy Σ := iThyTraverse [channel1] [channel2] (iThySum (iThySum SendAlice SendBob) (iThySum RecvAliceAuth RecvBobAuth)).
  
  #[local] Notation n := (S n'').

  (* Verification of F_AUTH[DH_KE] ≤ F_AUTH[C[DH_real]] *)

  Definition alphaN : namespace := nroot .@ "alpha".
  Definition betaN : namespace := nroot .@ "beta".

  Lemma F_AUTH_DH_KE_C_DH_real f1 f2 :
    (∀ s n, val_subst s n f1 = f1) →
           (∀ s n, val_subst s n f2 = f2) →
           REL f1 ≤ f2 <|Tf|> {{ (λ v1 v2, ⌜v1 = #()%V⌝ ∧ ⌜v2 = #()%V⌝) }} -∗
           REL F_AUTH channel1 (DH_KE getKey1 channel1 f1) ≤ F_AUTH channel2 (C getKey2 channel2 DH_real f2) <|Y|> {{ (λ v1 v2, ⌜ v1 = v2 ⌝) }}.
  Proof using G.
    iIntros (Hf1closed Hf2closed) "Hff".
    iApply rel_alloc_l. iIntros (l1) "!> Hl1".
    iApply rel_alloc_l. iIntros (l2) "!> Hl2".
    iApply rel_alloctape_l. iIntros (α) "!> Hα". rel_pures_l.
    iApply rel_alloctape_l. iIntros (β) "!> Hβ". rel_pures_l.
    iApply rel_alloc_l. iIntros (la) "!> Hla".
    iApply rel_alloc_l. iIntros (lb) "!> Hlb".
    iApply rel_alloc_r. iIntros (l1') "Hl1s".
    iApply rel_alloc_r. iIntros (l2') "Hl2s".
    rel_pures_r. 
    do 4 rewrite Hf1closed.
    iDestruct "Hα" as (ns) "(%Hf & Hα)". apply map_eq_nil in Hf. simplify_eq.
    iApply rel_couple_TU; [done|]. iFrame. simpl. iIntros (a) "Hα".
    iDestruct "Hβ" as (ms) "(%Hf' & Hβ)". apply map_eq_nil in Hf'. simplify_eq.
    iApply rel_couple_TU; [done|]. iFrame "Hβ". simpl. iIntros (b) "Hβ".
    rel_pures_r. rewrite -Nat2Z.inj_mul.
    do 3 rel_exp_r.
    rel_pures_r.
    do 5 rewrite Hf2closed.
    rel_pures_l. do 2 rewrite Hf1closed.
    
    iApply (rel_na_alloc
              ((β ↪ (n; [b]) ∗ l2 ↦ NONEV ∗ l2' ↦ₛ NONEV ∗ lb ↦ NONEV)
                ∨ (β ↪□ (n; [])
                   ∗ l2 ↦□ SOMEV (g ^+ b)%g
                   ∗ l2' ↦ₛ□ SOMEV (g ^+ b)%g
                   ∗ lb ↦□ SOMEV #b))%I
              betaN).
    iSplitL "Hl2 Hl2s Hβ Hlb"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinvb".

    iApply (rel_na_alloc
              ((α ↪ (n; [a]) ∗ l1 ↦ NONEV ∗ l1' ↦ₛ NONEV ∗ la ↦ NONEV)
                ∨ (α ↪□ (n; [])
                   ∗ l1 ↦□ SOMEV (g ^+ a)%g
                   ∗ l1' ↦ₛ□ SOMEV (g ^+ a)%g
                   ∗ la ↦□ SOMEV #a))%I
              alphaN).
    iSplitL "Hα Hl1 Hl1s Hla"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinva".
    
    iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
    iLöb as "IH".
    
    iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
    iIntros (e1 e2 ?)
      "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".
    
    (* getKey1 first time *)
    1 : {
    do 2 rel_pures_l; [apply Hk1; set_solver|]. 
    do 2rel_pures_r; [split;[apply Hk2; set_solver|set_solver]|].
    iApply (rel_na_inv _ _ alphaN ); [set_solver|].
    iFrame "Hinva". 
    iIntros "(>[(Hα & Hl1 & Hl1s & Hla) | #(Hα & Hl1 & Hl1s &Hla)] & Hclose)". 
    -     
      iApply (rel_load_l_mask [HandleCtx _ _ _ ; AppRCtx _; CaseCtx _ _]).
      iFrame. iIntros "!> Hla". rel_pures_l.
      iApply (rel_rand_l _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _]).
      iAssert (α ↪N (n; [fin_to_nat a]))%I with "[Hα]" as "Hα".
      { iExists [a]. simpl. iFrame. done. }
      iFrame. iIntros "!>Hα _". rel_pures_l.
      iApply (rel_store_l _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hla").
      iIntros "!> Hla".
      rel_pures_l.
      iApply (rel_exp_l _ [HandleCtx _ _ _ ; AppRCtx _]).
      rel_pures_l; [set_solver|].
      iApply (rel_load_l_mask [CaseCtx _ _]). iFrame. iIntros "!> Hl1".
      iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
      rel_pures_l. rel_pures_r.
      iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1"). iIntros "!> Hl1".
      iApply (rel_store_r _ _ _ _ [AppRCtx _] with "Hl1s"). iIntros "Hl1s".
      rel_pures_l.
      rel_pures_r.
      
      (* Send gA first time *)
      iApply (rel_bind_mask (⊤ ∖ ↑alphaN) [AppRCtx _] [AppRCtx _]);
        [by iApply traversable_iThyTraverse|iApply iThy_le_refl|].
      
      iApply fupd_rel.
      iMod (ghost_map_elem_persist with "Hl1s") as "#Hl1s".
      iMod (ghost_map_elem_persist with "Hl1") as "#Hl1".
      iMod (ghost_map_elem_persist with "Hla") as "#Hla".
      iDestruct "Hα" as (ns) "(%Hf & Hα)". apply map_eq_nil in Hf. simplify_eq.
      iMod (ghost_map_elem_persist with "Hα") as "#Hα".
      iModIntro.
      iApply rel_na_close. iFrame.
      iSplitL; [iRight; iFrame "#"|]. fold Y.
      
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iLeft. iRight.
      iExists _. do 2 (iSplit; try (iPureIntro; done)).
      iModIntro.
      iApply rel_value.
      rel_pures_l; [set_solver|]. 
      rel_pures_r; [set_solver|].
    
      (* Recv bob first time (either none or some) *)
      iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iRight. iRight.
      do 2 (iSplit; try (iPureIntro; done)). iModIntro.
      iSplit; last first.

    (* Recv bob = None *)
      + iApply rel_value.
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "Hnone") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".

        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]"). iApply "IH".

      (* Recv bob = Some b *)
      + iIntros (b1 b2). iApply rel_value.
        rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ betaN ); [set_solver|].
        iFrame "Hinvb". 
        iIntros "(>[(Hβ & Hl2 & Hl2s & Hlb) | #(Hβ & Hl2 & Hl2s &Hlb)] & Hclose)". 
        * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s". rel_pures_l.
          iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame; iDestruct "Hbeta" as (ms) "(%Hf' & Hβ)"; apply map_eq_nil in Hf'; simplify_eq; done|].
          iDestruct ("HQ" with "Hnone") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
          (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".
        
        * iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
          iApply (rel_load_l with "Hl2"). iIntros "!> _".
          iApply (rel_load_r with "Hl2s"). iIntros "_". rel_pures_l.
          rel_pures_r.
          rel_exp_l. rel_pures_l.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
        (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".

    - iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
      iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
      iApply (rel_load_r with "Hl1s"). iIntros "_".
      iApply (rel_load_l with "Hla"). iIntros "!> _". rel_pures_l. iModIntro.
      rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|].
      rel_pures_r; [set_solver|]. 
      iApply (rel_load_l with "Hl1"). iIntros "!> _".
      rel_pures_l; [set_solver|].
      iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iRight. iRight.
      do 2 (iSplit; try (iPureIntro; done)). iModIntro.
      iSplit.
      2 : { iApply rel_value. rel_pures_l. rel_pures_r.
            iDestruct ("HQ" with "Hnone") as "HQfill".
            iDestruct ("Hk" with "HQfill") as "Hfillrel".
            iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
            iApply "IH". }
      iIntros (b1 b2).
      iApply rel_value. rel_pures_l. rel_pures_r.
      iApply (rel_na_inv _ _ betaN ); [set_solver|].
      iFrame "Hinvb". 
      iIntros "(>[(Hβ & Hl2 & Hl2s & Hlb) | #(Hβ & Hl2 & Hl2s &Hlb)] & Hclose)". 
      * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
        iApply rel_na_close. iFrame. iSplitR "Hla"; [iLeft; iFrame| ]. 
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "Hnone") as "HQnone".
        iDestruct ("Hk" with "HQnone") as "Hknone".
        iApply (rel_exhaustion [_;_] [_;_] with "[$]").
        iApply "IH".
      * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame "Hl2". iIntros "!> _".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "_".
        iApply rel_na_close. iFrame. iSplitR "Hla"; [iRight; iFrame "#"| ]. simpl.
        rel_pures_l. rel_pures_r.
        rel_exp_l. rel_pures_l.
        rewrite -expgM. rewrite -ssrnat.multE.
        rewrite -Nat.mul_comm.
        iDestruct ("HQ" with "Hsome") as "HQsome".
        iDestruct ("Hk" with "HQsome") as "Hksome".
        iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
        iApply "IH". }

    1 : {
      do 2 rel_pures_l; [apply Hk1; set_solver|]. 
      do 2rel_pures_r; [split;[apply Hk2; set_solver|set_solver]|].
      iApply (rel_na_inv _ _ betaN ); [set_solver|].
      iFrame "Hinvb". 
      iIntros "(>[(Hβ & Hl1 & Hl1s & Hlb) | #(Hβ & Hl1 & Hl1s &Hlb)] & Hclose)". 
      - iApply (rel_load_l_mask [HandleCtx _ _ _ ; AppRCtx _; CaseCtx _ _]).
        iFrame. iIntros "!> Hlb". rel_pures_l.
        iApply (rel_rand_l _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _]).
        iAssert (β ↪N (n; [fin_to_nat b]))%I with "[Hβ]" as "Hβ".
        { iExists [b]. simpl. iFrame. done. }
        iFrame. iIntros "!>Hβ _". rel_pures_l.
        iApply (rel_store_l _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hlb").
        iIntros "!> Hlb".
        rel_pures_l.
        iApply (rel_exp_l _ [HandleCtx _ _ _ ; AppRCtx _]).
        rel_pures_l; [set_solver|].
        iApply (rel_load_l_mask [CaseCtx _ _]). iFrame. iIntros "!> Hl1".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
        rel_pures_l. rel_pures_r.
        iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1"). iIntros "!> Hl1".
        iApply (rel_store_r _ _ _ _ [AppRCtx _] with "Hl1s"). iIntros "Hl1s".
        rel_pures_l.
        rel_pures_r.
      
        (* Send gB first time *)
        iApply (rel_bind_mask _ [AppRCtx _] [AppRCtx _]);
          [by iApply traversable_iThyTraverse|iApply iThy_le_refl |].
      
        iApply fupd_rel.
        iMod (ghost_map_elem_persist with "Hl1s") as "#Hl1s".
        iMod (ghost_map_elem_persist with "Hl1") as "#Hl1".
        iMod (ghost_map_elem_persist with "Hlb") as "#Hlb".
        iDestruct "Hβ" as (ns) "(%Hf & Hβ)". apply map_eq_nil in Hf. simplify_eq.
        iMod (ghost_map_elem_persist with "Hβ") as "#Hβ".
        iModIntro.
        iApply rel_na_close. iFrame.
        iSplitL; [iRight; iFrame "#"|]. fold Y.
        
        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iLeft. iLeft.
        iExists _. do 2 (iSplit; try (iPureIntro; done)).
        iModIntro.
        iApply rel_value.
        rel_pures_l; [set_solver|].
        rel_pures_r; [set_solver|].
    
        (* Recv alice (either none or some) *)
        iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iRight. iLeft.
        do 2 (iSplit; try (iPureIntro; done)). iModIntro.
        iSplit; last first.

        (* Recv alice = None *)
        + iApply rel_value.
          rel_pures_l. rel_pures_r.
          iDestruct ("HQ" with "Hnone") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".

          (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]"). iApply "IH".

        (* Recv alice = Some a *)
        + iIntros (a1 a2). iApply rel_value.
          rel_pures_l. rel_pures_r.
          iApply (rel_na_inv _ _ alphaN ); [set_solver|].
          iFrame "Hinva". 
          iIntros "(>[(Hα & Hl2 & Hl2s & Hla) | #(Hα & Hl2 & Hl2s &Hla)] & Hclose)". 
          * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
            iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s". rel_pures_l.
            iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame; iDestruct "Hα" as (ms) "(%Hf' & Hα)"; apply map_eq_nil in Hf'; simplify_eq; done|].
            iDestruct ("HQ" with "Hnone") as "HQfill".
            iDestruct ("Hk" with "HQfill") as "Hfillrel".
            iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
            
            (* First call is done. Can call getKey1 or getKey2 again. *)
            iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".
            
          * iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
            iApply (rel_load_l with "Hl2"). iIntros "!> _".
            iApply (rel_load_r with "Hl2s"). iIntros "_". rel_pures_l.
            rel_pures_r.
            rel_exp_l. rel_pures_l.
            rewrite -expgM. rewrite -ssrnat.multE.
            rewrite -Nat.mul_comm.
            iDestruct ("HQ" with "Hsome") as "HQfill".
            iDestruct ("Hk" with "HQfill") as "Hfillrel".
            iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
        (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".

      - iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
        iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
        iApply (rel_load_r with "Hl1s"). iIntros "_".
        iApply (rel_load_l with "Hlb"). iIntros "!> _". rel_pures_l. iModIntro.
        rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|]. 
        rel_pures_r; [set_solver|].
        iApply (rel_load_l with "Hl1"). iIntros "!> _".
        rel_pures_l; [set_solver|].
        iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iRight. iLeft.
        do 2 (iSplit; try (iPureIntro; done)). iModIntro.
        iSplit.
        2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }
        iIntros (a1 a2).
        iApply rel_value. rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ alphaN ); [set_solver|].
        iFrame "Hinva". 
        iIntros "(>[(Hα & Hl2 & Hl2s & Hla) | #(Hα & Hl2 & Hl2s &Hla)] & Hclose)". 
      * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
        iApply rel_na_close. iFrame. iSplitR "Hlb"; [iLeft; iFrame| ]. 
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "Hnone") as "HQnone".
        iDestruct ("Hk" with "HQnone") as "Hknone".
        iApply (rel_exhaustion [_;_] [_;_] with "[$]").
        iApply "IH".
      * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame "Hl2". iIntros "!> _".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "_".
        iApply rel_na_close. iFrame. iSplitR "Hlb"; [iRight; iFrame "#"| ]. simpl.
        rel_pures_l. rel_pures_r.
        rel_exp_l. rel_pures_l.
        rewrite -expgM. rewrite -ssrnat.multE.
        rewrite -Nat.mul_comm.
        iDestruct ("HQ" with "Hsome") as "HQsome".
        iDestruct ("Hk" with "HQsome") as "Hksome".
        iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
        iApply "IH". }
  Qed.

  (* Verification of F_AUTH[C[DH_real]] ≤ F_AUTH[DH_KE] *)


  Lemma F_AUTH_C_DH_real_DH_KE f1 f2 :
    (∀ s n, val_subst s n f1 = f1) →
           (∀ s n, val_subst s n f2 = f2) →
           REL f1 ≤ f2 <|Tf|> {{ (λ v1 v2, ⌜v1 = #()%V⌝ ∧ ⌜v2 = #()%V⌝) }} -∗
           REL F_AUTH channel1 (C getKey1 channel1 DH_real f1) ≤ F_AUTH channel2 (DH_KE getKey2 channel2 f2)  <|Y|> {{ (λ v1 v2, ⌜ v1 = v2 ⌝) }}.
  Proof using G.
    iIntros (Hf1closed Hf2closed) "Hff".
    iApply rel_alloc_r. iIntros (l1) "Hl1".
    iApply rel_alloc_r. iIntros (l2) "Hl2".
    iApply rel_alloctape_r. iIntros (α) "Hα". rel_pures_r.
    iApply rel_alloctape_r. iIntros (β) "Hβ". rel_pures_r.
    iApply rel_alloc_r. iIntros (la) "Hla".
    iApply rel_alloc_r. iIntros (lb) "Hlb".
    iApply rel_alloc_l. iIntros (l1') "!> Hl1'".
    iApply rel_alloc_l. iIntros (l2') "!> Hl2'".
    rel_pures_l. 
    do 4 rewrite Hf2closed.
    iApply rel_couple_UT. iFrame "Hα". simpl. iIntros (a) "!> %Hlt Hα".
    iApply rel_couple_UT. iFrame "Hβ". simpl. iIntros (b) "!> %_ Hβ".

    rel_pures_l. rewrite -Nat2Z.inj_mul.
    do 3 rel_exp_l.
    rel_pures_l.
    do 5 rewrite Hf1closed.
    rel_pures_r. do 2 rewrite Hf2closed.

    iApply (rel_na_alloc
              ((β ↪ₛ (n; [b]) ∗ l2 ↦ₛ NONEV ∗ l2' ↦ NONEV ∗ lb ↦ₛ NONEV)
               ∨ (β ↪ₛ□ (n; [])
                  ∗ l2 ↦ₛ□ SOMEV (g ^+ b)%g
                  ∗ l2' ↦□ SOMEV (g ^+ b)%g
                  ∗ lb ↦ₛ□ SOMEV #b))%I
              betaN).
    iSplitL "Hl2 Hl2' Hβ Hlb"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinvb".

    iApply (rel_na_alloc
              ((α ↪ₛ (n; [a]) ∗ l1 ↦ₛ NONEV ∗ l1' ↦ NONEV ∗ la ↦ₛ NONEV)
               ∨ (α ↪ₛ□ (n; [])
                  ∗ l1 ↦ₛ□ SOMEV (g ^+ a)%g
                  ∗ l1' ↦□ SOMEV (g ^+ a)%g
                  ∗ la ↦ₛ□ SOMEV #a))%I
              alphaN).
    iSplitL "Hα Hl1 Hl1' Hla"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinva".
    
    iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
    iLöb as "IH".
    
    iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
    iIntros (e1 e2 ?)
      "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".
    
    (* getKey1 first time *)
    1 : {
    do 2 rel_pures_r; [apply Hk2; set_solver|]. 
    do 2rel_pures_l; [split;[apply Hk1; set_solver|set_solver]|].
    iApply (rel_na_inv _ _ alphaN ); [set_solver|].
    iFrame "Hinva". 
    iIntros "(>[(Hα & Hl1 & Hl1' & Hla) | #(Hα & Hl1 & Hl1' &Hla)] & Hclose)".
    - iApply (rel_load_r_with_mask _ _ _ _ [HandleCtx _ _ _ ; AppRCtx _; CaseCtx _ _] with "Hla").
      iIntros "Hla". rel_pures_r.
      iAssert (α ↪ₛN (n; [fin_to_nat a]))%I with "[Hα]" as "Hα".
      { iExists [a]. simpl. iFrame. done. }
      iApply (rel_rand_r [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hα").
      iIntros "Hα ?". rel_pures_r.
      iApply (rel_store_r _ _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hla"). iIntros "Hla".
      rel_pures_r.
      iApply (rel_exp_r _ [HandleCtx _ _ _; AppRCtx _]).
      rel_pures_r; [set_solver|]. 
      iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1"). iIntros "Hl1".
      iApply (rel_load_l_mask [CaseCtx _ _]). iFrame. iIntros "!> Hl1'".
      rel_pures_l. rel_pures_r.
      iApply (rel_store_r _ _ _ _ [AppRCtx _] with "Hl1"). iIntros "Hl1".
      iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1'"). iIntros "!>Hl1'".
      rel_pures_l.
      rel_pures_r.
    
      (* Send gA first time *)
      iApply (rel_bind_mask _ [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|iApply iThy_le_refl| ].
      iApply fupd_rel.
      iMod (ghost_map_elem_persist with "Hl1'") as "#Hl1'".
      iMod (ghost_map_elem_persist with "Hl1") as "#Hl1".
      iMod (ghost_map_elem_persist with "Hla") as "#Hla".
      iDestruct "Hα" as (ns) "(%Hf & Hα)". apply map_eq_nil in Hf. simplify_eq.
      iMod (ghost_map_elem_persist with "Hα") as "#Hα".
      iModIntro.
      iApply rel_na_close. iFrame.
      iSplitL; [iRight; iFrame "#"|].
      
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iLeft. iRight.
      iExists _. do 2 (iSplit; try (iPureIntro; done)).
      iModIntro.
      iApply rel_value.
      rel_pures_l; [set_solver|]. 
      rel_pures_r; [set_solver|]. 
      
      (* Recv bob first time (either none or some) *)
      iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iRight. iRight.
      do 2 (iSplit; try (iPureIntro; done)). iModIntro.
      iSplit; last first.

    (* Recv bob = None *)
      + iApply rel_value.
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "Hnone") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".

        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]"). iApply "IH".

      + iIntros (b1 b2). iApply rel_value.
        rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ betaN ); [set_solver|].
        iFrame "Hinvb". 
        iIntros "(>[(Hβ & Hl2 & Hl2' & Hlb) | #(Hβ & Hl2 & Hl2' &Hlb)] & Hclose)". 
        * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2'".
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2". rel_pures_l.
          iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame; iDestruct "Hβ" as (ms) "(%Hf' & Hβ)"; apply map_eq_nil in Hf'; simplify_eq; done|].
          iDestruct ("HQ" with "Hnone") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
          
          (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".

        * iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
          iApply (rel_load_l with "Hl2'"). iIntros "!> _".
          iApply (rel_load_r with "Hl2"). iIntros "_". rel_pures_l.
          rel_pures_r. rel_exp_r. rel_pures_r.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
          
          (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".

    - iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
      iApply (rel_bind [_] [_;_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
      iApply (rel_load_r with "Hla"). iIntros "_".
      iApply (rel_load_l with "Hl1'"). iIntros "!> _".
      rel_pures_r. iModIntro. rel_pures_r. rel_exp_r.
      rel_pures_l; [set_solver|].
      rel_pures_r; [set_solver|].
      iApply (rel_load_r with "Hl1"). iIntros "_".
      rel_pures_r; [set_solver|]. 

      iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iRight. iRight.
      do 2 (iSplit; try (iPureIntro; done)). iModIntro.
      iSplit.
      2 : { iApply rel_value. rel_pures_l. rel_pures_r.
            iDestruct ("HQ" with "Hnone") as "HQfill".
            iDestruct ("Hk" with "HQfill") as "Hfillrel".
            iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
            iApply "IH". }
      iIntros (b1' b2').
      iApply rel_value. rel_pures_l. rel_pures_r.
      iApply (rel_na_inv _ _ betaN ); [set_solver|].
      iFrame "Hinvb". 
      iIntros "(>[(Hβ & Hl2 & Hl2s & Hlb) | (Hβ & Hl2 & Hl2s &Hlb)] & Hclose)". 
      -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2s".
         iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2".
         iApply rel_na_close. iFrame. iSplitR "Hla"; [iLeft; iFrame| ]. 
         rel_pures_l. rel_pures_r.
         iDestruct ("HQ" with "Hnone") as "HQnone".
         iDestruct ("Hk" with "HQnone") as "Hknone".
         iApply (rel_exhaustion [_;_] [_;_] with "[$]").
         iApply "IH".
      -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2s".
         iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2".
         iApply rel_na_close. iFrame. iSplitR "Hla"; [iRight; iFrame| ]. simpl.
         rel_pures_l. rel_pures_r.
         rel_exp_r. rel_pures_r.
         rewrite -expgM. rewrite -ssrnat.multE.
         rewrite -Nat.mul_comm.
         iDestruct ("HQ" with "Hsome") as "HQsome".
         iDestruct ("Hk" with "HQsome") as "Hksome".
         iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
         iApply "IH". }

     (* getKey2 *)
    1 : {
    do 2 rel_pures_r; [apply Hk2; set_solver|]. 
    do 2rel_pures_l; [split;[apply Hk1; set_solver|set_solver]|].
    iApply (rel_na_inv _ _ betaN ); [set_solver|].
    iFrame "Hinvb". 
    iIntros "(>[(Hβ & Hl1 & Hl1' & Hlb) | #(Hβ & Hl1 & Hl1' &Hlb)] & Hclose)".
    - iApply (rel_load_r_with_mask _ _ _ _ [HandleCtx _ _ _ ; AppRCtx _; CaseCtx _ _] with "Hlb").
      iIntros "Hlb". rel_pures_r.
      iAssert (β ↪ₛN (n; [fin_to_nat b]))%I with "[Hβ]" as "Hβ".
      { iExists [b]. simpl. iFrame. done. }
      iApply (rel_rand_r [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hβ").
      iIntros "Hβ ?". rel_pures_r.
      iApply (rel_store_r _ _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hlb"). iIntros "Hlb".
      rel_pures_r.
      iApply (rel_exp_r _ [HandleCtx _ _ _; AppRCtx _]).
      rel_pures_r; [set_solver|]. 
      iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1"). iIntros "Hl1".
      iApply (rel_load_l_mask [CaseCtx _ _]). iFrame. iIntros "!> Hl1'".
      rel_pures_l. rel_pures_r.
      iApply (rel_store_r _ _ _ _ [AppRCtx _] with "Hl1"). iIntros "Hl1".
      iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1'"). iIntros "!>Hl1'".
      rel_pures_l.
      rel_pures_r.
    
      (* Send gB first time *)
      iApply (rel_bind_mask _ [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|iApply iThy_le_refl| ].
      iApply fupd_rel.
      iMod (ghost_map_elem_persist with "Hl1'") as "#Hl1'".
      iMod (ghost_map_elem_persist with "Hl1") as "#Hl1".
      iMod (ghost_map_elem_persist with "Hlb") as "#Hlb".
      iDestruct "Hβ" as (ns) "(%Hf & Hβ)". apply map_eq_nil in Hf. simplify_eq.
      iMod (ghost_map_elem_persist with "Hβ") as "#Hβ".
      iModIntro.
      iApply rel_na_close. iFrame.
      iSplitL; [iRight; iFrame "#"|].
      
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iLeft. iLeft.
      iExists _. do 2 (iSplit; try (iPureIntro; done)).
      iModIntro.
      iApply rel_value.
      rel_pures_l; [set_solver|]. 
      rel_pures_r; [set_solver|]. 
      
      (* Recv alice (either none or some) *)
      iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iRight. iLeft.
      do 2 (iSplit; try (iPureIntro; done)). iModIntro.
      iSplit; last first.

    (* Recv alice = None *)
      + iApply rel_value.
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "Hnone") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".

        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]"). iApply "IH".

      + iIntros (b1 b2). iApply rel_value.
        rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ alphaN ); [set_solver|].
        iFrame "Hinva". 
        iIntros "(>[(Hα & Hl2 & Hl2' & Hla) | #(Hα & Hl2 & Hl2' &Hla)] & Hclose)". 
        * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2'".
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2". rel_pures_l.
          iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame; iDestruct "Hα" as (ms) "(%Hf' & Hα)"; apply map_eq_nil in Hf'; simplify_eq; done|].
          iDestruct ("HQ" with "Hnone") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
          
          (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".

        * iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
          iApply (rel_load_l with "Hl2'"). iIntros "!> _".
          iApply (rel_load_r with "Hl2"). iIntros "_". rel_pures_l.
          rel_pures_r. rel_exp_r. rel_pures_r.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
          
          (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".

    - iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
      iApply (rel_bind [_] [_;_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
      iApply (rel_load_r with "Hlb"). iIntros "_".
      iApply (rel_load_l with "Hl1'"). iIntros "!> _".
      rel_pures_r. iModIntro. rel_pures_r. rel_exp_r.
      rel_pures_l; [set_solver|].
      rel_pures_r; [set_solver|].
      iApply (rel_load_r with "Hl1"). iIntros "_".
      rel_pures_r; [set_solver|]. 

      iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iRight. iLeft.
      do 2 (iSplit; try (iPureIntro; done)). iModIntro.
      iSplit.
      2 : { iApply rel_value. rel_pures_l. rel_pures_r.
            iDestruct ("HQ" with "Hnone") as "HQfill".
            iDestruct ("Hk" with "HQfill") as "Hfillrel".
            iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
            iApply "IH". }
      iIntros (b1' b2').
      iApply rel_value. rel_pures_l. rel_pures_r.
      iApply (rel_na_inv _ _ alphaN ); [set_solver|].
      iFrame "Hinva". 
      iIntros "(>[(Hα & Hl2 & Hl2s & Hla) | (Hα & Hl2 & Hl2s &Hla)] & Hclose)". 
      -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2s".
         iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2".
         iApply rel_na_close. iFrame. iSplitR "Hlb"; [iLeft; iFrame| ]. 
         rel_pures_l. rel_pures_r.
         iDestruct ("HQ" with "Hnone") as "HQnone".
         iDestruct ("Hk" with "HQnone") as "Hknone".
         iApply (rel_exhaustion [_;_] [_;_] with "[$]").
         iApply "IH".
      -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2s".
         iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2".
         iApply rel_na_close. iFrame. iSplitR "Hlb"; [iRight; iFrame| ]. simpl.
         rel_pures_l. rel_pures_r.
         rel_exp_r. rel_pures_r.
         rewrite -expgM. rewrite -ssrnat.multE.
         rewrite -Nat.mul_comm.
         iDestruct ("HQ" with "Hsome") as "HQsome".
         iDestruct ("Hk" with "HQsome") as "Hksome".
         iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
         iApply "IH". }
  Qed.
       
End verification. 
