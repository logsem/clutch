From clutch.prob_eff_lang.probblaze Require Export notation valgroup.


Import fingroup.

Import fingroup.fingroup.

Import valgroup_notation.
Import valgroup_tactics.

Section implementation.
  Context {vg : val_group}.           (* A group on a subset of values. *)
  Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
  Context {vgg : @val_group_generator vg}.   (* G is generated by g. *)

  #[local] Notation n := (S n'').

  Definition sample : expr := λ: <>, rand #n.
  Definition samplelbl α : expr := λ: <>, (rand(α) #n).

  Definition Send (e : expr) := InjL e.
  Definition Recv (e : expr) := InjR e.
  Definition SendV (v : val) := InjLV v.
  Definition RecvV (v : val) := InjRV v.
  Definition bob := InjLV #()%V.
  Definition alice := InjRV #()%V.
  Definition pow : expr := rec: "pow" "b" "e" := if: "e" = #0 then #1 else "b" * ("pow" "b" ("e" - #1)).
  Definition modn : expr := rec: "mod" "a" := if: "a" < #n then "a" else "mod" ("a" - #n).

  Definition F_AUTH (channel : label) f : expr :=
    let: "m1" := ref NONEV in
    let: "m2" := ref NONEV in

    handle: f with
    | effect channel "message", rec "k" =>
        match: "message" with
        | InjL "payload" =>
            let, ("m", "dst") := "payload" in
            match: "dst" with
              InjL <> => match: !"m1" with
                         NONE => "m1" <- SOME "m";; (do: channel (Send ("m", "dst")));; "k" #()%V
                       | SOME "x" => "k" #()%V 
                       end
            | InjR <> => match: !"m2" with
                          NONE => "m2" <- SOME "m";; (do: channel (Send ("m", "dst")));; "k" #()%V
                        | SOME "x" => "k" #()%V 
                        end
            end
        | InjR "from" =>
            let: "r" := (do: channel (Recv "from")) in
             match: "r" with
               NONE => "k" NONEV
             | SOME "x" => match: "from" with
                             InjL <> => match: !"m2" with
                                          NONE => "k" NONEV
                                        | SOME "m" => "k" (SOME "m")
                                        end
                           | InjR <> => match: !"m1" with
                                          NONE => "k" NONEV
                                        | SOME "m" => "k" (SOME "m")
                                        end
                           end
             end
        end
     | return "y" => #()%V end.


  Definition F_KE (getKey channel : label) f : expr :=
    let: "key" := (sample #()%V) in

    handle: f with
    | effect getKey "p", rec "k" =>
        match: "p" with
          InjL <> =>
            (do: channel Send (#0, bob));;
            let: "r" := do: channel Recv bob in
            match: "r" with
              NONE => "k" NONEV
            | SOME "w" => "k" (SOME "key")
            end
        | InjR <> =>
            (do: channel Send (#0, alice));;
            let: "r" := do: channel Recv alice in
            match: "r" with
              NONE => "k" NONEV
            | SOME "w" => "k" (SOME "key")
            end
       end
    | return "y" => "y" end.


  Definition DH_KE (getKey channel : label) f : expr :=
    let: "α" := alloc #n in
    let: "β" := alloc #n in
    let: "l1" := ref NONEV in
    let: "l2" := ref NONEV in
    handle: f with
    | effect getKey "p", rec "k" =>
        match: "p" with
          InjL <> =>
            let: "a" :=
              (match: !"l1" with
                NONE => let: "a" := (samplelbl "α" #()%V) in "l1" <- SOME "a";; "a"
              | SOME "a" => "a"
              end) in
            let: "gA" := g^"a" in
            (do: channel (Send ("gA", bob)));;
            let: "r" := do: channel (Recv bob) in
            match: "r" with
              NONE => "k" NONEV
            | SOME "gB" =>
                let: "key" := "gB"^"a" in
                "k" (SOME "key")
            end
        | InjR <> =>
           let: "b" :=
              match: !"l2" with
                NONE => let: "b" := (samplelbl "β" #()%V) in "l2" <- SOME "b";; "b"
              | SOME "b" => "b"
              end in
            let: "gB" := g^"b" in
            (do: channel (Send ("gB", alice)));;
            let: "r" := do: channel (Recv alice) in
            match: "r" with
              NONE => "k" NONE
            | SOME "gA" =>
                let: "key" := "gA"^"b" in
                "k" (SOME "key")
            end
       end
   | return "y" => "y" end.

  Definition DH_SIM (channel : label) (f : expr) : expr :=
      handle: f with
    | effect channel "payload", rec "k" =>
        match: "payload" with
        | InjL "payload" =>
            let, ("m", "dst") := "payload" in
            match: "dst" with
              InjL <> => let: "c" := sample #()%V in
                         let: "gC" := g^"c" in
                         (do: channel (Send ("gC", bob)));;
                         "k" #()%V
            | InjR <> => let: "c" := sample #()%V in
                         let: "gC" := g^"c" in
                         (do: channel (Send ("gC", alice)));;
                         "k" #()%V
            end
        | InjR "from" =>
            let: "r" := do: channel (Recv "from") in
             match: "r" with
               NONE => "k" NONE
             | SOME "x" => "k" (SOME #0)
             end
        end
    | return "y" => "y" end.

  Definition C (getKey channel : label) (DH : expr) (f : expr) : expr :=
    let, ("ga", "gb", "gc") := DH in

    handle: f with
    | effect getKey "p", rec "k" =>
        match: "p" with
          InjL <> =>
            (do: channel (Send ("ga", bob)));;
            let: "r" := (do: channel (Recv bob)) in
            match: "r" with
              NONE => "k" NONE
            | SOME "w" => "k" (SOME "gc")
            end
        | InjR <> =>
            (do: channel (Send ("gb", alice)));;
            let: "r" := (do: channel (Recv alice)) in
            match: "r" with
              NONE => "k" NONE
            | SOME "w" => "k" (SOME "gc")
            end
        end
    | return "y" => "y" end.

  Definition DH_real : expr :=
    let: "a" := sample #()%V in
    let: "b" := sample #()%V in
    (g^"a", g^"b", g^("a"*"b")).

  Definition DH_rand : expr :=
    let: "a" := sample #()%V in
    let: "b" := sample #()%V in
    let: "c" := sample #()%V in
    ( g^"a", g^"b", g^"c").

End implementation.
