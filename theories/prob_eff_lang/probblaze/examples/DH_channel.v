From iris.proofmode Require Import base tactics classes.
From iris.base_logic.lib Require Import ghost_var na_invariants.
From clutch Require Import stdpp_ext.
From clutch.prob_eff_lang.probblaze Require Import logic primitive_laws proofmode
  spec_rules spec_ra notation
  class_instances valgroup.

Import fingroup.

Import fingroup.fingroup.

Import valgroup_notation.
Import valgroup_tactics.

Section implementation.
  Context {vg : val_group}.           (* A group on a subset of values. *)
  Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
  Context {vgg : @val_group_generator vg}.   (* G is generated by g. *)

  #[local] Notation n := (S n'').

  Definition sample : expr := λ: <>, rand #n.
  Definition samplelbl α : expr := λ: <>, (rand(α) #n).

  Definition Send (e : expr) := InjL e.
  Definition Recv (e : expr) := InjR e.
  Definition SendV (v : val) := InjLV v.
  Definition RecvV (v : val) := InjRV v.
  Definition bob := InjLV #()%V.
  Definition alice := InjRV #()%V.
  Definition pow : expr := rec: "pow" "b" "e" := if: "e" = #0 then #1 else "b" * ("pow" "b" ("e" - #1)).
  Definition modn : expr := rec: "mod" "a" := if: "a" < #n then "a" else "mod" ("a" - #n).

  Definition F_AUTH (channel : label) f : expr :=
    let: "m1" := ref NONEV in
    let: "m2" := ref NONEV in

    handle: f with
    | effect channel "message", rec "k" =>
        match: "message" with
        | InjL "payload" =>
            let, ("m", "dst") := "payload" in
            match: "dst" with
              InjL <> => match: !"m1" with
                         NONE => "m1" <- SOME "m";; (do: channel (Send ("m", "dst")));; "k" #()%V
                       | SOME "x" => "k" #()%V 
                       end
            | InjR <> => match: !"m2" with
                          NONE => "m2" <- SOME "m";; (do: channel (Send ("m", "dst")));; "k" #()%V
                        | SOME "x" => "k" #()%V 
                        end
            end
        | InjR "from" =>
            let: "r" := (do: channel (Recv "from")) in
             match: "r" with
               NONE => "k" NONEV
             | SOME "x" => match: "from" with
                             InjL <> => match: !"m2" with
                                          NONE => "k" NONEV
                                        | SOME "m" => "k" (SOME "m")
                                        end
                           | InjR <> => match: !"m1" with
                                          NONE => "k" NONEV
                                        | SOME "m" => "k" (SOME "m")
                                        end
                           end
             end
        end
     | return "y" => #()%V end.


  Definition F_KE (getKey channel : label) f : expr :=
    let: "key" := (sample #()%V) in

    handle: f with
    | effect getKey "p", rec "k" =>
        match: "p" with
          InjL <> =>
            (do: channel Send (#0, bob));;
            let: "r" := do: channel Recv bob in
            match: "r" with
              NONE => "k" NONEV
            | SOME "w" => "k" (SOME "key")
            end
        | InjR <> =>
            (do: channel Send (#0, alice));;
            let: "r" := do: channel Recv alice in
            match: "r" with
              NONE => "k" NONEV
            | SOME "w" => "k" (SOME "key")
            end
       end
    | return "y" => "y" end.


  Definition DH_KE (getKey channel : label) f : expr :=
    let: "α" := alloc #n in
    let: "β" := alloc #n in
    let: "l1" := ref NONEV in
    let: "l2" := ref NONEV in
    handle: f with
    | effect getKey "p", rec "k" =>
        match: "p" with
          InjL <> =>
            let: "a" :=
              (match: !"l1" with
                NONE => let: "a" := (samplelbl "α" #()%V) in "l1" <- SOME "a";; "a"
              | SOME "a" => "a"
              end) in
            let: "gA" := g^"a" in
            (do: channel (Send ("gA", bob)));;
            let: "r" := do: channel (Recv bob) in
            match: "r" with
              NONE => "k" NONEV
            | SOME "gB" =>
                let: "key" := "gB"^"a" in
                "k" (SOME "key")
            end
        | InjR <> =>
           let: "b" :=
              match: !"l2" with
                NONE => let: "b" := (samplelbl "β" #()%V) in "l2" <- SOME "b";; "b"
              | SOME "b" => "b"
              end in
            let: "gB" := g^"b" in
            (do: channel (Send ("gB", alice)));;
            let: "r" := do: channel (Recv alice) in
            match: "r" with
              NONE => "k" NONE
            | SOME "gA" =>
                let: "key" := "gA"^"b" in
                "k" (SOME "key")
            end
       end
   | return "y" => "y" end.

  Definition DH_SIM (channel : label) (f : expr) : expr :=
      handle: f with
    | effect channel "payload", rec "k" =>
        match: "payload" with
        | InjL "payload" =>
            let, ("m", "dst") := "payload" in
            match: "dst" with
              InjL <> => let: "c" := sample #()%V in
                         let: "gC" := g^"c" in
                         (do: channel (Send ("gC", bob)));;
                         "k" #()%V
            | InjR <> => let: "c" := sample #()%V in
                         let: "gC" := g^"c" in
                         (do: channel (Send ("gC", alice)));;
                         "k" #()%V
            end
        | InjR "from" =>
            let: "r" := do: channel (Recv "from") in
             match: "r" with
               NONE => "k" NONE
             | SOME "x" => "k" (SOME #0)
             end
        end
    | return "y" => "y" end.

  Definition C (getKey channel : label) (DH : expr) (f : expr) : expr :=
    let, ("ga", "gb", "gc") := DH in

    handle: f with
    | effect getKey "p", rec "k" =>
        match: "p" with
          InjL <> =>
            (do: channel (Send ("ga", bob)));;
            let: "r" := (do: channel (Recv bob)) in
            match: "r" with
              NONE => "k" NONE
            | SOME "w" => "k" (SOME "gc")
            end
        | InjR <> =>
            (do: channel (Send ("gb", alice)));;
            let: "r" := (do: channel (Recv alice)) in
            match: "r" with
              NONE => "k" NONE
            | SOME "w" => "k" (SOME "gc")
            end
        end
    | return "y" => "y" end.

  Definition DH_real : expr :=
    let: "a" := sample #()%V in
    let: "b" := sample #()%V in
    (g^"a", g^"b", g^("a"*"b")).

  Definition DH_rand : expr :=
    let: "a" := sample #()%V in
    let: "b" := sample #()%V in
    let: "c" := sample #()%V in
    ( g^"a", g^"b", g^"c").

End implementation.

Section handlee_verification.
  Context `{!probblazeRGS Σ, !ghost_varG Σ nat}.
  Context (channel1 channel2 getKey1 getKey2 : label).
  Context {vg : val_group}.           (* A group on a subset of values. *)
  Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
  Context {G : clutch_group (vg:=vg) (cg:=cg)}.
  Context {vgg : @val_group_generator vg}.   (* G is generated by g. *)

  #[local] Notation n := (S n'').

  Program Definition GetKey1 : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: getKey1 (InjL #()%V) ⌝%E ∗
                ⌜ e2 = do: getKey2 (InjL #()%V) ⌝%E ∗
                □ (Q NONEV NONEV ∗ ∀ key : vgG, Q (SOMEV key) (SOMEV key) )
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition GetKey2 : iThy Σ :=
     λ e1 e2, (λne Q,
                ⌜ e1 = do: getKey1 (InjR #()%V) ⌝%E ∗
                ⌜ e2 = do: getKey2 (InjR #()%V) ⌝%E ∗
                □ (Q NONEV NONEV ∗ ∀ key : vgG, Q (SOMEV key) (SOMEV key) )
             )%I.
  Next Obligation. solve_proper. Qed.
    
  Program Definition SendBob : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : vgG, 
                  ⌜ e1 = do: channel1 (SendV (m, bob)) ⌝%E ∗
                  ⌜ e2 = do: channel2 (SendV (m, bob)) ⌝%E ∗
                   □ Q (Val #()%V) (Val #()%V)
             )%I. 
  Next Obligation. solve_proper. Qed.

  Program Definition SendAlice : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : vgG, 
                  ⌜ e1 = do: channel1 (SendV (m, alice)) ⌝%E ∗
                  ⌜ e2 = do: channel2 (SendV (m, alice)) ⌝%E ∗
                  □ Q (Val #()%V) (Val #()%V)
             )%I. 
  Next Obligation. solve_proper. Qed.

  Program Definition RecvBob : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: channel1 (RecvV bob) ⌝%E ∗
                ⌜ e2 = do: channel2 (RecvV bob) ⌝%E ∗
                 ((∀ gB : nat, ∃ a m, ⌜ (gB ^ a) `mod` n = m ⌝%nat  -∗
                                       Q (SOMEV #gB) (SOMEV #gB)) ∧ Q NONEV NONEV)
                  )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition RecvBobAuth : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: channel1 (RecvV bob) ⌝%E ∗
                ⌜ e2 = do: channel2 (RecvV bob) ⌝%E ∗
                □ ((∀ b1 b2 : nat, Q (SOMEV #b1) (SOMEV #b2)) ∧ Q NONEV NONEV)
             )%I.
  Next Obligation. solve_proper. Qed.

   Program Definition RecvAliceAuth : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: channel1 (RecvV alice) ⌝%E ∗
                ⌜ e2 = do: channel2 (RecvV alice) ⌝%E ∗
                □ ((∀ b1 b2 : nat, Q (SOMEV #b1) (SOMEV #b2)) ∧ Q NONEV NONEV)
             )%I.
  Next Obligation. solve_proper. Qed.
  
  Definition T : iThy Σ := iThyTraverse [getKey1] [getKey2] (iThySum GetKey1 GetKey2).
  Definition X : iThy Σ := iThyTraverse [channel1] [channel2] (iThySum (SendBob) (RecvBob)).
  Definition Y : iThy Σ := iThyTraverse [channel1] [channel2] (iThySum (iThySum SendAlice SendBob) (iThySum RecvAliceAuth RecvBobAuth)).

  Definition tapeN : namespace := nroot .@ "tape".

  Definition KontGetKey1 k1 la lb α β :=
    KontV
      (HandleCtx getKey1
         (λ: "p" "k",
            match: "p" with
              InjL <> =>
                let: "a" := match: ! #la with InjL <> => let: "a" := #()%V;; rand(#lbl:α) #n in #la <- InjR "a";; "a" | InjR "a" => "a" end in
                let: "gA" := g ^ "a" in
                (do: channel1 InjL ("gA", bob));; 
                let: "r" := do: channel1 InjR bob in match: "r" with InjL <> => "k" (InjLV #()%V) | InjR "gB" => let: "key" := "gB" ^ "a" in "k" (InjR "key") end
                            | InjR <> =>
                                let: "b" := match: ! #lb with InjL <> => let: "b" := #()%V;; rand(#lbl:β) #n in #lb <- InjR "b";; "b" | InjR "b" => "b" end in
                                let: "gB" := g ^ "b" in
                                (do: channel1 InjL ("gB", alice));; 
                                let: "r" := do: channel1 InjR alice in match: "r" with InjL <> => "k" (InjL #()%V) | InjR "gA" => let: "key" := "gA" ^ "b" in "k" (InjR "key") end
                                              end) (λ: "y", "y") :: k1).
   
  Definition KontGetKey2 k a b :=
      KontV
                    (HandleCtx getKey2
                       (λ: "p" "k",
                          match: "p" with
                            InjL <> =>
                              (do: channel2 InjL ((g ^+ a)%g, bob));; 
                              let: "r" := do: channel2 InjR bob in
                              match: "r" with
                                InjL <> => "k" (InjL #()%V)
                              | InjR "w" => "k" (InjR (g ^+ (a * b))%g)
                              end
                          | InjR <> =>
                            (do: channel2 InjL ((g ^+ b)%g, alice));; 
                            let: "r" := do: channel2 InjR alice in
                            match: "r" with
                              InjL <> => "k" (InjL #()%V)
                            | InjR "w" => "k" (InjR (g ^+ (a * b))%g)
                            end
                          end) (λ: "y", "y") :: k).

  Definition KontChannel2 dst l1' l2' k2 a b :=
       KontV
        [HandleCtx channel2
           (λ: "message" "k",
              match: "message" with
                InjL "payload" =>
                  let: "dst" := "payload" in
                  let: "m" := Fst "dst" in
                  let: "dst" := Snd "dst" in
                  match: "dst" with
                    InjL <> =>
                      match: ! #l1' with
                        InjL <> => #l1' <- InjR "m";; (do: channel2 InjL ("m", "dst"));; "k" #()%V
                      | InjR "x" => "k" #()%V
                      end
                  | InjR <> =>
                    match: ! #l2' with
                      InjL <> => #l2' <- InjR "m";; (do: channel2 InjL ("m", "dst"));; "k" #()%V
                    | InjR "x" => "k" #()%V
                    end
                  end
              | InjR "from" =>
                let: "r" := do: channel2 InjR "from" in
                match: "r" with
                  InjL <> => "k" (InjLV #()%V)
                | InjR "x" =>
                  match: "from" with
                    InjL <> =>
                      match: ! #l2' with InjL <> => "k" (InjLV #()%V) | InjR "m" => "k" (SOME "m") end
                  | InjR <> =>
                    match: ! #l1' with InjL <> => "k" (InjLV #()%V) | InjR "m" => "k" (SOME "m") end
                  end
                end
              end) (λ: "y", #()%V);
         AppRCtx
           (λ: <>,
              let: "r" := do: channel2 InjR dst in
              match: "r" with
                InjL <> => KontGetKey2 k2 a b (InjL #()%V)
              | InjR "w" => KontGetKey2 k2 a b (InjR (g ^+ (a * b))%g)
              end)].

  Definition KontChannel2' l1' l2' k2 a b :=
       KontV
             [HandleCtx channel2
                (λ: "message" "k",
                   match: "message" with
                     InjL "payload" =>
                       let: "dst" := "payload" in
                       let: "m" := Fst "dst" in
                       let: "dst" := Snd "dst" in
                       match: "dst" with
                         InjL <> =>
                           match: ! #l1' with
                             InjL <> =>
                               #l1' <- InjR "m";; (do: channel2 InjL ("m", "dst"));; "k" #()%V
                           | InjR "x" => "k" #()%V
                           end
                       | InjR <> =>
                         match: ! #l2' with
                           InjL <> => #l2' <- InjR "m";; (do: channel2 InjL ("m", "dst"));; "k" #()%V
                         | InjR "x" => "k" #()%V
                         end
                       end
                   | InjR "from" =>
                     let: "r" := do: channel2 InjR "from" in
                     match: "r" with
                       InjL <> => "k" (InjLV #()%V)
                     | InjR "x" =>
                       match: "from" with
                         InjL <> =>
                           match: ! #l2' with InjL <> => "k" (InjLV #()%V) | InjR "m" => "k" (SOME "m") end
                       | InjR <> =>
                         match: ! #l1' with InjL <> => "k" (InjLV #()%V) | InjR "m" => "k" (SOME "m") end
                       end
                     end
                   end) (λ: "y", #()%V);
              AppRCtx
                (λ: "r",
                   match: "r" with
                     InjL <> => KontGetKey2 k2 a b (InjL #()%V)
                   | InjR "w" => KontGetKey2 k2 a b (InjR (g ^+ (a * b))%g)
                   end)].

  Definition KontChannel1 dst la lb l1 l2 k1 a α β :=
       KontV
        [HandleCtx channel1
           (λ: "message" "k",
              match: "message" with
                InjL "payload" =>
                  let: "dst" := "payload" in
                  let: "m" := Fst "dst" in
                  let: "dst" := Snd "dst" in
                  match: "dst" with
                    InjL <> =>
                      match: ! #l1 with
                        InjL <> => #l1 <- InjR "m";; (do: channel1 InjL ("m", "dst"));; "k" #()%V
                      | InjR "x" => "k" #()%V
                      end
                  | InjR <> =>
                    match: ! #l2 with
                      InjL <> => #l2 <- InjR "m";; (do: channel1 InjL ("m", "dst"));; "k" #()%V
                    | InjR "x" => "k" #()%V
                    end
                  end
              | InjR "from" =>
                let: "r" := do: channel1 InjR "from" in
                match: "r" with
                  InjL <> => "k" (InjLV #()%V)
                | InjR "x" =>
                  match: "from" with
                    InjL <> =>
                      match: ! #l2 with InjL <> => "k" (InjLV #()%V) | InjR "m" => "k" (SOME "m") end
                  | InjR <> =>
                    match: ! #l1 with InjL <> => "k" (InjLV #()%V) | InjR "m" => "k" (SOME "m") end
                  end
                end
              end) (λ: "y", #()%V);
         AppRCtx
           (λ: <>,
              let: "r" := do: channel1 InjR dst in
              match: "r" with
                InjL <> => KontGetKey1 k1 la lb α β (InjLV #()%V)
              | InjR "gB" => let: "key" := "gB" ^ #a in KontGetKey1 k1 la lb α β (InjR "key")
              end)].

  Definition KontChannel1' la lb l1 l2 k1 a α β :=
    KontV
             [HandleCtx channel1
                (λ: "message" "k",
                   match: "message" with
                     InjL "payload" =>
                       let: "dst" := "payload" in
                       let: "m" := Fst "dst" in
                       let: "dst" := Snd "dst" in
                       match: "dst" with
                         InjL <> =>
                           match: ! #l1 with
                             InjL <> =>
                               #l1 <- InjR "m";; (do: channel1 InjL ("m", "dst"));; "k" #()%V
                           | InjR "x" => "k" #()%V
                           end
                       | InjR <> =>
                         match: ! #l2 with
                           InjL <> => #l2 <- InjR "m";; (do: channel1 InjL ("m", "dst"));; "k" #()%V
                         | InjR "x" => "k" #()%V
                         end
                       end
                   | InjR "from" =>
                     let: "r" := do: channel1 InjR "from" in
                     match: "r" with
                       InjL <> => "k" (InjLV #()%V)
                     | InjR "x" =>
                       match: "from" with
                         InjL <> =>
                           match: ! #l2 with InjL <> => "k" (InjLV #()%V) | InjR "m" => "k" (SOME "m") end
                       | InjR <> =>
                         match: ! #l1 with InjL <> => "k" (InjLV #()%V) | InjR "m" => "k" (SOME "m") end
                       end
                     end
                   end) (λ: "y", #()%V);
              AppRCtx
                (λ: "r",
                   match: "r" with
                     InjL <> => KontGetKey1 k1 la lb α β (InjLV #()%V)
                   | InjR "gB" => let: "key" := "gB" ^ #a in KontGetKey1 k1 la lb α β (InjR "key")
                   end)].
  

  Lemma F_AUTH_DH_KE_C_DH_real f1 f2 :
    (∀ s n, val_subst s n f1 = f1) →
           (∀ s n, val_subst s n f2 = f2) →
           REL f1 ≤ f2 <|T|> {{ (λ v1 v2, ⌜v1 = #()%V⌝ ∧ ⌜v2 = #()%V⌝) }} -∗
           REL F_AUTH channel1 (DH_KE getKey1 channel1 f1) ≤ F_AUTH channel2 (C getKey2 channel2 DH_real f2) <|Y|> {{ (λ v1 v2, ⌜ v1 = v2 ⌝) }}.
  Proof using G.
    iIntros (Hf1closed Hf2closed) "Hff".
    iApply rel_alloc_l. iIntros (l1) "!> Hl1".
    iApply rel_alloc_l. iIntros (l2) "!> Hl2".
    iApply rel_alloctape_l. iIntros (α) "!> Hα". rel_pures_l.
    iApply rel_alloctape_l. iIntros (β) "!> Hβ". rel_pures_l.
    iApply rel_alloc_l. iIntros (la) "!> Hla".
    iApply rel_alloc_l. iIntros (lb) "!> Hlb".
    iApply rel_alloc_r. iIntros (l1') "Hl1s".
    iApply rel_alloc_r. iIntros (l2') "Hl2s".
    rel_pures_r. 
    do 4 rewrite Hf1closed.
    iDestruct "Hα" as (ns) "(%Hf & Hα)". apply map_eq_nil in Hf. simplify_eq.
    iApply rel_couple_TU; [done|]. iFrame. simpl. iIntros (a) "Hα".
    iDestruct "Hβ" as (ms) "(%Hf' & Hβ)". apply map_eq_nil in Hf'. simplify_eq.
    iApply rel_couple_TU; [done|]. iFrame "Hβ". simpl. iIntros (b) "Hβ".
    rel_pures_r. rewrite -Nat2Z.inj_mul.
    do 3 rel_exp_r.
    rel_pures_r.
    do 5 rewrite Hf2closed.
    rel_pures_l. do 2 rewrite Hf1closed.
    iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
    iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
    iIntros (e1 e2 ?)
      "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".
    
    (* getKey1 first time *)
    1 : {
    do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
    do 2rel_pures_r; [split;[apply Hk2; set_solver|set_solver]|].
    fold (KontGetKey2 k2 a b ).
    fold (KontChannel2 bob l1' l2' k2 a b).
    iApply (rel_load_l with "Hla"). iIntros "!> Hla". rel_pures_l.
    iApply rel_rand_l.
    iAssert (α ↪N (n; [fin_to_nat a]))%I with "[Hα]" as "Hα".
    { iExists [a]. simpl. iFrame. done. }
    iFrame. iIntros "!>Hα %Hlt". rel_pures_l.
    iApply (rel_store_l with "Hla"). iIntros "!> Hla".
    rel_pures_l.
    rel_exp_l.
    rel_pures_l; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
    iApply (rel_load_l with "Hl1"). iIntros "!> Hl1".
    iApply (rel_load_r with "Hl1s"). iIntros "Hl1s".
    rel_pures_l. rel_pures_r.
    iApply (rel_store_l with "Hl1"). iIntros "!> Hl1".
    iApply (rel_store_r with "Hl1s"). iIntros "Hl1s".
    rel_pures_l.
    rel_pures_r.
    
    (* Send gA first time *)
    iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
    iApply fupd_rel.
    iMod (ghost_map_elem_persist with "Hl1s") as "#Hl1s".
    iMod (ghost_map_elem_persist with "Hl1") as "#Hl1".
    iMod (ghost_map_elem_persist with "Hla") as "#Hla".
    iModIntro.
    iApply (rel_na_alloc
              (α ↪N (n; []) ∗
               ((β ↪ (n; [b]) ∗ l2 ↦ NONEV ∗ l2' ↦ₛ NONEV ∗ lb ↦ NONEV)
                ∨ (β ↪□ (n; [])
                   ∗ l2 ↦□ SOMEV (g ^+ b)%g
                   ∗ l2' ↦ₛ□ SOMEV (g ^+ b)%g
                   ∗ lb ↦□ SOMEV #b)))%I
              tapeN).
    iSplitL "Hα Hl2 Hl2s Hβ Hlb"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinv".
    iApply rel_introduction'.
    iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
    iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
    iLeft. iRight.
    iExists _. do 2 (iSplit; try (iPureIntro; done)).
    iModIntro.
    iApply rel_value.
    rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).
    rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
    
    (* Recv bob first time (either none or some) *)
    iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
    iApply rel_introduction'.
    iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
    iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
    iRight. iRight.
    do 2 (iSplit; try (iPureIntro; done)). iModIntro.
    iSplit; last first.

    (* Recv bob = None *)
    - iApply rel_value.
      rel_pures_l. rel_pures_r.
      iDestruct ("HQ" with "Hnone") as "HQfill".
      iDestruct ("Hk" with "HQfill") as "Hfillrel".
      iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".

      (* First call is done. Can call getKey1 or getKey2 again. *)
      iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
      iClear (k1 k2 S) "Hfillrel".
      iLöb as "IH".
      iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
      iIntros (e1 e2 ?)
      "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".

      (* getKey1 second time. No a is sampled *)
      + do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
        do 2 rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 bob l1' l2' k2 a b).
        iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
        iApply (rel_load_r with "Hl1s"). iIntros "_".
        iApply (rel_load_l with "Hla"). iIntros "!> _". rel_pures_l. iModIntro.
        rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
        rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
        iApply (rel_load_l with "Hl1"). iIntros "!> _".
        rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).

        iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iRight. iRight.
        do 2 (iSplit; try (iPureIntro; done)). iModIntro.
        iSplit.
        2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }
        iIntros (b1 b2).
        iApply rel_value. rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ tapeN ); [set_solver|].
        iFrame "Hinv". 
        iIntros "(>(Htape & [(Hbeta & Hl2 & Hl2s & Hlb) | #(Hbeta & Hl2 & Hl2s &Hlb)]) & Hclose)". 
        * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
          iApply rel_na_close. iFrame. iSplitR "Hla"; [iLeft; iFrame| ]. 
          rel_pures_l. rel_pures_r.
          iDestruct ("HQ" with "Hnone") as "HQnone".
          iDestruct ("Hk" with "HQnone") as "Hknone".
          iApply (rel_exhaustion [_;_] [_;_] with "[$]").
          iApply "IH".
        * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame "Hl2". iIntros "!> _".
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "_".
          iApply rel_na_close. iFrame. iSplitR "Hla"; [iRight; iFrame "#"| ]. simpl.
          rel_pures_l. rel_pures_r.
          rel_exp_l. rel_pures_l.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".

      (* getKey2 after first getKey1. *)
      + do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β). 
        do 2rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 alice l1' l2' k2 a b).
        iApply (rel_na_inv _ _ tapeN ); [set_solver|].
        iFrame "Hinv". 
        iIntros "(>(Htape & [(Hbeta & Hl2 & Hl2s & Hlb) | #(Hbeta & Hl2 & Hl2s &Hlb)]) & Hclose)".

        (* getKey2 hasn't been called before *)
        * iApply (rel_load_l_mask [HandleCtx _ _ _; AppRCtx _; CaseCtx _ _ ]).
          iFrame. iIntros "!> Hlb". simpl. 
          rel_pures_l.
          iApply (rel_rand_l _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _]).
          iAssert (β ↪N (n; [fin_to_nat b]))%I with "[Hbeta]" as "Hβ".
          { iExists [b]. simpl. iFrame. done. }
          iFrame. iIntros "!>Hβ %Hltb". rel_pures_l.
          iApply (rel_store_l _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hlb"). iIntros "!> Hlb".
          rel_pures_l. iApply (rel_exp_l _ [HandleCtx _ _ _; AppRCtx _] _ _ _ b).
          rel_pures_l; [set_solver|].
          iApply (rel_load_l_mask [CaseCtx _ _] ). iFrame. iIntros "!> Hl2". rel_pures_l.
          iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl2"). iIntros "!> Hl2". rel_pures_l.
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
          rel_pures_r.
          iApply (rel_store_r _ _ _ _  [AppRCtx _] with "Hl2s"). iIntros "Hl2s". rel_pures_r.
          
          iApply fupd_rel.
          iMod (ghost_map_elem_persist with "Hl2") as "Hl2".
          iMod (ghost_map_elem_persist with "Hl2s") as "Hl2s".
          iMod (ghost_map_elem_persist with "Hlb") as "Hlb".
          iDestruct "Hβ" as (ns) "(%Hf & Hβ)".
          apply map_eq_nil in Hf. simplify_eq.
          iMod (ghost_map_elem_persist with "Hβ") as "Hβ".
          iModIntro.
          iApply rel_na_close. iFrame.
          iSplitL; [iRight; iFrame|].
          
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iLeft. iLeft.
          iExists _. do 2 (iSplit; try (iPureIntro; done)).
          iModIntro.
          iApply rel_value.
          rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 b α β).
          rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).

          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iLeft.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }

          iIntros (b1 b2).
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_l with "Hl1"). iIntros "!> _". 
          iApply (rel_load_r with "Hl1s"). iIntros "_".
          rel_pures_l. rel_exp_l. rel_pures_l.
          rel_pures_r.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".
          
        (* getKey2 has been called before *)
        * iApply rel_na_close.
          iFrame. iSplitL; [iRight; iFrame "#"|].
          iApply (rel_load_l with "Hlb"). iIntros "!> _". rel_pures_l. rel_exp_l.
          rel_pures_l; [set_solver|].
          iApply (rel_load_l with "Hl2"). iIntros "!> _". rel_pures_l; [set_solver |].
          iApply (rel_load_r with "Hl2s"). iIntros "_". rel_pures_r; [set_solver|].
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iLeft.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }
          iIntros (b1 b2).
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_l with "Hl1"). iIntros "!> _". 
          iApply (rel_load_r with "Hl1s"). iIntros "_".
          rel_pures_l. rel_exp_l. rel_pures_l.
          rel_pures_r.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".

    (* Recv bob = Some b *)
    - iIntros (b1 b2). iApply rel_value.
      rel_pures_l. rel_pures_r.
      iApply (rel_na_inv _ _ tapeN ); [set_solver|].
      iFrame "Hinv". 
      iIntros "(>(Htape & [(Hbeta & Hl2 & Hl2s & Hlb) | #(Hbeta & Hl2 & Hl2s &Hlb)]) & Hclose)". 
      + iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s". rel_pures_l.
        iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame; iDestruct "Hbeta" as (ms) "(%Hf' & Hβ)"; apply map_eq_nil in Hf'; simplify_eq; done|].
        iDestruct ("HQ" with "Hnone") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]").
        iClear (k1 k2 S) "Hfillrel".
        iLöb as "IH".
        iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
        iIntros (e1 e2 ?)
          "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".

      (* getKey1 second time. No a is sampled *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
          do 2 rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 bob l1' l2' k2 a b).
          iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
          iApply (rel_load_r with "Hl1s"). iIntros "_".
          iApply (rel_load_l with "Hla"). iIntros "!> _". rel_pures_l. iModIntro.
          rel_pures_l. rel_exp_l.
          rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
          rel_pures_l; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
          iApply (rel_load_l with "Hl1").
          iIntros "!> _".
          rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).

          iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iRight.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                iDestruct ("HQ" with "Hnone") as "HQfill".
                iDestruct ("Hk" with "HQfill") as "Hfillrel".
                iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                iApply "IH". }
        iIntros (b1' b2').
        iApply rel_value. rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ tapeN ); [set_solver|].
        iFrame "Hinv". 
        iIntros "(>(Htape & [(Hbeta & Hl2 & Hl2s & Hlb) | (Hbeta & Hl2 & Hl2s &Hlb)]) & Hclose)". 
          -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
             iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
             iApply rel_na_close. iFrame. iSplitR "Hla"; [iLeft; iFrame| ]. 
             rel_pures_l. rel_pures_r.
             iDestruct ("HQ" with "Hnone") as "HQnone".
             iDestruct ("Hk" with "HQnone") as "Hknone".
             iApply (rel_exhaustion [_;_] [_;_] with "[$]").
             iApply "IH".
          -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
             iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
             iApply rel_na_close. iFrame. iSplitR "Hla"; [iRight; iFrame| ]. simpl.
             rel_pures_l. rel_pures_r.
             rel_exp_l. rel_pures_l.
             rewrite -expgM. rewrite -ssrnat.multE.
             rewrite -Nat.mul_comm.
             iDestruct ("HQ" with "Hsome") as "HQsome".
             iDestruct ("Hk" with "HQsome") as "Hksome".
             iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
             iApply "IH".

      (* getKey2 after first getKey1. *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β). 
        do 2rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 alice l1' l2' k2 a b).
        iApply (rel_na_inv _ _ tapeN ); [set_solver|].
        iFrame "Hinv". 
        iIntros "(>(Htape & [(Hbeta & Hl2 & Hl2s & Hlb) | #(Hbeta & Hl2 & Hl2s &Hlb)]) & Hclose)".

        (* getKey2 hasn't been called before *)
          -- iApply (rel_load_l_mask [HandleCtx _ _ _; AppRCtx _; CaseCtx _ _ ]).
             iFrame. iIntros "!> Hlb". simpl. 
             rel_pures_l.
             iApply (rel_rand_l _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _]).
             iAssert (β ↪N (n; [fin_to_nat b]))%I with "[Hbeta]" as "Hβ".
             { iExists [b]. simpl. iFrame. done. }
             iFrame. iIntros "!>Hβ %Hltb". rel_pures_l.
             iApply (rel_store_l _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hlb"). iIntros "!> Hlb".
             rel_pures_l. iApply (rel_exp_l _ [HandleCtx _ _ _; AppRCtx _] _ _ _ b).
             rel_pures_l; [set_solver|].
             iApply (rel_load_l_mask [CaseCtx _ _] ). iFrame. iIntros "!> Hl2". rel_pures_l.
             iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl2"). iIntros "!> Hl2". rel_pures_l.
             iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
             rel_pures_r.
             iApply (rel_store_r _ _ _ _  [AppRCtx _] with "Hl2s"). iIntros "Hl2s". rel_pures_r.

             iApply fupd_rel.
             iMod (ghost_map_elem_persist with "Hl2") as "Hl2".
             iMod (ghost_map_elem_persist with "Hl2s") as "Hl2s".
             iMod (ghost_map_elem_persist with "Hlb") as "Hlb".
             iDestruct "Hβ" as (ns) "(%Hf & Hβ)".
             apply map_eq_nil in Hf. simplify_eq.
             iMod (ghost_map_elem_persist with "Hβ") as "Hβ".
             iModIntro.
             iApply rel_na_close. iFrame.
             iSplitL; [iRight; iFrame|].
             
             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iLeft. iLeft.
             iExists _. do 2 (iSplit; try (iPureIntro; done)).
             iModIntro.
             iApply rel_value.
             rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 b α β).
             rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).

             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iRight. iLeft.
             do 2 (iSplit; try (iPureIntro; done)). iModIntro.
             iSplit.
             2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                   iDestruct ("HQ" with "Hnone") as "HQfill".
                   iDestruct ("Hk" with "HQfill") as "Hfillrel".
                   iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                   iApply "IH". }

             iIntros (b1' b2').
             iApply rel_value. rel_pures_l. rel_pures_r.
             iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame "Hl1". iIntros "!> _". 
             iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "_".
             rel_pures_l. rel_pures_r.
             rel_exp_l. rel_pures_l.
             rewrite -expgM. rewrite -ssrnat.multE.
             rewrite -Nat.mul_comm.
             iDestruct ("HQ" with "Hsome") as "HQsome".
             iDestruct ("Hk" with "HQsome") as "Hksome".
             iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
             iApply "IH".
        (* getKey2 has been called before *)
          -- iApply rel_na_close.
             iFrame. iSplitL; [iRight; iFrame "#"|].
             iApply (rel_load_l with "Hlb"). iIntros "!> _". rel_pures_l. rel_exp_l.
             rel_pures_l; [set_solver|].
             iApply (rel_load_l with "Hl2"). iIntros "!> _". rel_pures_l; [set_solver |].
             iApply (rel_load_r with "Hl2s"). iIntros "_". rel_pures_r; [set_solver|].
             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iRight. iLeft.
             do 2 (iSplit; try (iPureIntro; done)). iModIntro.
             iSplit.
             2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                   iDestruct ("HQ" with "Hnone") as "HQfill".
                   iDestruct ("Hk" with "HQfill") as "Hfillrel".
                   iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                   iApply "IH". }
             iIntros (b1' b2').
             iApply rel_value. rel_pures_l. rel_pures_r.
             iApply (rel_load_l with "Hl1"). iIntros "!> _". 
             iApply (rel_load_r with "Hl1s"). iIntros "_".
             rel_pures_l. rel_exp_l. rel_pures_l.
             rel_pures_r.
             rewrite -expgM. rewrite -ssrnat.multE.
             rewrite -Nat.mul_comm.
             iDestruct ("HQ" with "Hsome") as "HQsome".
             iDestruct ("Hk" with "HQsome") as "Hksome".
             iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
             iApply "IH".

      + iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
        iApply (rel_load_l with "Hl2"). iIntros "!> _".
        iApply (rel_load_r with "Hl2s"). iIntros "_". rel_pures_l.
        rel_pures_r.
        rel_exp_l. rel_pures_l.
        rewrite -expgM. rewrite -ssrnat.multE.
        rewrite -Nat.mul_comm.
        iDestruct ("HQ" with "Hsome") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]").
        iClear (k1 k2 S) "Hfillrel".
        iLöb as "IH".
        iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
        iIntros (e1 e2 ?)
          "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".

      (* getKey1 second time. No a is sampled *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
          do 2 rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 bob l1' l2' k2 a b).
          iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
          iApply (rel_load_r with "Hl1s"). iIntros "_".
          iApply (rel_load_l with "Hla"). iIntros "!> _". rel_pures_l. iModIntro.
          rel_pures_l. rel_exp_l.
          rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
          rel_pures_l; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
          iApply (rel_load_l with "Hl1").
          iIntros "!> _".
          rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).

          iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iRight.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                iDestruct ("HQ" with "Hnone") as "HQfill".
                iDestruct ("Hk" with "HQfill") as "Hfillrel".
                iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                iApply "IH". }
          iIntros (b1' b2').
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_l with "Hl2"). iIntros "!> _".
          iApply (rel_load_r with "Hl2s"). iIntros "_".
          rel_pures_l. rel_pures_r.
          rel_exp_l. rel_pures_l.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".

        (* getKey2 after first getKey1. getKey2 is called before. *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β). 
          do 2rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 alice l1' l2' k2 a b).
          iApply (rel_load_l with "Hlb"). iIntros "!> _".
          rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|].
          iApply (rel_load_l with "Hl2"). iIntros "!> _". rel_pures_l; [set_solver |].
          iApply (rel_load_r with "Hl2s"). iIntros "_". rel_pures_r; [set_solver|].
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iLeft.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                iDestruct ("HQ" with "Hnone") as "HQfill".
                iDestruct ("Hk" with "HQfill") as "Hfillrel".
                iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                iApply "IH". }
          iIntros (b1' b2').
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_l with "Hl1"). iIntros "!> _". 
          iApply (rel_load_r with "Hl1s"). iIntros "_".
          rel_pures_l. rel_pures_r.
          rel_exp_l. rel_pures_l.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH". }


     1 : {
    do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
    do 2rel_pures_r; [split;[apply Hk2; set_solver|set_solver]|].
    fold (KontGetKey2 k2 a b ).
    fold (KontChannel2 alice l1' l2' k2 a b).
    iApply (rel_load_l with "Hlb"). iIntros "!> Hlb". rel_pures_l.
    iApply rel_rand_l.
    iAssert (β ↪N (n; [fin_to_nat b]))%I with "[Hβ]" as "Hβ".
    { iExists [b]. simpl. iFrame. done. }
    iFrame. iIntros "!>Hβ %Hlt". rel_pures_l.
    iApply (rel_store_l with "Hlb"). iIntros "!> Hlb".
    rel_pures_l.
    rel_exp_l.
    rel_pures_l; [set_solver|]. fold (KontChannel1 alice la lb l1 l2 k1 b β α).
    iApply (rel_load_l with "Hl2"). iIntros "!> Hl2".
    iApply (rel_load_r with "Hl2s"). iIntros "Hl2s".
    rel_pures_l. rel_pures_r.
    iApply (rel_store_l with "Hl2"). iIntros "!> Hl2".
    iApply (rel_store_r with "Hl2s"). iIntros "Hl2s".
    rel_pures_l.
    rel_pures_r.
    
    (* Send gB first time *)
    iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
    iApply fupd_rel.
    iMod (ghost_map_elem_persist with "Hl2s") as "#Hl2s".
    iMod (ghost_map_elem_persist with "Hl2") as "#Hl2".
    iMod (ghost_map_elem_persist with "Hlb") as "#Hlb".
    iModIntro.
    iApply (rel_na_alloc
              (β ↪N (n; []) ∗
               ((α ↪ (n; [a]) ∗ l1 ↦ NONEV ∗ l1' ↦ₛ NONEV ∗ la ↦ NONEV)
                ∨ (α ↪□ (n; [])
                   ∗ l1 ↦□ SOMEV (g ^+ a)%g
                   ∗ l1' ↦ₛ□ SOMEV (g ^+ a)%g
                   ∗ la ↦□ SOMEV #a)))%I
              tapeN).
    iSplitL "Hα Hl1 Hl1s Hβ Hla"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinv".
    iApply rel_introduction'.
    iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
    iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
    iLeft. iLeft.
    iExists _. do 2 (iSplit; try (iPureIntro; done)).
    iModIntro.
    iApply rel_value.
    rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 b β α).
    rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 b a).
    
    (* Recv alice first time (either none or some) *)
    iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
    iApply rel_introduction'.
    iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
    iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
    iRight. iLeft.
    do 2 (iSplit; try (iPureIntro; done)). iModIntro.
    iSplit; last first.

    (* Recv alice = None *)
    - iApply rel_value.
      rel_pures_l. rel_pures_r.
      iDestruct ("HQ" with "Hnone") as "HQfill".
      iDestruct ("Hk" with "HQfill") as "Hfillrel".
      iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".

      (* First call is done. Can call getKey1 or getKey2 again. *)
      iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
      iClear (k1 k2 S) "Hfillrel".
      iLöb as "IH".
      iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
      iIntros (e1 e2 ?)
      "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".

      (* getKey2 after first getKey1. *)
      + do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β). 
        do 2rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 alice l1' l2' k2 a b).
        iApply (rel_na_inv _ _ tapeN ); [set_solver|].
        iFrame "Hinv". 
        iIntros "(>(Htape & [(Hα & Hl1 & Hl1s & Hla) | #(Hα & Hl1 & Hl1s &Hla)]) & Hclose)".

        (* getKey2 hasn't been called before *)
        * iApply (rel_load_l_mask [HandleCtx _ _ _; AppRCtx _; CaseCtx _ _ ]).
          iFrame. iIntros "!> Hla". simpl. 
          rel_pures_l.
          iApply (rel_rand_l _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _]).
          iAssert (α ↪N (n; [fin_to_nat a]))%I with "[Hα]" as "Hα".
          { iExists [a]. simpl. iFrame. done. }
          iFrame. iIntros "!>Hα %Hlta". rel_pures_l.
          iApply (rel_store_l _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hla"). iIntros "!> Hla".
          rel_pures_l. iApply (rel_exp_l _ [HandleCtx _ _ _; AppRCtx _] _ _ _ a).
          rel_pures_l; [set_solver|].
          iApply (rel_load_l_mask [CaseCtx _ _] ). iFrame. iIntros "!> Hl1". rel_pures_l.
          iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1"). iIntros "!> Hl1". rel_pures_l.
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
          rel_pures_r.
          iApply (rel_store_r _ _ _ _  [AppRCtx _] with "Hl1s"). iIntros "Hl1s". rel_pures_r.

          iApply fupd_rel.
          iMod (ghost_map_elem_persist with "Hl1") as "Hl1".
          iMod (ghost_map_elem_persist with "Hl1s") as "Hl1s".
          iMod (ghost_map_elem_persist with "Hla") as "Hla".
          iDestruct "Hα" as (ns) "(%Hf & Hα)".
          apply map_eq_nil in Hf. simplify_eq.
          iMod (ghost_map_elem_persist with "Hα") as "Hα".
          iModIntro.
          iApply rel_na_close. iFrame.
          iSplitL; [iRight; iFrame|].
          
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iLeft. iRight.
          iExists _. do 2 (iSplit; try (iPureIntro; done)).
          iModIntro.
          iApply rel_value.
          rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).
          rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).

          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iRight.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }

          iIntros (b1 b2).
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_l with "Hl2"). iIntros "!> _". 
          iApply (rel_load_r with "Hl2s"). iIntros "_".
          rel_pures_l. rel_pures_r.
          rel_exp_l. rel_pures_l.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".

          
        (* getKey2 has been called before *)
        * iApply rel_na_close.
          iFrame. iSplitL; [iRight; iFrame "#"|].
          iApply (rel_load_l with "Hla"). iIntros "!> _".
          rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|].
          iApply (rel_load_l with "Hl1"). iIntros "!> _". rel_pures_l; [set_solver |].
          iApply (rel_load_r with "Hl1s"). iIntros "_". rel_pures_r; [set_solver|].
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iRight.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }
          iIntros (b1 b2).
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_l with "Hl2"). iIntros "!> _". 
          iApply (rel_load_r with "Hl2s"). iIntros "_".
          rel_pures_l. rel_exp_l. rel_pures_l.
          rel_pures_r.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".
      
      (* getKey2 second time. No b is sampled *)
      + do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
        do 2 rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 bob l1' l2' k2 a b).
        iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
        iApply (rel_load_r with "Hl2s"). iIntros "_".
        iApply (rel_load_l with "Hlb"). iIntros "!> _". rel_pures_l. iModIntro.
        rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
        rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
        iApply (rel_load_l with "Hl2"). iIntros "!> _".
        rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).

        iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iRight. iLeft.
        do 2 (iSplit; try (iPureIntro; done)). iModIntro.
        iSplit.
        2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }
        iIntros (b1 b2).
        iApply rel_value. rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ tapeN ); [set_solver|].
        iFrame "Hinv". 
        iIntros "(>(Htape & [(Hα & Hl1 & Hl1s & Hla) | #(Hβ & Hl1 & Hl1s &Hla)]) & Hclose)". 
        * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl1".
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
          iApply rel_na_close. iFrame. iSplitR "Hlb"; [iLeft; iFrame| ]. 
          rel_pures_l. rel_pures_r.
          iDestruct ("HQ" with "Hnone") as "HQnone".
          iDestruct ("Hk" with "HQnone") as "Hknone".
          iApply (rel_exhaustion [_;_] [_;_] with "[$]").
          iApply "IH".
        * iApply rel_na_close. iFrame. iSplitR; [iRight; iFrame "#"|].
          iApply (rel_load_l with "Hl1"). iIntros "!> _".
          iApply (rel_load_r with "Hl1s"). iIntros "_".
          rel_pures_l. rel_exp_l. rel_pures_l.
          rel_pures_r.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".

    (* Recv bob = Some b *)
    - iIntros (b1 b2). iApply rel_value.
      rel_pures_l. rel_pures_r.
      iApply (rel_na_inv _ _ tapeN ); [set_solver|].
      iFrame "Hinv". 
      iIntros "(>(Htape & [(Hα & Hl1 & Hl1s & Hla) | #(Hα & Hl1 & Hl1s &Hla)]) & Hclose)". 
      + iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl1".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s". rel_pures_l.
        iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame; iDestruct "Hα" as (ms) "(%Hf' & Hα)"; apply map_eq_nil in Hf'; simplify_eq; done|].
        iDestruct ("HQ" with "Hnone") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]").
        iClear (k1 k2 S) "Hfillrel".
        iLöb as "IH".
        iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
        iIntros (e1 e2 ?)
          "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".

        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β). 
          do 2rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 alice l1' l2' k2 a b).
          iApply (rel_na_inv _ _ tapeN ); [set_solver|].
          iFrame "Hinv". 
          iIntros "(>(Htape & [(Hα & Hl1 & Hl1s & Hla) | #(Hα & Hl1 & Hl1s &Hla)]) & Hclose)".

          (* getKey2 hasn't been called before *)
          -- iApply (rel_load_l_mask [HandleCtx _ _ _; AppRCtx _; CaseCtx _ _ ]).
             iFrame. iIntros "!> Hla". simpl. 
             rel_pures_l.
             iApply (rel_rand_l _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _]).
             iAssert (α ↪N (n; [fin_to_nat a]))%I with "[Hα]" as "Hα".
             { iExists [a]. simpl. iFrame. done. }
             iFrame. iIntros "!>Hα %Hlta". rel_pures_l.
             iApply (rel_store_l _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hla"). iIntros "!> Hla".
             rel_pures_l. iApply (rel_exp_l _ [HandleCtx _ _ _; AppRCtx _] _ _ _ a).
             rel_pures_l; [set_solver|].
             iApply (rel_load_l_mask [CaseCtx _ _] ). iFrame. iIntros "!> Hl1". rel_pures_l.
             iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1"). iIntros "!> Hl1". rel_pures_l.
             iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
             rel_pures_r.
             iApply (rel_store_r _ _ _ _  [AppRCtx _] with "Hl1s"). iIntros "Hl1s". rel_pures_r.

             iApply fupd_rel.
             iMod (ghost_map_elem_persist with "Hl1") as "Hl1".
             iMod (ghost_map_elem_persist with "Hl1s") as "Hl1s".
             iMod (ghost_map_elem_persist with "Hla") as "Hla".
             iDestruct "Hα" as (ns) "(%Hf & Hα)".
             apply map_eq_nil in Hf. simplify_eq.
             iMod (ghost_map_elem_persist with "Hα") as "Hα".
             iModIntro.
             iApply rel_na_close. iFrame.
             iSplitL; [iRight; iFrame|].
             
             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iLeft. iRight.
             iExists _. do 2 (iSplit; try (iPureIntro; done)).
             iModIntro.
             iApply rel_value.
             rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 b α β).
             rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).

             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iRight. iRight.
             do 2 (iSplit; try (iPureIntro; done)). iModIntro.
             iSplit.
             2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                   iDestruct ("HQ" with "Hnone") as "HQfill".
                   iDestruct ("Hk" with "HQfill") as "Hfillrel".
                   iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                   iApply "IH". }

             iIntros (b1' b2').
             iApply rel_value. rel_pures_l. rel_pures_r.
             iApply (rel_load_l with "Hl2"). iIntros "!> _". 
             iApply (rel_load_r with "Hl2s"). iIntros "_".
             rel_pures_l. rel_exp_l. rel_pures_l.
             rel_pures_r.
             rewrite -expgM. rewrite -ssrnat.multE.
             rewrite -Nat.mul_comm.
             iDestruct ("HQ" with "Hsome") as "HQsome".
             iDestruct ("Hk" with "HQsome") as "Hksome".
             iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
             iApply "IH".
             
             (* getKey2 has been called before *)
          -- iApply rel_na_close. iFrame.
             iSplitR; [iRight; iFrame "#"|].
             iApply (rel_load_l with "Hla"). iIntros "!> _".
             rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|].
             iApply (rel_load_l with "Hl1"). iIntros "!> _". rel_pures_l; [set_solver |].
             iApply (rel_load_r with "Hl1s"). iIntros "_". rel_pures_r; [set_solver|].
             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iRight. iRight.
             do 2 (iSplit; try (iPureIntro; done)). iModIntro.
             iSplit.
             2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                   iDestruct ("HQ" with "Hnone") as "HQfill".
                   iDestruct ("Hk" with "HQfill") as "Hfillrel".
                   iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                   iApply "IH". }
             iIntros (b1' b2').
             iApply rel_value. rel_pures_l. rel_pures_r.
             iApply (rel_load_l with "Hl2"). iIntros "!> _". 
             iApply (rel_load_r with "Hl2s"). iIntros "_".
             rel_pures_l. rel_exp_l. rel_pures_l.
             rel_pures_r.
             rewrite -expgM. rewrite -ssrnat.multE.
             rewrite -Nat.mul_comm.
             iDestruct ("HQ" with "Hsome") as "HQsome".
             iDestruct ("Hk" with "HQsome") as "Hksome".
             iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
             iApply "IH".

             
      (* getKey1 second time. No a is sampled *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
          do 2 rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 bob l1' l2' k2 a b).
          iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
          iApply (rel_load_r with "Hl2s"). iIntros "_".
          iApply (rel_load_l with "Hlb"). iIntros "!> _". rel_pures_l. iModIntro.
          rel_pures_l. rel_exp_l.
          rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
          rel_pures_l; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
          iApply (rel_load_l with "Hl2").
          iIntros "!> _".
          rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).

          iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iLeft.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                iDestruct ("HQ" with "Hnone") as "HQfill".
                iDestruct ("Hk" with "HQfill") as "Hfillrel".
                iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                iApply "IH". }
          iIntros (b1' b2').
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_na_inv _ _ tapeN ); [set_solver|].
          iFrame "Hinv". 
          iIntros "(>(Htape & [(Hα & Hl1 & Hl1s & Hla) | #(Hα & Hl1 & Hl1s &Hla)]) & Hclose)". 
          -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl1".
             iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
             iApply rel_na_close. iFrame. iSplitR "Hlb"; [iLeft; iFrame| ]. 
             rel_pures_l. rel_pures_r.
             iDestruct ("HQ" with "Hnone") as "HQnone".
             iDestruct ("Hk" with "HQnone") as "Hknone".
             iApply (rel_exhaustion [_;_] [_;_] with "[$]").
             iApply "IH".
          -- iApply rel_na_close. iFrame. iSplitR "Hlb"; [iRight; iFrame "#"|].
             iApply (rel_load_l with "Hl1"). iIntros "!> _".
             iApply (rel_load_r with "Hl1s"). iIntros "_".
             rel_pures_l. rel_exp_l. rel_pures_l.
             rel_pures_r.
             rewrite -expgM. rewrite -ssrnat.multE.
             rewrite -Nat.mul_comm.
             iDestruct ("HQ" with "Hsome") as "HQsome".
             iDestruct ("Hk" with "HQsome") as "Hksome".
             iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
             iApply "IH".

      + iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
        iApply (rel_load_l with "Hl1"). iIntros "!> _".
        iApply (rel_load_r with "Hl1s"). iIntros "_". 
        rel_pures_r.
        rel_pures_l. rel_exp_l. rel_pures_l.
        rewrite -expgM. rewrite -ssrnat.multE.
        rewrite -Nat.mul_comm.
        iDestruct ("HQ" with "Hsome") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]").
        iClear (k1 k2 S) "Hfillrel".
        iLöb as "IH".
        iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
        iIntros (e1 e2 ?)
          "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".

         (* getKey2 after first getKey1. *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β). 
        do 2rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 alice l1' l2' k2 a b).
        iApply (rel_load_l with "Hla"). iIntros "!> _".
        rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|].
        iApply (rel_load_l with "Hl1"). iIntros "!> _". rel_pures_l; [set_solver |].
        iApply (rel_load_r with "Hl1s"). iIntros "_". rel_pures_r; [set_solver|].
        iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iRight. iRight.
        do 2 (iSplit; try (iPureIntro; done)). iModIntro.
        iSplit.
        2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }
        iIntros (b1' b2').
        iApply rel_value. rel_pures_l. rel_pures_r.
        iApply (rel_load_l with "Hl2"). iIntros "!> _". 
        iApply (rel_load_r with "Hl2s"). iIntros "_".
        rel_pures_l. rel_exp_l. rel_pures_l.
        rel_pures_r.
        rewrite -expgM. rewrite -ssrnat.multE.
        rewrite -Nat.mul_comm.
        iDestruct ("HQ" with "Hsome") as "HQsome".
        iDestruct ("Hk" with "HQsome") as "Hksome".
        iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
        iApply "IH".
        

      (* getKey1 second time. No a is sampled *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
          do 2 rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 bob l1' l2' k2 a b).
          iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
          iApply (rel_load_r with "Hl2s"). iIntros "_".
          iApply (rel_load_l with "Hlb"). iIntros "!> _". rel_pures_l. iModIntro.
          rel_pures_l. rel_exp_l.
          rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
          rel_pures_l; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
          iApply (rel_load_l with "Hl2").
          iIntros "!> _".
          rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).

          iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iLeft.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                iDestruct ("HQ" with "Hnone") as "HQfill".
                iDestruct ("Hk" with "HQfill") as "Hfillrel".
                iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                iApply "IH". }
          iIntros (b1' b2').
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_l with "Hl1"). iIntros "!> _".
          iApply (rel_load_r with "Hl1s"). iIntros "_".
          rel_pures_l. rel_exp_l. rel_pures_l.
          rel_pures_r.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH". }
  Qed.


   Lemma F_AUTH_C_DH_real_DH_KE f1 f2 :
    (∀ s n, val_subst s n f1 = f1) →
           (∀ s n, val_subst s n f2 = f2) →
           REL f1 ≤ f2 <|T|> {{ (λ v1 v2, ⌜v1 = #()%V⌝ ∧ ⌜v2 = #()%V⌝) }} -∗
           REL F_AUTH channel1 (C getKey1 channel1 DH_real f1) ≤ F_AUTH channel2 (DH_KE getKey2 channel2 f2)  <|Y|> {{ (λ v1 v2, ⌜ v1 = v2 ⌝) }}.
  Proof using G.
    iIntros (Hf1closed Hf2closed) "Hff".
    iApply rel_alloc_r. iIntros (l1) "Hl1".
    iApply rel_alloc_r. iIntros (l2) "Hl2".
    iApply rel_alloctape_r. iIntros (α) "Hα". rel_pures_r.
    iApply rel_alloctape_r. iIntros (β) "Hβ". rel_pures_r.
    iApply rel_alloc_r. iIntros (la) "Hla".
    iApply rel_alloc_r. iIntros (lb) "Hlb".
    iApply rel_alloc_l. iIntros (l1') "!> Hl1'".
    iApply rel_alloc_l. iIntros (l2') "!> Hl2'".
    rel_pures_l. 
    do 4 rewrite Hf2closed.
    iApply rel_couple_UT. iFrame "Hα". simpl. iIntros (a) "!> %Hlt Hα".
    (* iDestruct "Hβ" as (ms) "(%Hf' & Hβ)". apply map_eq_nil in Hf'. simplify_eq. *)
    iApply rel_couple_UT. iFrame "Hβ". simpl. iIntros (b) "!> %_ Hβ".

    rel_pures_l. rewrite -Nat2Z.inj_mul.
    do 3 rel_exp_l.
    rel_pures_l.
    do 5 rewrite Hf1closed.
    rel_pures_r. do 2 rewrite Hf2closed.
    iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
    iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
    iIntros (e1 e2 ?)
      "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".
    
    (* getKey1 first time *)
    1 : {
    do 2 rel_pures_r; [apply Hk2; set_solver|]. fold (KontGetKey1 k1 la lb α β).
    do 2rel_pures_l; [split;[apply Hk1; set_solver|set_solver]|].
    fold (KontGetKey2 k2 a b ).
    fold (KontChannel2 bob l1' l2' k2 a b).
    iApply (rel_load_r with "Hla"). iIntros "Hla". rel_pures_r.
    iAssert (α ↪ₛN (n; [fin_to_nat a]))%I with "[Hα]" as "Hα".
    { iExists [a]. simpl. iFrame. done. }
    iApply (rel_rand_r with "Hα").
    iIntros "Hα ?". rel_pures_r.
    iApply (rel_store_r with "Hla"). iIntros "Hla".
    rel_pures_r.
    rel_exp_r.
    rel_pures_r; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
    iApply (rel_load_r with "Hl1"). iIntros "Hl1".
    iApply (rel_load_l with "Hl1'"). iIntros "!> Hl1'".
    rel_pures_l. rel_pures_r.
    iApply (rel_store_r with "Hl1"). iIntros "Hl1".
    iApply (rel_store_l with "Hl1'"). iIntros "!>Hl1'".
    rel_pures_l.
    rel_pures_r.
    
    (* Send gA first time *)
    iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
    iApply fupd_rel.
    iMod (ghost_map_elem_persist with "Hl1'") as "#Hl1'".
    iMod (ghost_map_elem_persist with "Hl1") as "#Hl1".
    iMod (ghost_map_elem_persist with "Hla") as "#Hla".
    iModIntro.
    iApply (rel_na_alloc
              (α ↪ₛN (n; []) ∗
               ((β ↪ₛ (n; [b]) ∗ l2 ↦ₛ NONEV ∗ l2' ↦ NONEV ∗ lb ↦ₛ NONEV)
                ∨ (β ↪ₛ□ (n; [])
                   ∗ l2 ↦ₛ□ SOMEV (g ^+ b)%g
                   ∗ l2' ↦□ SOMEV (g ^+ b)%g
                   ∗ lb ↦ₛ□ SOMEV #b)))%I
              tapeN).
    iSplitL "Hα Hl2 Hl2' Hβ Hlb"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinv".
    iApply rel_introduction'.
    iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
    iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
    iLeft. iRight.
    iExists _. do 2 (iSplit; try (iPureIntro; done)).
    iModIntro.
    iApply rel_value.
    rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).
    rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
    
    (* Recv bob first time (either none or some) *)
    iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
    iApply rel_introduction'.
    iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
    iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
    iRight. iRight.
    do 2 (iSplit; try (iPureIntro; done)). iModIntro.
    iSplit; last first.

    (* Recv bob = None *)
    - iApply rel_value.
      rel_pures_l. rel_pures_r.
      iDestruct ("HQ" with "Hnone") as "HQfill".
      iDestruct ("Hk" with "HQfill") as "Hfillrel".
      iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".

      (* First call is done. Can call getKey1 or getKey2 again. *)
      iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
      iClear (k1 k2 S) "Hfillrel".
      iLöb as "IH".
      iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
      iIntros (e1 e2 ?)
      "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".

      (* getKey1 second time. No a is sampled *)
      + do 2 rel_pures_r; [apply Hk2; set_solver|]. fold (KontGetKey1 k1 la lb α β).
        do 2 rel_pures_l; [split; [apply Hk1; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 bob l1' l2' k2 a b).
        iApply (rel_bind [_] [_;_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
        iApply (rel_load_l with "Hl1'"). iIntros "!> _".
        iApply (rel_load_r with "Hla"). iIntros "_". rel_pures_r. iModIntro.
        rel_pures_r. rel_exp_r. rel_pures_r; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
        rel_pures_l; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
        iApply (rel_load_r with "Hl1"). iIntros "_".
        rel_pures_r; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).

        iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iRight. iRight.
        do 2 (iSplit; try (iPureIntro; done)). iModIntro.
        iSplit.
        2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }
        iIntros (b1 b2).
        iApply rel_value. rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ tapeN ); [set_solver|].
        iFrame "Hinv". 
        iIntros "(>(Htape & [(Hbeta & Hl2 & Hl2' & Hlb) | #(Hbeta & Hl2 & Hl2' &Hlb)]) & Hclose)". 
        * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2'".
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2".
          iApply rel_na_close. iFrame. iSplitR "Hla"; [iLeft; iFrame| ]. 
          rel_pures_l. rel_pures_r.
          iDestruct ("HQ" with "Hnone") as "HQnone".
          iDestruct ("Hk" with "HQnone") as "Hknone".
          iApply (rel_exhaustion [_;_] [_;_] with "[$]").
          iApply "IH".
        * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame "Hl2'". iIntros "!> _".
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "_".
          iApply rel_na_close. iFrame. iSplitR "Hla"; [iRight; iFrame "#"| ]. simpl.
          rel_pures_l. rel_pures_r.
          rel_exp_r. rel_pures_r.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".

      (* getKey2 after first getKey1. *)
      + do 2 rel_pures_r; [apply Hk2; set_solver|]. fold (KontGetKey1 k1 la lb α β). 
        do 2rel_pures_l; [split; [apply Hk1; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 alice l1' l2' k2 a b).
        iApply (rel_na_inv _ _ tapeN ); [set_solver|].
        iFrame "Hinv". 
        iIntros "(>(Htape & [(Hbeta & Hl2 & Hl2s & Hlb) | #(Hbeta & Hl2 & Hl2s &Hlb)]) & Hclose)".

        (* getKey2 hasn't been called before *)
        * iApply (rel_load_r_with_mask _ _ _ _ [HandleCtx _ _ _; AppRCtx _; CaseCtx _ _ ] with "Hlb").
          iIntros "Hlb". simpl. 
          rel_pures_r.
          iAssert (β ↪ₛN (n; [fin_to_nat b]))%I with "[Hbeta]" as "Hβ".
          { iExists [b]. simpl. iFrame. done. }
          iApply (rel_rand_r [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hβ").
          iIntros "Hβ ?". rel_pures_r.
          iApply (rel_store_r _ _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hlb"). iIntros "Hlb".
          rel_pures_r. iApply (rel_exp_r _ [HandleCtx _ _ _; AppRCtx _] _ _ _ b).
          rel_pures_r; [set_solver|].
          iApply (rel_load_l_mask [CaseCtx _ _] ). iFrame. iIntros "!> Hl2'". rel_pures_l.
          iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl2'"). iIntros "!> Hl2'". rel_pures_l.
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2".
          rel_pures_r.
          iApply (rel_store_r _ _ _ _  [AppRCtx _] with "Hl2"). iIntros "Hl2". rel_pures_r.
          
          iApply fupd_rel.
          iMod (ghost_map_elem_persist with "Hl2") as "Hl2".
          iMod (ghost_map_elem_persist with "Hl2'") as "Hl2'".
          iMod (ghost_map_elem_persist with "Hlb") as "Hlb".
          iDestruct "Hβ" as (ns) "(%Hf & Hβ)".
          apply map_eq_nil in Hf. simplify_eq.
          iMod (ghost_map_elem_persist with "Hβ") as "Hβ".
          iModIntro.
          iApply rel_na_close. iFrame.
          iSplitL; [iRight; iFrame|].
          
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iLeft. iLeft.
          iExists _. do 2 (iSplit; try (iPureIntro; done)).
          iModIntro.
          iApply rel_value.
          rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 b α β).
          rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).

          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iLeft.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }

          iIntros (b1 b2).
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_r with "Hl1"). iIntros "_". 
          iApply (rel_load_l with "Hl1'"). iIntros "!>_".
          rel_pures_r. rel_exp_r. rel_pures_r.
          rel_pures_l.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".
          
        (* getKey2 has been called before *)
        * iApply rel_na_close.
          iFrame. iSplitL; [iRight; iFrame "#"|].
          iApply (rel_load_r with "Hlb"). iIntros "_". rel_pures_r. rel_exp_r.
          rel_pures_r; [set_solver|].
          iApply (rel_load_r with "Hl2"). iIntros "_". rel_pures_r; [set_solver |].
          iApply (rel_load_l with "Hl2s"). iIntros "!>_". rel_pures_l; [set_solver|].
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iLeft.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }
          iIntros (b1 b2).
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_l with "Hl1'"). iIntros "!> _". 
          iApply (rel_load_r with "Hl1"). iIntros "_".
          rel_pures_r. rel_exp_r. rel_pures_r.
          rel_pures_l.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".
    (* TODO: Correct the rest of proof *)
    (* Recv bob = Some b *)
    - iIntros (b1 b2). iApply rel_value.
      rel_pures_l. rel_pures_r.
      iApply (rel_na_inv _ _ tapeN ); [set_solver|].
      iFrame "Hinv". 
      iIntros "(>(Htape & [(Hbeta & Hl2 & Hl2s & Hlb) | #(Hbeta & Hl2 & Hl2s &Hlb)]) & Hclose)". 
      + iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s". rel_pures_l.
        iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame; iDestruct "Hbeta" as (ms) "(%Hf' & Hβ)"; apply map_eq_nil in Hf'; simplify_eq; done|].
        iDestruct ("HQ" with "Hnone") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]").
        iClear (k1 k2 S) "Hfillrel".
        iLöb as "IH".
        iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
        iIntros (e1 e2 ?)
          "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".

      (* getKey1 second time. No a is sampled *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
          do 2 rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 bob l1' l2' k2 a b).
          iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
          iApply (rel_load_r with "Hl1s"). iIntros "_".
          iApply (rel_load_l with "Hla"). iIntros "!> _". rel_pures_l. iModIntro.
          rel_pures_l. rel_exp_l.
          rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
          rel_pures_l; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
          iApply (rel_load_l with "Hl1").
          iIntros "!> _".
          rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).

          iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iRight.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                iDestruct ("HQ" with "Hnone") as "HQfill".
                iDestruct ("Hk" with "HQfill") as "Hfillrel".
                iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                iApply "IH". }
        iIntros (b1' b2').
        iApply rel_value. rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ tapeN ); [set_solver|].
        iFrame "Hinv". 
        iIntros "(>(Htape & [(Hbeta & Hl2 & Hl2s & Hlb) | (Hbeta & Hl2 & Hl2s &Hlb)]) & Hclose)". 
          -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
             iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
             iApply rel_na_close. iFrame. iSplitR "Hla"; [iLeft; iFrame| ]. 
             rel_pures_l. rel_pures_r.
             iDestruct ("HQ" with "Hnone") as "HQnone".
             iDestruct ("Hk" with "HQnone") as "Hknone".
             iApply (rel_exhaustion [_;_] [_;_] with "[$]").
             iApply "IH".
          -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
             iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
             iApply rel_na_close. iFrame. iSplitR "Hla"; [iRight; iFrame| ]. simpl.
             rel_pures_l. rel_pures_r.
             rel_exp_l. rel_pures_l.
             rewrite -expgM. rewrite -ssrnat.multE.
             rewrite -Nat.mul_comm.
             iDestruct ("HQ" with "Hsome") as "HQsome".
             iDestruct ("Hk" with "HQsome") as "Hksome".
             iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
             iApply "IH".

      (* getKey2 after first getKey1. *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β). 
        do 2rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 alice l1' l2' k2 a b).
        iApply (rel_na_inv _ _ tapeN ); [set_solver|].
        iFrame "Hinv". 
        iIntros "(>(Htape & [(Hbeta & Hl2 & Hl2s & Hlb) | #(Hbeta & Hl2 & Hl2s &Hlb)]) & Hclose)".

        (* getKey2 hasn't been called before *)
          -- iApply (rel_load_l_mask [HandleCtx _ _ _; AppRCtx _; CaseCtx _ _ ]).
             iFrame. iIntros "!> Hlb". simpl. 
             rel_pures_l.
             iApply (rel_rand_l _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _]).
             iAssert (β ↪N (n; [fin_to_nat b]))%I with "[Hbeta]" as "Hβ".
             { iExists [b]. simpl. iFrame. done. }
             iFrame. iIntros "!>Hβ %Hltb". rel_pures_l.
             iApply (rel_store_l _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hlb"). iIntros "!> Hlb".
             rel_pures_l. iApply (rel_exp_l _ [HandleCtx _ _ _; AppRCtx _] _ _ _ b).
             rel_pures_l; [set_solver|].
             iApply (rel_load_l_mask [CaseCtx _ _] ). iFrame. iIntros "!> Hl2". rel_pures_l.
             iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl2"). iIntros "!> Hl2". rel_pures_l.
             iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
             rel_pures_r.
             iApply (rel_store_r _ _ _ _  [AppRCtx _] with "Hl2s"). iIntros "Hl2s". rel_pures_r.

             iApply fupd_rel.
             iMod (ghost_map_elem_persist with "Hl2") as "Hl2".
             iMod (ghost_map_elem_persist with "Hl2s") as "Hl2s".
             iMod (ghost_map_elem_persist with "Hlb") as "Hlb".
             iDestruct "Hβ" as (ns) "(%Hf & Hβ)".
             apply map_eq_nil in Hf. simplify_eq.
             iMod (ghost_map_elem_persist with "Hβ") as "Hβ".
             iModIntro.
             iApply rel_na_close. iFrame.
             iSplitL; [iRight; iFrame|].
             
             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iLeft. iLeft.
             iExists _. do 2 (iSplit; try (iPureIntro; done)).
             iModIntro.
             iApply rel_value.
             rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 b α β).
             rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).

             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iRight. iLeft.
             do 2 (iSplit; try (iPureIntro; done)). iModIntro.
             iSplit.
             2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                   iDestruct ("HQ" with "Hnone") as "HQfill".
                   iDestruct ("Hk" with "HQfill") as "Hfillrel".
                   iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                   iApply "IH". }

             iIntros (b1' b2').
             iApply rel_value. rel_pures_l. rel_pures_r.
             iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame "Hl1". iIntros "!> _". 
             iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "_".
             rel_pures_l. rel_pures_r.
             rel_exp_l. rel_pures_l.
             rewrite -expgM. rewrite -ssrnat.multE.
             rewrite -Nat.mul_comm.
             iDestruct ("HQ" with "Hsome") as "HQsome".
             iDestruct ("Hk" with "HQsome") as "Hksome".
             iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
             iApply "IH".
        (* getKey2 has been called before *)
          -- iApply rel_na_close.
             iFrame. iSplitL; [iRight; iFrame "#"|].
             iApply (rel_load_l with "Hlb"). iIntros "!> _". rel_pures_l. rel_exp_l.
             rel_pures_l; [set_solver|].
             iApply (rel_load_l with "Hl2"). iIntros "!> _". rel_pures_l; [set_solver |].
             iApply (rel_load_r with "Hl2s"). iIntros "_". rel_pures_r; [set_solver|].
             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iRight. iLeft.
             do 2 (iSplit; try (iPureIntro; done)). iModIntro.
             iSplit.
             2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                   iDestruct ("HQ" with "Hnone") as "HQfill".
                   iDestruct ("Hk" with "HQfill") as "Hfillrel".
                   iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                   iApply "IH". }
             iIntros (b1' b2').
             iApply rel_value. rel_pures_l. rel_pures_r.
             iApply (rel_load_l with "Hl1"). iIntros "!> _". 
             iApply (rel_load_r with "Hl1s"). iIntros "_".
             rel_pures_l. rel_exp_l. rel_pures_l.
             rel_pures_r.
             rewrite -expgM. rewrite -ssrnat.multE.
             rewrite -Nat.mul_comm.
             iDestruct ("HQ" with "Hsome") as "HQsome".
             iDestruct ("Hk" with "HQsome") as "Hksome".
             iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
             iApply "IH".

      + iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
        iApply (rel_load_l with "Hl2"). iIntros "!> _".
        iApply (rel_load_r with "Hl2s"). iIntros "_". rel_pures_l.
        rel_pures_r.
        rel_exp_l. rel_pures_l.
        rewrite -expgM. rewrite -ssrnat.multE.
        rewrite -Nat.mul_comm.
        iDestruct ("HQ" with "Hsome") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]").
        iClear (k1 k2 S) "Hfillrel".
        iLöb as "IH".
        iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
        iIntros (e1 e2 ?)
          "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".

      (* getKey1 second time. No a is sampled *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
          do 2 rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 bob l1' l2' k2 a b).
          iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
          iApply (rel_load_r with "Hl1s"). iIntros "_".
          iApply (rel_load_l with "Hla"). iIntros "!> _". rel_pures_l. iModIntro.
          rel_pures_l. rel_exp_l.
          rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
          rel_pures_l; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
          iApply (rel_load_l with "Hl1").
          iIntros "!> _".
          rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).

          iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iRight.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                iDestruct ("HQ" with "Hnone") as "HQfill".
                iDestruct ("Hk" with "HQfill") as "Hfillrel".
                iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                iApply "IH". }
          iIntros (b1' b2').
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_l with "Hl2"). iIntros "!> _".
          iApply (rel_load_r with "Hl2s"). iIntros "_".
          rel_pures_l. rel_pures_r.
          rel_exp_l. rel_pures_l.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".

        (* getKey2 after first getKey1. getKey2 is called before. *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β). 
          do 2rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 alice l1' l2' k2 a b).
          iApply (rel_load_l with "Hlb"). iIntros "!> _".
          rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|].
          iApply (rel_load_l with "Hl2"). iIntros "!> _". rel_pures_l; [set_solver |].
          iApply (rel_load_r with "Hl2s"). iIntros "_". rel_pures_r; [set_solver|].
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iLeft.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                iDestruct ("HQ" with "Hnone") as "HQfill".
                iDestruct ("Hk" with "HQfill") as "Hfillrel".
                iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                iApply "IH". }
          iIntros (b1' b2').
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_l with "Hl1"). iIntros "!> _". 
          iApply (rel_load_r with "Hl1s"). iIntros "_".
          rel_pures_l. rel_pures_r.
          rel_exp_l. rel_pures_l.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH". }


     1 : {
    do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
    do 2rel_pures_r; [split;[apply Hk2; set_solver|set_solver]|].
    fold (KontGetKey2 k2 a b ).
    fold (KontChannel2 alice l1' l2' k2 a b).
    iApply (rel_load_l with "Hlb"). iIntros "!> Hlb". rel_pures_l.
    iApply rel_rand_l.
    iAssert (β ↪N (n; [fin_to_nat b]))%I with "[Hβ]" as "Hβ".
    { iExists [b]. simpl. iFrame. done. }
    iFrame. iIntros "!>Hβ %Hlt". rel_pures_l.
    iApply (rel_store_l with "Hlb"). iIntros "!> Hlb".
    rel_pures_l.
    rel_exp_l.
    rel_pures_l; [set_solver|]. fold (KontChannel1 alice la lb l1 l2 k1 b β α).
    iApply (rel_load_l with "Hl2"). iIntros "!> Hl2".
    iApply (rel_load_r with "Hl2s"). iIntros "Hl2s".
    rel_pures_l. rel_pures_r.
    iApply (rel_store_l with "Hl2"). iIntros "!> Hl2".
    iApply (rel_store_r with "Hl2s"). iIntros "Hl2s".
    rel_pures_l.
    rel_pures_r.
    
    (* Send gB first time *)
    iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
    iApply fupd_rel.
    iMod (ghost_map_elem_persist with "Hl2s") as "#Hl2s".
    iMod (ghost_map_elem_persist with "Hl2") as "#Hl2".
    iMod (ghost_map_elem_persist with "Hlb") as "#Hlb".
    iModIntro.
    iApply (rel_na_alloc
              (β ↪N (n; []) ∗
               ((α ↪ (n; [a]) ∗ l1 ↦ NONEV ∗ l1' ↦ₛ NONEV ∗ la ↦ NONEV)
                ∨ (α ↪□ (n; [])
                   ∗ l1 ↦□ SOMEV (g ^+ a)%g
                   ∗ l1' ↦ₛ□ SOMEV (g ^+ a)%g
                   ∗ la ↦□ SOMEV #a)))%I
              tapeN).
    iSplitL "Hα Hl1 Hl1s Hβ Hla"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinv".
    iApply rel_introduction'.
    iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
    iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
    iLeft. iLeft.
    iExists _. do 2 (iSplit; try (iPureIntro; done)).
    iModIntro.
    iApply rel_value.
    rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 b β α).
    rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 b a).
    
    (* Recv alice first time (either none or some) *)
    iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
    iApply rel_introduction'.
    iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
    iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
    iRight. iLeft.
    do 2 (iSplit; try (iPureIntro; done)). iModIntro.
    iSplit; last first.

    (* Recv alice = None *)
    - iApply rel_value.
      rel_pures_l. rel_pures_r.
      iDestruct ("HQ" with "Hnone") as "HQfill".
      iDestruct ("Hk" with "HQfill") as "Hfillrel".
      iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".

      (* First call is done. Can call getKey1 or getKey2 again. *)
      iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
      iClear (k1 k2 S) "Hfillrel".
      iLöb as "IH".
      iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
      iIntros (e1 e2 ?)
      "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".

      (* getKey2 after first getKey1. *)
      + do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β). 
        do 2rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 alice l1' l2' k2 a b).
        iApply (rel_na_inv _ _ tapeN ); [set_solver|].
        iFrame "Hinv". 
        iIntros "(>(Htape & [(Hα & Hl1 & Hl1s & Hla) | #(Hα & Hl1 & Hl1s &Hla)]) & Hclose)".

        (* getKey2 hasn't been called before *)
        * iApply (rel_load_l_mask [HandleCtx _ _ _; AppRCtx _; CaseCtx _ _ ]).
          iFrame. iIntros "!> Hla". simpl. 
          rel_pures_l.
          iApply (rel_rand_l _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _]).
          iAssert (α ↪N (n; [fin_to_nat a]))%I with "[Hα]" as "Hα".
          { iExists [a]. simpl. iFrame. done. }
          iFrame. iIntros "!>Hα %Hlta". rel_pures_l.
          iApply (rel_store_l _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hla"). iIntros "!> Hla".
          rel_pures_l. iApply (rel_exp_l _ [HandleCtx _ _ _; AppRCtx _] _ _ _ a).
          rel_pures_l; [set_solver|].
          iApply (rel_load_l_mask [CaseCtx _ _] ). iFrame. iIntros "!> Hl1". rel_pures_l.
          iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1"). iIntros "!> Hl1". rel_pures_l.
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
          rel_pures_r.
          iApply (rel_store_r _ _ _ _  [AppRCtx _] with "Hl1s"). iIntros "Hl1s". rel_pures_r.

          iApply fupd_rel.
          iMod (ghost_map_elem_persist with "Hl1") as "Hl1".
          iMod (ghost_map_elem_persist with "Hl1s") as "Hl1s".
          iMod (ghost_map_elem_persist with "Hla") as "Hla".
          iDestruct "Hα" as (ns) "(%Hf & Hα)".
          apply map_eq_nil in Hf. simplify_eq.
          iMod (ghost_map_elem_persist with "Hα") as "Hα".
          iModIntro.
          iApply rel_na_close. iFrame.
          iSplitL; [iRight; iFrame|].
          
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iLeft. iRight.
          iExists _. do 2 (iSplit; try (iPureIntro; done)).
          iModIntro.
          iApply rel_value.
          rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).
          rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).

          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iRight.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }

          iIntros (b1 b2).
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_l with "Hl2"). iIntros "!> _". 
          iApply (rel_load_r with "Hl2s"). iIntros "_".
          rel_pures_l. rel_pures_r.
          rel_exp_l. rel_pures_l.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".

          
        (* getKey2 has been called before *)
        * iApply rel_na_close.
          iFrame. iSplitL; [iRight; iFrame "#"|].
          iApply (rel_load_l with "Hla"). iIntros "!> _".
          rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|].
          iApply (rel_load_l with "Hl1"). iIntros "!> _". rel_pures_l; [set_solver |].
          iApply (rel_load_r with "Hl1s"). iIntros "_". rel_pures_r; [set_solver|].
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iRight.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }
          iIntros (b1 b2).
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_l with "Hl2"). iIntros "!> _". 
          iApply (rel_load_r with "Hl2s"). iIntros "_".
          rel_pures_l. rel_exp_l. rel_pures_l.
          rel_pures_r.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".
      
      (* getKey2 second time. No b is sampled *)
      + do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
        do 2 rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 bob l1' l2' k2 a b).
        iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
        iApply (rel_load_r with "Hl2s"). iIntros "_".
        iApply (rel_load_l with "Hlb"). iIntros "!> _". rel_pures_l. iModIntro.
        rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
        rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
        iApply (rel_load_l with "Hl2"). iIntros "!> _".
        rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).

        iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iRight. iLeft.
        do 2 (iSplit; try (iPureIntro; done)). iModIntro.
        iSplit.
        2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }
        iIntros (b1 b2).
        iApply rel_value. rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ tapeN ); [set_solver|].
        iFrame "Hinv". 
        iIntros "(>(Htape & [(Hα & Hl1 & Hl1s & Hla) | #(Hβ & Hl1 & Hl1s &Hla)]) & Hclose)". 
        * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl1".
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
          iApply rel_na_close. iFrame. iSplitR "Hlb"; [iLeft; iFrame| ]. 
          rel_pures_l. rel_pures_r.
          iDestruct ("HQ" with "Hnone") as "HQnone".
          iDestruct ("Hk" with "HQnone") as "Hknone".
          iApply (rel_exhaustion [_;_] [_;_] with "[$]").
          iApply "IH".
        * iApply rel_na_close. iFrame. iSplitR; [iRight; iFrame "#"|].
          iApply (rel_load_l with "Hl1"). iIntros "!> _".
          iApply (rel_load_r with "Hl1s"). iIntros "_".
          rel_pures_l. rel_exp_l. rel_pures_l.
          rel_pures_r.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH".

    (* Recv bob = Some b *)
    - iIntros (b1 b2). iApply rel_value.
      rel_pures_l. rel_pures_r.
      iApply (rel_na_inv _ _ tapeN ); [set_solver|].
      iFrame "Hinv". 
      iIntros "(>(Htape & [(Hα & Hl1 & Hl1s & Hla) | #(Hα & Hl1 & Hl1s &Hla)]) & Hclose)". 
      + iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl1".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s". rel_pures_l.
        iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame; iDestruct "Hα" as (ms) "(%Hf' & Hα)"; apply map_eq_nil in Hf'; simplify_eq; done|].
        iDestruct ("HQ" with "Hnone") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]").
        iClear (k1 k2 S) "Hfillrel".
        iLöb as "IH".
        iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
        iIntros (e1 e2 ?)
          "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".

        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β). 
          do 2rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 alice l1' l2' k2 a b).
          iApply (rel_na_inv _ _ tapeN ); [set_solver|].
          iFrame "Hinv". 
          iIntros "(>(Htape & [(Hα & Hl1 & Hl1s & Hla) | #(Hα & Hl1 & Hl1s &Hla)]) & Hclose)".

          (* getKey2 hasn't been called before *)
          -- iApply (rel_load_l_mask [HandleCtx _ _ _; AppRCtx _; CaseCtx _ _ ]).
             iFrame. iIntros "!> Hla". simpl. 
             rel_pures_l.
             iApply (rel_rand_l _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _]).
             iAssert (α ↪N (n; [fin_to_nat a]))%I with "[Hα]" as "Hα".
             { iExists [a]. simpl. iFrame. done. }
             iFrame. iIntros "!>Hα %Hlta". rel_pures_l.
             iApply (rel_store_l _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hla"). iIntros "!> Hla".
             rel_pures_l. iApply (rel_exp_l _ [HandleCtx _ _ _; AppRCtx _] _ _ _ a).
             rel_pures_l; [set_solver|].
             iApply (rel_load_l_mask [CaseCtx _ _] ). iFrame. iIntros "!> Hl1". rel_pures_l.
             iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1"). iIntros "!> Hl1". rel_pures_l.
             iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
             rel_pures_r.
             iApply (rel_store_r _ _ _ _  [AppRCtx _] with "Hl1s"). iIntros "Hl1s". rel_pures_r.

             iApply fupd_rel.
             iMod (ghost_map_elem_persist with "Hl1") as "Hl1".
             iMod (ghost_map_elem_persist with "Hl1s") as "Hl1s".
             iMod (ghost_map_elem_persist with "Hla") as "Hla".
             iDestruct "Hα" as (ns) "(%Hf & Hα)".
             apply map_eq_nil in Hf. simplify_eq.
             iMod (ghost_map_elem_persist with "Hα") as "Hα".
             iModIntro.
             iApply rel_na_close. iFrame.
             iSplitL; [iRight; iFrame|].
             
             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iLeft. iRight.
             iExists _. do 2 (iSplit; try (iPureIntro; done)).
             iModIntro.
             iApply rel_value.
             rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 b α β).
             rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).

             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iRight. iRight.
             do 2 (iSplit; try (iPureIntro; done)). iModIntro.
             iSplit.
             2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                   iDestruct ("HQ" with "Hnone") as "HQfill".
                   iDestruct ("Hk" with "HQfill") as "Hfillrel".
                   iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                   iApply "IH". }

             iIntros (b1' b2').
             iApply rel_value. rel_pures_l. rel_pures_r.
             iApply (rel_load_l with "Hl2"). iIntros "!> _". 
             iApply (rel_load_r with "Hl2s"). iIntros "_".
             rel_pures_l. rel_exp_l. rel_pures_l.
             rel_pures_r.
             rewrite -expgM. rewrite -ssrnat.multE.
             rewrite -Nat.mul_comm.
             iDestruct ("HQ" with "Hsome") as "HQsome".
             iDestruct ("Hk" with "HQsome") as "Hksome".
             iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
             iApply "IH".
             
             (* getKey2 has been called before *)
          -- iApply rel_na_close. iFrame.
             iSplitR; [iRight; iFrame "#"|].
             iApply (rel_load_l with "Hla"). iIntros "!> _".
             rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|].
             iApply (rel_load_l with "Hl1"). iIntros "!> _". rel_pures_l; [set_solver |].
             iApply (rel_load_r with "Hl1s"). iIntros "_". rel_pures_r; [set_solver|].
             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iRight. iRight.
             do 2 (iSplit; try (iPureIntro; done)). iModIntro.
             iSplit.
             2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                   iDestruct ("HQ" with "Hnone") as "HQfill".
                   iDestruct ("Hk" with "HQfill") as "Hfillrel".
                   iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                   iApply "IH". }
             iIntros (b1' b2').
             iApply rel_value. rel_pures_l. rel_pures_r.
             iApply (rel_load_l with "Hl2"). iIntros "!> _". 
             iApply (rel_load_r with "Hl2s"). iIntros "_".
             rel_pures_l. rel_exp_l. rel_pures_l.
             rel_pures_r.
             rewrite -expgM. rewrite -ssrnat.multE.
             rewrite -Nat.mul_comm.
             iDestruct ("HQ" with "Hsome") as "HQsome".
             iDestruct ("Hk" with "HQsome") as "Hksome".
             iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
             iApply "IH".

             
      (* getKey1 second time. No a is sampled *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
          do 2 rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 bob l1' l2' k2 a b).
          iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
          iApply (rel_load_r with "Hl2s"). iIntros "_".
          iApply (rel_load_l with "Hlb"). iIntros "!> _". rel_pures_l. iModIntro.
          rel_pures_l. rel_exp_l.
          rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
          rel_pures_l; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
          iApply (rel_load_l with "Hl2").
          iIntros "!> _".
          rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).

          iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iLeft.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                iDestruct ("HQ" with "Hnone") as "HQfill".
                iDestruct ("Hk" with "HQfill") as "Hfillrel".
                iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                iApply "IH". }
          iIntros (b1' b2').
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_na_inv _ _ tapeN ); [set_solver|].
          iFrame "Hinv". 
          iIntros "(>(Htape & [(Hα & Hl1 & Hl1s & Hla) | #(Hα & Hl1 & Hl1s &Hla)]) & Hclose)". 
          -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl1".
             iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
             iApply rel_na_close. iFrame. iSplitR "Hlb"; [iLeft; iFrame| ]. 
             rel_pures_l. rel_pures_r.
             iDestruct ("HQ" with "Hnone") as "HQnone".
             iDestruct ("Hk" with "HQnone") as "Hknone".
             iApply (rel_exhaustion [_;_] [_;_] with "[$]").
             iApply "IH".
          -- iApply rel_na_close. iFrame. iSplitR "Hlb"; [iRight; iFrame "#"|].
             iApply (rel_load_l with "Hl1"). iIntros "!> _".
             iApply (rel_load_r with "Hl1s"). iIntros "_".
             rel_pures_l. rel_exp_l. rel_pures_l.
             rel_pures_r.
             rewrite -expgM. rewrite -ssrnat.multE.
             rewrite -Nat.mul_comm.
             iDestruct ("HQ" with "Hsome") as "HQsome".
             iDestruct ("Hk" with "HQsome") as "Hksome".
             iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
             iApply "IH".

      + iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
        iApply (rel_load_l with "Hl1"). iIntros "!> _".
        iApply (rel_load_r with "Hl1s"). iIntros "_". 
        rel_pures_r.
        rel_pures_l. rel_exp_l. rel_pures_l.
        rewrite -expgM. rewrite -ssrnat.multE.
        rewrite -Nat.mul_comm.
        iDestruct ("HQ" with "Hsome") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]").
        iClear (k1 k2 S) "Hfillrel".
        iLöb as "IH".
        iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
        iIntros (e1 e2 ?)
          "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".

         (* getKey2 after first getKey1. *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β). 
        do 2rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 alice l1' l2' k2 a b).
        iApply (rel_load_l with "Hla"). iIntros "!> _".
        rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|].
        iApply (rel_load_l with "Hl1"). iIntros "!> _". rel_pures_l; [set_solver |].
        iApply (rel_load_r with "Hl1s"). iIntros "_". rel_pures_r; [set_solver|].
        iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iRight. iRight.
        do 2 (iSplit; try (iPureIntro; done)). iModIntro.
        iSplit.
        2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }
        iIntros (b1' b2').
        iApply rel_value. rel_pures_l. rel_pures_r.
        iApply (rel_load_l with "Hl2"). iIntros "!> _". 
        iApply (rel_load_r with "Hl2s"). iIntros "_".
        rel_pures_l. rel_exp_l. rel_pures_l.
        rel_pures_r.
        rewrite -expgM. rewrite -ssrnat.multE.
        rewrite -Nat.mul_comm.
        iDestruct ("HQ" with "Hsome") as "HQsome".
        iDestruct ("Hk" with "HQsome") as "Hksome".
        iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
        iApply "IH".
        

      (* getKey1 second time. No a is sampled *)
        * do 2 rel_pures_l; [apply Hk1; set_solver|]. fold (KontGetKey1 k1 la lb α β).
          do 2 rel_pures_r; [split; [apply Hk2; set_solver| set_solver]|]. fold (KontGetKey2 k2 a b). fold (KontChannel2 bob l1' l2' k2 a b).
          iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
          iApply (rel_load_r with "Hl2s"). iIntros "_".
          iApply (rel_load_l with "Hlb"). iIntros "!> _". rel_pures_l. iModIntro.
          rel_pures_l. rel_exp_l.
          rel_pures_r; [set_solver|]. fold (KontChannel2' l1' l2' k2 a b).
          rel_pures_l; [set_solver|]. fold (KontChannel1 bob la lb l1 l2 k1 a α β).
          iApply (rel_load_l with "Hl2").
          iIntros "!> _".
          rel_pures_l; [set_solver|]. fold (KontChannel1' la lb l1 l2 k1 a α β).

          iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iLeft.
          do 2 (iSplit; try (iPureIntro; done)). iModIntro.
          iSplit.
          2 : { iApply rel_value. rel_pures_l. rel_pures_r.
                iDestruct ("HQ" with "Hnone") as "HQfill".
                iDestruct ("Hk" with "HQfill") as "Hfillrel".
                iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
                iApply "IH". }
          iIntros (b1' b2').
          iApply rel_value. rel_pures_l. rel_pures_r.
          iApply (rel_load_l with "Hl1"). iIntros "!> _".
          iApply (rel_load_r with "Hl1s"). iIntros "_".
          rel_pures_l. rel_exp_l. rel_pures_l.
          rel_pures_r.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQsome".
          iDestruct ("Hk" with "HQsome") as "Hksome".
          iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
          iApply "IH". }
  Qed.
  
