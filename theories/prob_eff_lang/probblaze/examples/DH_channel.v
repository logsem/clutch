From iris.proofmode Require Import base tactics classes.
From iris.base_logic.lib Require Import  na_invariants.
From iris.algebra Require Import agree excl auth frac excl_auth.
From iris.algebra.lib Require Import dfrac_agree.
From clutch Require Import stdpp_ext.
From clutch.prob_eff_lang.probblaze Require Import logic primitive_laws proofmode
  spec_rules spec_ra notation
  class_instances valgroup.

Import fingroup.

Import fingroup.fingroup.

Import valgroup_notation.
Import valgroup_tactics.

Section implementation.
  Context {vg : val_group}.           (* A group on a subset of values. *)
  Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
  Context {vgg : @val_group_generator vg}.   (* G is generated by g. *)

  #[local] Notation n := (S n'').

  Definition sample : expr := λ: <>, rand #n.
  Definition samplelbl α : expr := λ: <>, (rand(α) #n).

  Definition Send (e : expr) := InjL e.
  Definition Recv (e : expr) := InjR e.
  Definition SendV (v : val) := InjLV v.
  Definition RecvV (v : val) := InjRV v.
  Definition bob := InjLV #()%V.
  Definition alice := InjRV #()%V.
  Definition pow : expr := rec: "pow" "b" "e" := if: "e" = #0 then #1 else "b" * ("pow" "b" ("e" - #1)).
  Definition modn : expr := rec: "mod" "a" := if: "a" < #n then "a" else "mod" ("a" - #n).

  Definition F_AUTH (channel : label) f : expr :=
    let: "m1" := ref NONEV in
    let: "m2" := ref NONEV in

    handle: f with
    | effect channel "message", rec "k" =>
        match: "message" with
        | InjL "payload" =>
            let, ("m", "dst") := "payload" in
            match: "dst" with
              InjL <> => match: !"m1" with
                         NONE => "m1" <- SOME "m";; (do: channel (Send ("m", "dst")));; "k" #()%V
                       | SOME "x" => "k" #()%V 
                       end
            | InjR <> => match: !"m2" with
                          NONE => "m2" <- SOME "m";; (do: channel (Send ("m", "dst")));; "k" #()%V
                        | SOME "x" => "k" #()%V 
                        end
            end
        | InjR "from" =>
            let: "r" := (do: channel (Recv "from")) in
             match: "r" with
               NONE => "k" NONEV
             | SOME "x" => match: "from" with
                             InjL <> => match: !"m2" with
                                          NONE => "k" NONEV
                                        | SOME "m" => "k" (SOME "m")
                                        end
                           | InjR <> => match: !"m1" with
                                          NONE => "k" NONEV
                                        | SOME "m" => "k" (SOME "m")
                                        end
                           end
             end
        end
     | return "y" => #()%V end.


  Definition F_KE (getKey channel : label) f : expr :=
    let: "key" := (sample #()%V) in

    handle: f with
    | effect getKey "p", rec "k" =>
        match: "p" with
          InjL <> =>
            (do: channel Send (#0, bob));;
            let: "r" := do: channel Recv bob in
            match: "r" with
              NONE => "k" NONEV
            | SOME "w" => "k" (SOME "key")
            end
        | InjR <> =>
            (do: channel Send (#0, alice));;
            let: "r" := do: channel Recv alice in
            match: "r" with
              NONE => "k" NONEV
            | SOME "w" => "k" (SOME "key")
            end
       end
    | return "y" => "y" end.


  Definition DH_KE (getKey channel : label) f : expr :=
    let: "α" := alloc #n in
    let: "β" := alloc #n in
    let: "l1" := ref NONEV in
    let: "l2" := ref NONEV in
    handle: f with
    | effect getKey "p", rec "k" =>
        match: "p" with
          InjL <> =>
            let: "a" :=
              (match: !"l1" with
                NONE => let: "a" := (samplelbl "α" #()%V) in "l1" <- SOME "a";; "a"
              | SOME "a" => "a"
              end) in
            let: "gA" := g^"a" in
            (do: channel (Send ("gA", bob)));;
            let: "r" := do: channel (Recv bob) in
            match: "r" with
              NONE => "k" NONEV
            | SOME "gB" =>
                let: "key" := "gB"^"a" in
                "k" (SOME "key")
            end
        | InjR <> =>
           let: "b" :=
              match: !"l2" with
                NONE => let: "b" := (samplelbl "β" #()%V) in "l2" <- SOME "b";; "b"
              | SOME "b" => "b"
              end in
            let: "gB" := g^"b" in
            (do: channel (Send ("gB", alice)));;
            let: "r" := do: channel (Recv alice) in
            match: "r" with
              NONE => "k" NONE
            | SOME "gA" =>
                let: "key" := "gA"^"b" in
                "k" (SOME "key")
            end
       end
   | return "y" => "y" end.

  Definition DH_SIM (channel : label) (f : expr) : expr :=
      handle: f with
    | effect channel "payload", rec "k" =>
        match: "payload" with
        | InjL "payload" =>
            let, ("m", "dst") := "payload" in
            match: "dst" with
              InjL <> => let: "c" := sample #()%V in
                         let: "gC" := g^"c" in
                         (do: channel (Send ("gC", bob)));;
                         "k" #()%V
            | InjR <> => let: "c" := sample #()%V in
                         let: "gC" := g^"c" in
                         (do: channel (Send ("gC", alice)));;
                         "k" #()%V
            end
        | InjR "from" =>
            let: "r" := do: channel (Recv "from") in
             match: "r" with
               NONE => "k" NONE
             | SOME "x" => "k" (SOME #0)
             end
        end
    | return "y" => "y" end.

  Definition C (getKey channel : label) (DH : expr) (f : expr) : expr :=
    let, ("ga", "gb", "gc") := DH in

    handle: f with
    | effect getKey "p", rec "k" =>
        match: "p" with
          InjL <> =>
            (do: channel (Send ("ga", bob)));;
            let: "r" := (do: channel (Recv bob)) in
            match: "r" with
              NONE => "k" NONE
            | SOME "w" => "k" (SOME "gc")
            end
        | InjR <> =>
            (do: channel (Send ("gb", alice)));;
            let: "r" := (do: channel (Recv alice)) in
            match: "r" with
              NONE => "k" NONE
            | SOME "w" => "k" (SOME "gc")
            end
        end
    | return "y" => "y" end.

  Definition DH_real : expr :=
    let: "a" := sample #()%V in
    let: "b" := sample #()%V in
    (g^"a", g^"b", g^("a"*"b")).

  Definition DH_rand : expr :=
    let: "a" := sample #()%V in
    let: "b" := sample #()%V in
    let: "c" := sample #()%V in
    ( g^"a", g^"b", g^"c").

End implementation.

Section handlee_verification.
  Context `{!probblazeRGS Σ}.
  Context (channel1 channel2 getKey1 getKey2 : label).
  Context {vg : val_group}.           (* A group on a subset of values. *)
  Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
  Context {G : clutch_group (vg:=vg) (cg:=cg)}.
  Context {vgg : @val_group_generator vg}.   (* G is generated by g. *)
  Context `{!inG Σ (authR (agreeUR valO)), !inG Σ (exclR unitO), !inG Σ dfracO, !inG Σ (dfrac_agreeR valO), !inG Σ (excl_authR unitO) }.

  #[local] Notation n := (S n'').

  Program Definition GetKey1 : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: getKey1 (InjL #()%V) ⌝%E ∗
                ⌜ e2 = do: getKey2 (InjL #()%V) ⌝%E ∗
                □ (Q NONEV NONEV ∗ ∀ key : vgG, Q (SOMEV key) (SOMEV key) )
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition GetKey2 : iThy Σ :=
     λ e1 e2, (λne Q,
                ⌜ e1 = do: getKey1 (InjR #()%V) ⌝%E ∗
                ⌜ e2 = do: getKey2 (InjR #()%V) ⌝%E ∗
                □ (Q NONEV NONEV ∗ ∀ key : vgG, Q (SOMEV key) (SOMEV key) )
             )%I.
  Next Obligation. solve_proper. Qed.
    
  Program Definition SendBob : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : val,
                ⌜ e1 = do: channel1 (SendV (m, bob)) ⌝%E ∗
                  ⌜ e2 = do: channel2 (SendV (m, bob)) ⌝%E ∗
                   □ Q (Val #()%V) (Val #()%V)
             )%I. 
  Next Obligation. solve_proper. Qed.

  Program Definition SendAlice : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : val, 
                  ⌜ e1 = do: channel1 (SendV (m, alice)) ⌝%E ∗
                  ⌜ e2 = do: channel2 (SendV (m, alice)) ⌝%E ∗
                  □ Q (Val #()%V) (Val #()%V)
             )%I. 
  Next Obligation. solve_proper. Qed.

  Program Definition RecvBob : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: channel1 (RecvV bob) ⌝%E ∗
                ⌜ e2 = do: channel2 (RecvV bob) ⌝%E ∗
                □ ((∀ gB : vgG, Q (SOMEV gB) (SOMEV gB))
                   ∗ Q NONEV NONEV)
                  )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition RecvAlice : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: channel1 (RecvV alice) ⌝%E ∗
                ⌜ e2 = do: channel2 (RecvV alice) ⌝%E ∗
                 □ ((∀ gA : vgG, Q (SOMEV gA) (SOMEV gA)) ∗ Q NONEV NONEV)
                  )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition RecvBobAuth : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: channel1 (RecvV bob) ⌝%E ∗
                ⌜ e2 = do: channel2 (RecvV bob) ⌝%E ∗
                □ ((∀ b1 b2 : nat, Q (SOMEV #b1) (SOMEV #b2)) ∧ Q NONEV NONEV)
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition RecvAliceAuth : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: channel1 (RecvV alice) ⌝%E ∗
                ⌜ e2 = do: channel2 (RecvV alice) ⌝%E ∗
                □ ((∀ b1 b2 : nat, Q (SOMEV #b1) (SOMEV #b2)) ∧ Q NONEV NONEV)
             )%I.
  Next Obligation. solve_proper. Qed.

  Definition token γ := own γ (Excl ()).
                   
  
  Program Definition SendBobFirst γtok γfrac γauth ι : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : val, ((|={⊤, ⊤ ∖ ↑ι }=> ((own γfrac DfracDiscarded -∗ (|={⊤ ∖ ↑ι, ⊤}=> token γtok ∗ own γauth (to_dfrac_agree DfracDiscarded m))) ∨ |={⊤ ∖ ↑ι , ⊤}=> own γfrac DfracDiscarded)) ∗  
                            (⌜ e1 = do: channel1 (SendV (m, alice)) ⌝%E ∗
                             ⌜ e2 = do: channel2 (SendV (m, alice)) ⌝%E)  ∗ 
                            □ (Q (Val #()%V) (Val #()%V)))
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition SendBobSucc γfrac : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : vgG, (∃ q : dfrac, own γfrac q ∗
                  (⌜ e1 = do: channel1 (SendV (m, alice)) ⌝%E ∗
                   ⌜ e2 = do: channel2 (SendV (m, alice)) ⌝%E) ∗
                  □ (∀ q : dfrac, own γfrac q -∗ Q (Val #()%V) (Val #()%V)))
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition RecvAliceTest γauth : iThy Σ :=
    λ e1 e2, (λne Q,
                 ⌜ e1 = do: channel1 (RecvV alice) ⌝%E ∗
                 ⌜ e2 = do: channel2 (RecvV alice) ⌝%E ∗
                 □ (Q NONEV NONEV ∗ (∀ m, own γauth (to_dfrac_agree DfracDiscarded m) -∗ Q (SOMEV m) (SOMEV m)))
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition SendAliceFirst γtok γfrac γauth ι : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : val, ((|={⊤, ⊤ ∖ ↑ι }=> ((own γfrac DfracDiscarded -∗ (|={⊤ ∖ ↑ι, ⊤}=> token γtok ∗ own γauth (to_dfrac_agree DfracDiscarded m))) ∨ |={⊤ ∖ ↑ι , ⊤}=> own γfrac DfracDiscarded)) ∗  
                             (⌜ e1 = do: channel1 (SendV (m, bob)) ⌝%E ∗
                              ⌜ e2 = do: channel2 (SendV (m, bob)) ⌝%E)  ∗ 
                             □ (Q (Val #()%V) (Val #()%V)))
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition SendAliceSucc γfrac : iThy Σ :=
    λ e1 e2, (λne Q,
                ∃ m : vgG, (∃ q : dfrac, own γfrac q ∗
                                      (⌜ e1 = do: channel1 (SendV (m, bob)) ⌝%E ∗
                                       ⌜ e2 = do: channel2 (SendV (m, bob)) ⌝%E) ∗
                                      □ (∀ q : dfrac, own γfrac q -∗ Q (Val #()%V) (Val #()%V)))
             )%I.
  Next Obligation. solve_proper. Qed.

  Program Definition RecvBobTest γauth : iThy Σ :=
    λ e1 e2, (λne Q,
                ⌜ e1 = do: channel1 (RecvV bob) ⌝%E ∗
                ⌜ e2 = do: channel2 (RecvV bob) ⌝%E ∗
                □ (Q NONEV NONEV ∗ (∀ m, own γauth (to_dfrac_agree DfracDiscarded m) -∗ Q (SOMEV m) (SOMEV m)))
             )%I.
  Next Obligation. solve_proper. Qed. 

  
  Definition alphaN : namespace := nroot .@ "alpha".
  Definition betaN : namespace := nroot .@ "beta".
  Definition atokN : namespace := nroot .@ "atokN".
  Definition btokN : namespace := nroot .@ "btokN".

  Definition X γtoka atokN γtokb btokN γfraca γfracb γautha γauthb : iThy Σ := iThyTraverse [channel1] [channel2]
                                                                     (iThySum (iThySum (SendAliceFirst γtoka γfraca γautha atokN) (RecvBobTest γauthb))
                                                                        (iThySum (SendBobFirst γtokb γfracb γauthb btokN) (RecvAliceTest γautha))).
  Definition T : iThy Σ := iThyTraverse [getKey1] [getKey2] (iThySum GetKey1 GetKey2).
  Definition Z : iThy Σ := iThyTraverse [channel1] [channel2] (iThySum (iThySum (SendBob) (RecvBob)) (iThySum (SendAlice) (RecvAlice))).
  Definition Y : iThy Σ := iThyTraverse [channel1] [channel2] (iThySum (iThySum SendAlice SendBob) (iThySum RecvAliceAuth RecvBobAuth)).


  Lemma token_alloc : ⊢ |==> ∃ γ, token γ.
  Proof.
    iApply own_alloc. 
    constructor.
  Qed.

  Lemma token_agree γ : ⊢ token γ -∗ token γ -∗ False.
  Proof.
    iIntros "Ha Hb". 
    iDestruct (own_valid_2 with "Ha Hb") as "%Hvalid".
    done.
  Qed.

  Lemma auth_upd v' γ v : ⊢ own γ (to_dfrac_agree (DfracOwn 1) v) -∗ |==>  own γ (to_dfrac_agree (DfracOwn 1) v').
  Proof.
    iApply own_update.
    apply cmra_update_exclusive.
    constructor; done.
  Qed.

  Lemma auth_agree γ q q' v v' :
    ⊢ own γ (to_dfrac_agree q v) -∗ own γ (to_dfrac_agree q' v') -∗ ⌜ v = v' ⌝.
  Proof.
    iIntros "H1 H2".
    iDestruct (own_op with "[$H1 $H2]") as "H".
    iDestruct (own_valid with "H") as "%H".
    iPureIntro.
    by apply dfrac_agree_op_valid in H as (?&H). 
  Qed.

  Lemma auth_persist γ q v : ⊢ own γ (to_dfrac_agree q v) -∗ |==> own γ (to_dfrac_agree DfracDiscarded v).
  Proof.
    iApply own_update.
    by apply dfrac_agree_persist.
  Qed.

  Lemma dfrac_persist γ (q : dfrac) : ⊢ own γ q -∗ |==> own γ DfracDiscarded.
  Proof.
    iApply own_update.
    apply dfrac_discard_update.
  Qed.

  Lemma dfrac_contra γ (q : dfrac) : ⊢ own γ q -∗ own γ (DfracOwn 1) -∗ False.
  Proof.
    iIntros "H1 H2".
    iDestruct (own_op with "[$H1 $H2]") as "H".
    iDestruct (own_valid with "H") as "%H".
    iPureIntro.
    eapply exclusive_r; eauto using dfrac_full_exclusive.
  Qed.
  
  Lemma DH_KE_C_DH_real f1 f2 γtoka γtokb γfraca γfracb γautha γauthb :
    let X' := X γtoka atokN γtokb btokN γfraca γfracb γautha γauthb in
         (∀ s n, val_subst s n f1 = f1) →
         (∀ s n, val_subst s n f2 = f2) →
         token γtoka -∗
         token γtokb -∗
           own γautha (to_dfrac_agree (DfracOwn 1) #()%V) -∗
           own γauthb (to_dfrac_agree (DfracOwn 1) #()%V) -∗
           REL f1 ≤ f2 <|T|> {{ (λ v1 v2, ⌜v1 = #()%V⌝ ∧ ⌜v2 = #()%V⌝) }} -∗
           REL (DH_KE getKey1 channel1 f1) ≤ (C getKey2 channel2 DH_real f2) <|X'|> {{ (λ v1 v2, ⌜ v1 = v2 ⌝) }}.
  Proof using G.
    iIntros (X' Hf1closed Hf2closed) "Htoka Htokb Ha Hb Hff".
    iApply rel_alloctape_l. iIntros (α) "!> Hα". rel_pures_l.
    iApply rel_alloctape_l. iIntros (β) "!> Hβ". rel_pures_l.
    iApply rel_alloc_l. iIntros (la) "!> Hla".
    iApply rel_alloc_l. iIntros (lb) "!> Hlb".
    rel_pures_r. 
    do 3 rewrite Hf1closed.
    iDestruct "Hα" as (ns) "(%Hf & Hα)". apply map_eq_nil in Hf. simplify_eq.
    iApply rel_couple_TU; [done|]. iFrame. simpl. iIntros (a) "Hα".
    iDestruct "Hβ" as (ms) "(%Hf' & Hβ)". apply map_eq_nil in Hf'. simplify_eq.
    iApply rel_couple_TU; [done|]. iFrame "Hβ". simpl. iIntros (b) "Hβ".
    (* iApply fupd_rel.
          iMod (token_alloc (g ^+ a)%g) as (γa) "#Hga".
          iMod (token_alloc (g ^+ b)%g) as (γb) "#Hgb".
          iModIntro. *)
    rel_pures_r. rewrite -Nat2Z.inj_mul.
    do 3 rel_exp_r.
    rel_pures_r.
    do 3 rewrite Hf2closed.
    rel_pures_l. do 1 rewrite Hf1closed.
    
    iApply fupd_rel.
    iMod (auth_upd (g ^+ a)%g with "Ha") as "Ha".
    iMod (auth_upd (g ^+ b)%g with "Hb") as "Hb".
    iMod (auth_persist with "Ha") as "#Ha".
    iMod (auth_persist with "Hb") as "#Hb".
    iModIntro.

    iApply fupd_rel.
    iMod (inv_alloc atokN _ (token γtoka ∨ own γfraca DfracDiscarded)%I with "[Htoka]") as "#Hinvta".
    { iNext; iLeft;iFrame. }
    (* iApply (rel_na_alloc (token γtoka ∨ own γautha DfracDiscarded)%I atokN).
       iSplitL "Htoka"; [iNext; iFrame|].
       iIntros "#Hinvta". *)

    iMod (inv_alloc btokN _ (token γtokb ∨ own γfracb DfracDiscarded)%I with "[Htokb]") as "#Hinvtb".
    { iNext; iFrame. }
    (* iApply (rel_na_alloc (token γtokb ∨ own γauthb DfracDiscarded)%I btokN).
       iSplitL "Htokb"; [iNext; iFrame|].
       iIntros "#Hinvtb". *)
    iModIntro.
    
    iApply (rel_na_alloc
              ((β ↪ (n; [b]) ∗ lb ↦ NONEV)
               ∨ (β ↪□ (n; [])
                  ∗ lb ↦□ SOMEV #b)
              )%I
              betaN).
    iSplitL "Hβ Hlb"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinvb".
    
    iApply (rel_na_alloc
              ((α ↪ (n; [a]) ∗ la ↦ NONEV)
               ∨ (α ↪□ (n; [])
                  ∗ la ↦□ SOMEV #a))%I
              alphaN).
    iSplitL "Hα Hla"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinva".
    
    
    iApply (rel_exhaustion [_] [_] _ _ with "[$]").
    iLöb as "IH".
    
    iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
    
    iIntros (e1 e2 ?)
      "[%e1' [%e2' [%k1 [%k2 [%S
           (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
          ]]]]] #Hk".
    
        1 : {
          do 2 rel_pures_l; [apply Hk1; set_solver|].
          do 2rel_pures_r; [apply Hk2; set_solver|].
          iApply (rel_na_inv _ _ alphaN ); [set_solver|].
          iFrame "Hinva". 
          iIntros "([(Hα & Hla) | (#Hα & #Hla)] & Hclose)".
          - iApply (rel_load_l_mask [AppRCtx _; CaseCtx _ _]).
            iFrame. iIntros "!> Hla". rel_pures_l.
            iApply (rel_rand_l _ [AppRCtx _; AppRCtx _]).
            iAssert (α ↪N (n; [fin_to_nat a]))%I with "[Hα]" as "Hα".
            { iExists [a]. simpl. iFrame. done. }
            iFrame. iIntros "!>Hα _". rel_pures_l.
            iApply (rel_store_l _ _ _ [AppRCtx _; AppRCtx _] with "Hla").
            iIntros "!> Hla".
            rel_pures_l.
            iApply (rel_exp_l _ [AppRCtx _]). rel_pures_l.
     
            iApply fupd_rel.
            iMod (ghost_map_elem_persist with "Hla") as "#Hla".
            iDestruct "Hα" as (ns) "(%Hf & Hα)". apply map_eq_nil in Hf. simplify_eq.
            iMod (ghost_map_elem_persist with "Hα") as "#Hα".
            iModIntro.
            iApply rel_na_close. iFrame.
            iSplitL; [iNext; iRight; iFrame "#"|].
            
           
     
            (* Send (gA, bob) *)
            iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
            iApply rel_introduction'.
            iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
            iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
            iLeft. iLeft. 
            iExists _.
            iSplitL.
            { iMod (inv_acc with "Hinvta") as "([>Htok | >#Hfrac'] & Hclose)"; try done.
              - iModIntro. iLeft.
                iIntros. iFrame "#". iFrame.
                iApply "Hclose". iNext. by iRight.
              - iModIntro. iRight. iFrame "#".
                iApply "Hclose". iNext.
                by iRight. }
            iSplit; first ( do 2 (iSplit; try (iPureIntro; done))).
            iModIntro.
            
            (* iApply (rel_na_inv _ _ alphaN ); [set_solver|].
               iFrame "Hinva". 
               iIntros "([(_ & Hcontra & Htoka) | [(_ & _ & >Hcontra) | (_ & _ & Hautha)]] & Hclose)". *)
            
            
            iApply rel_value.
            rel_pures_l.
            rel_pures_r.
     
            (* Recv bob (either none or some) *)
            iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
            iApply rel_introduction'.
            iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
            iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
            iLeft. iRight.
            do 2 (iSplit; try (iPureIntro; done)).
            iModIntro.
            iSplitL.
     
            (* Recv bob = None *)
            + iApply rel_value.
              rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
     
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH".
     
            (* Recv bob = Some gB *)
            + iIntros (m) "Ha'".
              iDestruct (auth_agree with "[$Hb] [$Ha']") as "<-".
              iApply rel_value.
              rel_pures_l. rel_exp_l. 
              rel_pures_r.
              rewrite -expgM. rewrite -ssrnat.multE.
              rewrite -Nat.mul_comm.
              
              iDestruct ("HQ" with "Hsome") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH".
              
          - iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
            iApply (rel_load_l with "Hla"). iIntros "!> _". rel_pures_l. rel_exp_l. rel_pures_l.
     
             (* Send (gA, bob) *)
            iApply (rel_bind' [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|].
            iApply rel_introduction'.
            iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
            iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
            iLeft. iLeft.
            iExists _.
            iSplitL.
            { iMod (inv_acc with "Hinvta") as "([>Htok | >#Hfrac'] & Hclose)"; try done.
              - iModIntro. iLeft.
                iIntros. iFrame "#". iFrame.
                iApply "Hclose". iNext. by iRight.
              - iModIntro. iRight. iFrame "#".
                iApply "Hclose". iNext.
                by iRight. }
            iSplit; first ( do 2 (iSplit; try (iPureIntro; done))).

            iModIntro. 
            iApply rel_value.
            rel_pures_l.
            rel_pures_r.
     
            (* Recv bob (either none or some) *)
            iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
            iApply rel_introduction'.
            iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
            iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
            iLeft. iRight.
            do 2 (iSplit; try (iPureIntro; done)).
            iModIntro.
            iSplitL.
     
            (* Recv bob = None *)
            + iApply rel_value.
              rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
     
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH".
     
            (* Recv bob = Some gB *)
            + iIntros (m) "Ha'".
              iDestruct (auth_agree with "[$Hb] [$Ha']") as "<-".
              iApply rel_value.
              rel_pures_l. rel_exp_l. 
              rel_pures_r.
              rewrite -expgM. rewrite -ssrnat.multE.
              rewrite -Nat.mul_comm.
              
              iDestruct ("HQ" with "Hsome") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH". }

         1 : {
           do 2 rel_pures_l; [apply Hk1; set_solver|]. 
           do 2 rel_pures_r; [apply Hk2; set_solver|].
           iApply (rel_na_inv _ _ betaN ); [set_solver|].
           iFrame "Hinvb". 
           iIntros "(>[(Hβ & Hlb) | #(Hβ & Hlb)] & Hclose)". 
           - iApply (rel_load_l_mask [AppRCtx _; CaseCtx _ _]).
             iFrame. iIntros "!> Hlb". rel_pures_l.
             iApply (rel_rand_l _ [AppRCtx _; AppRCtx _]).
             iAssert (β ↪N (n; [fin_to_nat b]))%I with "[Hβ]" as "Hβ".
             { iExists [b]. simpl. iFrame. done. }
             iFrame. iIntros "!>Hβ _". rel_pures_l.
             iApply (rel_store_l _ _ _ [AppRCtx _; AppRCtx _] with "Hlb").
             iIntros "!> Hlb".
             rel_pures_l.
             iApply (rel_exp_l _ [AppRCtx _]). rel_pures_l.
             
             iApply fupd_rel.
             iMod (ghost_map_elem_persist with "Hlb") as "#Hlb".
             iDestruct "Hβ" as (ns) "(%Hf & Hβ)". apply map_eq_nil in Hf. simplify_eq.
             iMod (ghost_map_elem_persist with "Hβ") as "#Hβ".
             iModIntro.
             iApply rel_na_close. iFrame.
             iSplitL; [iRight; iFrame "#"|].
            
             iApply (rel_bind' [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iRight. iLeft.
             iExists _.
             iSplitL.
             { iMod (inv_acc with "Hinvtb") as "([>Htok | >#Hfrac'] & Hclose)"; try done.
               - iModIntro. iLeft.
                 iIntros. iFrame "#". iFrame.
                 iApply "Hclose". iNext. by iRight.
               - iModIntro. iRight. iFrame "#".
                 iApply "Hclose". iNext.
                 by iRight. }
             iSplit; first ( do 2 (iSplit; try (iPureIntro; done))).
             iModIntro.
             
             iApply rel_value.
             rel_pures_l.
             rel_pures_r.
     
             iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
             iApply rel_introduction'.
             iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
             iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
             iRight. iRight.
             do 2 (iSplit; try (iPureIntro; done)).
             iModIntro.
             iSplitL.

            + iApply rel_value.
              rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
     
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH".

            + iIntros (m) "Hb'".
              iDestruct (auth_agree with "[$Ha] [$Hb']") as "<-".
              iApply rel_value.
              rel_pures_l. rel_exp_l. 
              rel_pures_r.
              rewrite -expgM. rewrite -ssrnat.multE.
              rewrite -Nat.mul_comm.
              
              iDestruct ("HQ" with "Hsome") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH".
              
          - iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
            iApply (rel_load_l with "Hlb"). iIntros "!> _". rel_pures_l. rel_exp_l. rel_pures_l.
     
            iApply (rel_bind' [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|].
            iApply rel_introduction'.
            iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
            iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
            iRight. iLeft.
            iExists _.
            iSplitL.
            { iMod (inv_acc with "Hinvtb") as "([>Htok | >#Hfrac'] & Hclose)"; try done.
              - iModIntro. iLeft.
                iIntros. iFrame "#". iFrame.
                iApply "Hclose". iNext. by iRight.
              - iModIntro. iRight. iFrame "#".
                iApply "Hclose". iNext.
                by iRight. }
            iSplit; first ( do 2 (iSplit; try (iPureIntro; done))).

            iModIntro. 
            iApply rel_value.
            rel_pures_l.
            rel_pures_r.
     
            iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
            iApply rel_introduction'.
            iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
            iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
            iRight. iRight.
            do 2 (iSplit; try (iPureIntro; done)).
            iModIntro.
            iSplitL.
     
            + iApply rel_value.
              rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
     
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH".
     
            (* Recv bob = Some gB *)
            + iIntros (m) "Hb'".
              iDestruct (auth_agree with "[$Ha] [$Hb']") as "<-".
              iApply rel_value.
              rel_pures_l. rel_exp_l. 
              rel_pures_r.
              rewrite -expgM. rewrite -ssrnat.multE.
              rewrite -Nat.mul_comm.
              
              iDestruct ("HQ" with "Hsome") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] _ _ with "[$]"). iApply "IH". }
  Qed. 

  Lemma F_AUTH_F_AUTH f1 f2 γtoka γtokb γfraca γfracb γautha γauthb :
    let X' := X γtoka atokN γtokb btokN γfraca γfracb γautha γauthb in
    (∀ s n, val_subst s n f1 = f1) →
    (∀ s n, val_subst s n f2 = f2) →
    own γfraca (DfracOwn 1) -∗
    own γfracb (DfracOwn 1) -∗
     REL f1 ≤ f2 <|X'|> {{ (λ v1 v2, ⌜ v1 = v2 ⌝) }} -∗
           REL F_AUTH channel1 f1 ≤ F_AUTH channel2 f2 <|Y|> {{ (λ v1 v2, ⌜ v1 = v2 ⌝) }}.
  Proof using G cg channel1 channel2 inG1 inG2 inG3 probblazeRGS0 vg Σ.
    iIntros (X' Hf1closed Hf2closed) "Hfraca Hfracb Hff".
    iApply rel_alloc_l. iIntros (l1) "!> Hl1".
    iApply rel_alloc_l. iIntros (l2) "!> Hl2".
    rel_pures_l. do 2 rewrite Hf1closed.
    iApply rel_alloc_r. iIntros (l1') "Hl1s".
    iApply rel_alloc_r. iIntros (l2') "Hl2s".
    rel_pures_r. do 2 rewrite Hf2closed.

    iApply (rel_na_alloc
              ((l1 ↦ NONEV ∗ l1'  ↦ₛ NONEV ∗ own γfraca (DfracOwn 1))
               ∨ (∃ gA , l1 ↦□ SOMEV gA∗ l1' ↦ₛ□ SOMEV gA ∗ token γtoka
                         ∗ own γfraca DfracDiscarded
                         ∗ own γautha (to_dfrac_agree DfracDiscarded gA))) alphaN).
    iSplitL "Hl1 Hl1s Hfraca"; [iNext; iLeft; iFrame|].
    iIntros "#Hinva".

    iApply (rel_na_alloc
              ((l2 ↦ NONEV ∗ l2'  ↦ₛ NONEV ∗ own γfracb (DfracOwn 1))
               ∨ (∃ gB , l2 ↦□ SOMEV gB∗ l2' ↦ₛ□ SOMEV gB ∗ token γtokb
                         ∗ own γfracb DfracDiscarded
                         ∗ own γauthb (to_dfrac_agree DfracDiscarded gB))) betaN).
    iSplitL "Hl2 Hl2s Hfracb"; [iNext; iLeft; iFrame|].
    iIntros "#Hinvb".
    
    iApply (rel_exhaustion [_] [_] _ _ with "[$]").
    iLöb as "IH".
    iSplit; [iIntros (v1 v2) "->"; rel_pures_l; by rel_pures_r|].
    iIntros (e1 e2 ?)
              "[%e1' [%e2' [%k1 [%k2 [%S
              (-> & %Hk1 & -> & %Hk2 &
              [[(%m & Hupd & (-> & ->) & #HS) | (-> & -> & #(Hnone & Hsome))]
                     | [(%m & Hupd & (-> & ->) & #HS) | (-> & -> & #(Hnone & Hsome))]]
                         & #HQ)]]]]] #Hk".
    1 : {
      iApply (rel_na_inv _ _ alphaN ); [set_solver|].
      iFrame "Hinva". 
      iIntros "(>[(Hl1 & Hl1s & Hfraca) | (%gA & #Hl1 & #Hl1s & Htoka & #Hfraca & #Hautha)] & Hclose)".
      - iApply fupd_rel. iMod "Hupd" as "[Hupd | Hupd]"; [|iMod "Hupd"; iModIntro].
        2 : { by iDestruct (dfrac_contra with "[Hupd][$]") as "Hcontra". }
        iMod (dfrac_persist with "Hfraca") as "#Hfraca".
        iMod ("Hupd" with "Hfraca") as "Hupd".
        iModIntro.
        rel_pures_l; [apply Hk1; set_solver|].
        rel_pures_r; [apply Hk2; set_solver|].
        iApply (rel_load_l_mask [CaseCtx _ _]). iFrame. iIntros "!> Hl1".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
        rel_pures_l. rel_pures_r.
        iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1"). iIntros "!> Hl1".
        iApply (rel_store_r _ _ _ _ [AppRCtx _] with "Hl1s"). iIntros "Hl1s".
        rel_pures_l. rel_pures_r.
        iApply (rel_bind_mask _ [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|iApply iThy_le_refl|].

        iApply fupd_rel.
        iMod (ghost_map_elem_persist with "Hl1s") as "#Hl1s".
        iMod (ghost_map_elem_persist with "Hl1") as "#Hl1".
        iModIntro.
        iApply rel_na_close. iFrame.
        iSplitL "Hupd"; [iNext; iRight; iExists m; iFrame "#"; iFrame|].

        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iLeft. iRight.
        iExists _.
        do 2 (iSplit; try (iPureIntro; done)).
        iModIntro.
        iApply rel_value.
        rel_pures_l. rel_pures_r.

        iDestruct ("HQ" with "HS") as "HQk".
        iDestruct ("Hk" with "HQk") as "Hrelk".
        iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH".

      - iApply fupd_rel. iMod "Hupd" as "[Hupd | Hupd]"; [|iMod "Hupd"; iModIntro].
        1 : { iMod ("Hupd" with "Hfraca") as "(Hcontra & _)". by iDestruct (token_agree with "[$][$]") as "Hcontra". }
        iApply rel_na_close. iFrame.
        iSplitL "Htoka"; [iNext; iRight; iExists gA; iFrame; iFrame "#"|].
        rel_pures_l; [apply Hk1; set_solver|].
        rel_pures_r; [apply Hk2; set_solver|].
        iApply (rel_load_l_mask [CaseCtx _ _]). iFrame "#". iIntros "!> _".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "_".
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "HS") as "HQk".
        iDestruct ("Hk" with "HQk") as "Hrelk".
        iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH". }

    1 : { rel_pures_l; [apply Hk1; set_solver|].
          rel_pures_r; [apply Hk2; set_solver|].
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iRight. do 2 (iSplit; try (iPureIntro; done)).
          iModIntro.
          iSplit; last first.

          + iApply rel_value.
            iDestruct ("HQ" with "Hnone") as "HQk".
            iDestruct ("Hk" with "HQk") as "Hrelk".
            iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH".

          + iIntros (b1 b2). iApply rel_value.
            rel_pures_l. rel_pures_r.
            iApply (rel_na_inv _ _ betaN); [set_solver|].
            iFrame "Hinvb". 
            iIntros "(>[(Hl2 & Hl2s & Hfracb) | (%gB & #Hl2 & #Hl2s & Htokb & #Hfracb & #Hauthb)] & Hclose)".
            * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
              iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s". rel_pures_l.
              iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame|].
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion_mask _ [_] [_] with "[$]"). iApply "IH".
              
            * iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"; iFrame|].
              iApply (rel_load_l with "Hl2"). iIntros "!> _".
              iApply (rel_load_r with "Hl2s"). iIntros "_". 
              rel_pures_r. rel_pures_l.
              iDestruct ("Hsome" with "Hauthb") as "HS".
              iDestruct ("HQ" with "HS") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH". }
          
    1 : {
      iApply (rel_na_inv _ _ betaN ); [set_solver|].
      iFrame "Hinvb". 
      iIntros "(>[(Hl2 & Hl2s & Hfracb) | (%gB & #Hl2 & #Hl2s & Htokb & #Hfracb & #Hauthb)] & Hclose)".
      - iApply fupd_rel. iMod "Hupd" as "[Hupd | Hupd]"; [|iMod "Hupd"; iModIntro].
        2 : { by iDestruct (dfrac_contra with "[Hupd][$]") as "Hcontra". }
        iMod (dfrac_persist with "Hfracb") as "#Hfracb".
        iMod ("Hupd" with "Hfracb") as "Hupd".
        iModIntro.
        rel_pures_l; [apply Hk1; set_solver|].
        rel_pures_r; [apply Hk2; set_solver|].
        iApply (rel_load_l_mask [CaseCtx _ _]). iFrame. iIntros "!> Hl2".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
        rel_pures_l. rel_pures_r.
        iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl2"). iIntros "!> Hl2".
        iApply (rel_store_r _ _ _ _ [AppRCtx _] with "Hl2s"). iIntros "Hl2s".
        rel_pures_l. rel_pures_r.
        iApply (rel_bind_mask _ [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|iApply iThy_le_refl|].

        iApply fupd_rel.
        iMod (ghost_map_elem_persist with "Hl2s") as "#Hl2s".
        iMod (ghost_map_elem_persist with "Hl2") as "#Hl2".
        iModIntro.
        iApply rel_na_close. iFrame.
        iSplitL "Hupd"; [iNext; iRight; iExists m; iFrame "#"; iFrame|].

        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iLeft. iLeft.
        iExists _.
        do 2 (iSplit; try (iPureIntro; done)).
        iModIntro.
        iApply rel_value.
        rel_pures_l. rel_pures_r.

        iDestruct ("HQ" with "HS") as "HQk".
        iDestruct ("Hk" with "HQk") as "Hrelk".
        iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH".

      - iApply fupd_rel. iMod "Hupd" as "[Hupd | Hupd]"; [|iMod "Hupd"; iModIntro].
        1 : { iMod ("Hupd" with "Hfracb") as "(Hcontra & _)". by iDestruct (token_agree with "[$][$]") as "Hcontra". }
        iApply rel_na_close. iFrame.
        iSplitL "Htokb"; [iNext; iRight; iExists gB; iFrame; iFrame "#"|].
        rel_pures_l; [apply Hk1; set_solver|].
        rel_pures_r; [apply Hk2; set_solver|].
        iApply (rel_load_l_mask [CaseCtx _ _]). iFrame "#". iIntros "!> _".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "_".
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "HS") as "HQk".
        iDestruct ("Hk" with "HQk") as "Hrelk".
        iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH". }

    1 : { rel_pures_l; [apply Hk1; set_solver|].
          rel_pures_r; [apply Hk2; set_solver|].
          iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
          iApply rel_introduction'.
          iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
          iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
          iRight. iLeft. do 2 (iSplit; try (iPureIntro; done)).
          iModIntro.
          iSplit; last first.

          + iApply rel_value.
            iDestruct ("HQ" with "Hnone") as "HQk".
            iDestruct ("Hk" with "HQk") as "Hrelk".
            iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH".

          + iIntros (b1 b2). iApply rel_value.
            rel_pures_l. rel_pures_r.
            iApply (rel_na_inv _ _ alphaN); [set_solver|].
            iFrame "#". 
            iIntros "(>[(Hl1 & Hl1s & Hfraca) | (%gA & #Hl1 & #Hl1s & Htoka & #Hfraca & #Hautha)] & Hclose)".
            * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl1".
              iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s". rel_pures_l.
              iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame|].
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion_mask _ [_] [_] with "[$]"). iApply "IH".
              
            * iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"; iFrame|].
              iApply (rel_load_l with "Hl1"). iIntros "!> _".
              iApply (rel_load_r with "Hl1s"). iIntros "_". 
              rel_pures_r. rel_pures_l.
              iDestruct ("Hsome" with "Hautha") as "HS".
              iDestruct ("HQ" with "HS") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              
              (* First call is done. Can call getKey1 or getKey2 again. *)
              iApply (rel_exhaustion [_] [_] with "[$]"). iApply "IH". }
    Qed.


  Lemma F_AUTH_DH_KE_C_DH_real f1 f2 :
    (∀ s n, val_subst s n f1 = f1) →
           (∀ s n, val_subst s n f2 = f2) →
           REL f1 ≤ f2 <|T|> {{ (λ v1 v2, ⌜v1 = #()%V⌝ ∧ ⌜v2 = #()%V⌝) }} -∗
           REL F_AUTH channel1 (DH_KE getKey1 channel1 f1) ≤ F_AUTH channel2 (C getKey2 channel2 DH_real f2) <|Y|> {{ (λ v1 v2, ⌜ v1 = v2 ⌝) }}.
  Proof using G.
    iIntros (Hf1closed Hf2closed) "Hff".
    iApply rel_alloc_l. iIntros (l1) "!> Hl1".
    iApply rel_alloc_l. iIntros (l2) "!> Hl2".
    iApply rel_alloctape_l. iIntros (α) "!> Hα". rel_pures_l.
    iApply rel_alloctape_l. iIntros (β) "!> Hβ". rel_pures_l.
    iApply rel_alloc_l. iIntros (la) "!> Hla".
    iApply rel_alloc_l. iIntros (lb) "!> Hlb".
    iApply rel_alloc_r. iIntros (l1') "Hl1s".
    iApply rel_alloc_r. iIntros (l2') "Hl2s".
    rel_pures_r. 
    do 4 rewrite Hf1closed.
    iDestruct "Hα" as (ns) "(%Hf & Hα)". apply map_eq_nil in Hf. simplify_eq.
    iApply rel_couple_TU; [done|]. iFrame. simpl. iIntros (a) "Hα".
    iDestruct "Hβ" as (ms) "(%Hf' & Hβ)". apply map_eq_nil in Hf'. simplify_eq.
    iApply rel_couple_TU; [done|]. iFrame "Hβ". simpl. iIntros (b) "Hβ".
    rel_pures_r. rewrite -Nat2Z.inj_mul.
    do 3 rel_exp_r.
    rel_pures_r.
    do 5 rewrite Hf2closed.
    rel_pures_l. do 2 rewrite Hf1closed.
    
    iApply (rel_na_alloc
              ((β ↪ (n; [b]) ∗ l2 ↦ NONEV ∗ l2' ↦ₛ NONEV ∗ lb ↦ NONEV)
                ∨ (β ↪□ (n; [])
                   ∗ l2 ↦□ SOMEV (g ^+ b)%g
                   ∗ l2' ↦ₛ□ SOMEV (g ^+ b)%g
                   ∗ lb ↦□ SOMEV #b))%I
              betaN).
    iSplitL "Hl2 Hl2s Hβ Hlb"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinvb".

    iApply (rel_na_alloc
              ((α ↪ (n; [a]) ∗ l1 ↦ NONEV ∗ l1' ↦ₛ NONEV ∗ la ↦ NONEV)
                ∨ (α ↪□ (n; [])
                   ∗ l1 ↦□ SOMEV (g ^+ a)%g
                   ∗ l1' ↦ₛ□ SOMEV (g ^+ a)%g
                   ∗ la ↦□ SOMEV #a))%I
              alphaN).
    iSplitL "Hα Hl1 Hl1s Hla"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinva".
    
    iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
    iLöb as "IH".
    
    iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
    iIntros (e1 e2 ?)
      "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".
    
    (* getKey1 first time *)
    1 : {
    do 2 rel_pures_l; [apply Hk1; set_solver|]. 
    do 2rel_pures_r; [split;[apply Hk2; set_solver|set_solver]|].
    iApply (rel_na_inv _ _ alphaN ); [set_solver|].
    iFrame "Hinva". 
    iIntros "(>[(Hα & Hl1 & Hl1s & Hla) | #(Hα & Hl1 & Hl1s &Hla)] & Hclose)". 
    -     
      iApply (rel_load_l_mask [HandleCtx _ _ _ ; AppRCtx _; CaseCtx _ _]).
      iFrame. iIntros "!> Hla". rel_pures_l.
      iApply (rel_rand_l _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _]).
      iAssert (α ↪N (n; [fin_to_nat a]))%I with "[Hα]" as "Hα".
      { iExists [a]. simpl. iFrame. done. }
      iFrame. iIntros "!>Hα _". rel_pures_l.
      iApply (rel_store_l _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hla").
      iIntros "!> Hla".
      rel_pures_l.
      iApply (rel_exp_l _ [HandleCtx _ _ _ ; AppRCtx _]).
      rel_pures_l; [set_solver|].
      iApply (rel_load_l_mask [CaseCtx _ _]). iFrame. iIntros "!> Hl1".
      iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
      rel_pures_l. rel_pures_r.
      iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1"). iIntros "!> Hl1".
      iApply (rel_store_r _ _ _ _ [AppRCtx _] with "Hl1s"). iIntros "Hl1s".
      rel_pures_l.
      rel_pures_r.
      
      (* Send gA first time *)
      iApply (rel_bind_mask (⊤ ∖ ↑alphaN) [AppRCtx _] [AppRCtx _]);
        [by iApply traversable_iThyTraverse|iApply iThy_le_refl|].
      
      iApply fupd_rel.
      iMod (ghost_map_elem_persist with "Hl1s") as "#Hl1s".
      iMod (ghost_map_elem_persist with "Hl1") as "#Hl1".
      iMod (ghost_map_elem_persist with "Hla") as "#Hla".
      iDestruct "Hα" as (ns) "(%Hf & Hα)". apply map_eq_nil in Hf. simplify_eq.
      iMod (ghost_map_elem_persist with "Hα") as "#Hα".
      iModIntro.
      iApply rel_na_close. iFrame.
      iSplitL; [iRight; iFrame "#"|]. fold Y.
      
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iLeft. iRight.
      iExists _. do 2 (iSplit; try (iPureIntro; done)).
      iModIntro.
      iApply rel_value.
      rel_pures_l; [set_solver|]. 
      rel_pures_r; [set_solver|].
    
      (* Recv bob first time (either none or some) *)
      iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iRight. iRight.
      do 2 (iSplit; try (iPureIntro; done)). iModIntro.
      iSplit; last first.

    (* Recv bob = None *)
      + iApply rel_value.
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "Hnone") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".

        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]"). iApply "IH".

      (* Recv bob = Some b *)
      + iIntros (b1 b2). iApply rel_value.
        rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ betaN ); [set_solver|].
        iFrame "Hinvb". 
        iIntros "(>[(Hβ & Hl2 & Hl2s & Hlb) | #(Hβ & Hl2 & Hl2s &Hlb)] & Hclose)". 
        * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s". rel_pures_l.
          iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame; iDestruct "Hbeta" as (ms) "(%Hf' & Hβ)"; apply map_eq_nil in Hf'; simplify_eq; done|].
          iDestruct ("HQ" with "Hnone") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
          (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".
        
        * iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
          iApply (rel_load_l with "Hl2"). iIntros "!> _".
          iApply (rel_load_r with "Hl2s"). iIntros "_". rel_pures_l.
          rel_pures_r.
          rel_exp_l. rel_pures_l.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
        (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".

    - iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
      iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
      iApply (rel_load_r with "Hl1s"). iIntros "_".
      iApply (rel_load_l with "Hla"). iIntros "!> _". rel_pures_l. iModIntro.
      rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|].
      rel_pures_r; [set_solver|]. 
      iApply (rel_load_l with "Hl1"). iIntros "!> _".
      rel_pures_l; [set_solver|].
      iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iRight. iRight.
      do 2 (iSplit; try (iPureIntro; done)). iModIntro.
      iSplit.
      2 : { iApply rel_value. rel_pures_l. rel_pures_r.
            iDestruct ("HQ" with "Hnone") as "HQfill".
            iDestruct ("Hk" with "HQfill") as "Hfillrel".
            iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
            iApply "IH". }
      iIntros (b1 b2).
      iApply rel_value. rel_pures_l. rel_pures_r.
      iApply (rel_na_inv _ _ betaN ); [set_solver|].
      iFrame "Hinvb". 
      iIntros "(>[(Hβ & Hl2 & Hl2s & Hlb) | #(Hβ & Hl2 & Hl2s &Hlb)] & Hclose)". 
      * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
        iApply rel_na_close. iFrame. iSplitR "Hla"; [iLeft; iFrame| ]. 
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "Hnone") as "HQnone".
        iDestruct ("Hk" with "HQnone") as "Hknone".
        iApply (rel_exhaustion [_;_] [_;_] with "[$]").
        iApply "IH".
      * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame "Hl2". iIntros "!> _".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "_".
        iApply rel_na_close. iFrame. iSplitR "Hla"; [iRight; iFrame "#"| ]. simpl.
        rel_pures_l. rel_pures_r.
        rel_exp_l. rel_pures_l.
        rewrite -expgM. rewrite -ssrnat.multE.
        rewrite -Nat.mul_comm.
        iDestruct ("HQ" with "Hsome") as "HQsome".
        iDestruct ("Hk" with "HQsome") as "Hksome".
        iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
        iApply "IH". }

    1 : {
      do 2 rel_pures_l; [apply Hk1; set_solver|]. 
      do 2rel_pures_r; [split;[apply Hk2; set_solver|set_solver]|].
      iApply (rel_na_inv _ _ betaN ); [set_solver|].
      iFrame "Hinvb". 
      iIntros "(>[(Hβ & Hl1 & Hl1s & Hlb) | #(Hβ & Hl1 & Hl1s &Hlb)] & Hclose)". 
      - iApply (rel_load_l_mask [HandleCtx _ _ _ ; AppRCtx _; CaseCtx _ _]).
        iFrame. iIntros "!> Hlb". rel_pures_l.
        iApply (rel_rand_l _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _]).
        iAssert (β ↪N (n; [fin_to_nat b]))%I with "[Hβ]" as "Hβ".
        { iExists [b]. simpl. iFrame. done. }
        iFrame. iIntros "!>Hβ _". rel_pures_l.
        iApply (rel_store_l _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hlb").
        iIntros "!> Hlb".
        rel_pures_l.
        iApply (rel_exp_l _ [HandleCtx _ _ _ ; AppRCtx _]).
        rel_pures_l; [set_solver|].
        iApply (rel_load_l_mask [CaseCtx _ _]). iFrame. iIntros "!> Hl1".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1s"). iIntros "Hl1s".
        rel_pures_l. rel_pures_r.
        iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1"). iIntros "!> Hl1".
        iApply (rel_store_r _ _ _ _ [AppRCtx _] with "Hl1s"). iIntros "Hl1s".
        rel_pures_l.
        rel_pures_r.
      
        (* Send gB first time *)
        iApply (rel_bind_mask _ [AppRCtx _] [AppRCtx _]);
          [by iApply traversable_iThyTraverse|iApply iThy_le_refl |].
      
        iApply fupd_rel.
        iMod (ghost_map_elem_persist with "Hl1s") as "#Hl1s".
        iMod (ghost_map_elem_persist with "Hl1") as "#Hl1".
        iMod (ghost_map_elem_persist with "Hlb") as "#Hlb".
        iDestruct "Hβ" as (ns) "(%Hf & Hβ)". apply map_eq_nil in Hf. simplify_eq.
        iMod (ghost_map_elem_persist with "Hβ") as "#Hβ".
        iModIntro.
        iApply rel_na_close. iFrame.
        iSplitL; [iRight; iFrame "#"|]. fold Y.
        
        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iLeft. iLeft.
        iExists _. do 2 (iSplit; try (iPureIntro; done)).
        iModIntro.
        iApply rel_value.
        rel_pures_l; [set_solver|].
        rel_pures_r; [set_solver|].
    
        (* Recv alice (either none or some) *)
        iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iRight. iLeft.
        do 2 (iSplit; try (iPureIntro; done)). iModIntro.
        iSplit; last first.

        (* Recv alice = None *)
        + iApply rel_value.
          rel_pures_l. rel_pures_r.
          iDestruct ("HQ" with "Hnone") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".

          (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]"). iApply "IH".

        (* Recv alice = Some a *)
        + iIntros (a1 a2). iApply rel_value.
          rel_pures_l. rel_pures_r.
          iApply (rel_na_inv _ _ alphaN ); [set_solver|].
          iFrame "Hinva". 
          iIntros "(>[(Hα & Hl2 & Hl2s & Hla) | #(Hα & Hl2 & Hl2s &Hla)] & Hclose)". 
          * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
            iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s". rel_pures_l.
            iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame; iDestruct "Hα" as (ms) "(%Hf' & Hα)"; apply map_eq_nil in Hf'; simplify_eq; done|].
            iDestruct ("HQ" with "Hnone") as "HQfill".
            iDestruct ("Hk" with "HQfill") as "Hfillrel".
            iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
            
            (* First call is done. Can call getKey1 or getKey2 again. *)
            iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".
            
          * iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
            iApply (rel_load_l with "Hl2"). iIntros "!> _".
            iApply (rel_load_r with "Hl2s"). iIntros "_". rel_pures_l.
            rel_pures_r.
            rel_exp_l. rel_pures_l.
            rewrite -expgM. rewrite -ssrnat.multE.
            rewrite -Nat.mul_comm.
            iDestruct ("HQ" with "Hsome") as "HQfill".
            iDestruct ("Hk" with "HQfill") as "Hfillrel".
            iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
       
        (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".

      - iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
        iApply (rel_bind [_;_] [_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
        iApply (rel_load_r with "Hl1s"). iIntros "_".
        iApply (rel_load_l with "Hlb"). iIntros "!> _". rel_pures_l. iModIntro.
        rel_pures_l. rel_exp_l. rel_pures_l; [set_solver|]. 
        rel_pures_r; [set_solver|].
        iApply (rel_load_l with "Hl1"). iIntros "!> _".
        rel_pures_l; [set_solver|].
        iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
        iApply rel_introduction'.
        iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
        iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
        iRight. iLeft.
        do 2 (iSplit; try (iPureIntro; done)). iModIntro.
        iSplit.
        2 : { iApply rel_value. rel_pures_l. rel_pures_r.
              iDestruct ("HQ" with "Hnone") as "HQfill".
              iDestruct ("Hk" with "HQfill") as "Hfillrel".
              iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
              iApply "IH". }
        iIntros (a1 a2).
        iApply rel_value. rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ alphaN ); [set_solver|].
        iFrame "Hinva". 
        iIntros "(>[(Hα & Hl2 & Hl2s & Hla) | #(Hα & Hl2 & Hl2s &Hla)] & Hclose)". 
      * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "Hl2s".
        iApply rel_na_close. iFrame. iSplitR "Hlb"; [iLeft; iFrame| ]. 
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "Hnone") as "HQnone".
        iDestruct ("Hk" with "HQnone") as "Hknone".
        iApply (rel_exhaustion [_;_] [_;_] with "[$]").
        iApply "IH".
      * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame "Hl2". iIntros "!> _".
        iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2s"). iIntros "_".
        iApply rel_na_close. iFrame. iSplitR "Hlb"; [iRight; iFrame "#"| ]. simpl.
        rel_pures_l. rel_pures_r.
        rel_exp_l. rel_pures_l.
        rewrite -expgM. rewrite -ssrnat.multE.
        rewrite -Nat.mul_comm.
        iDestruct ("HQ" with "Hsome") as "HQsome".
        iDestruct ("Hk" with "HQsome") as "Hksome".
        iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
        iApply "IH". }
Qed.




   Lemma F_AUTH_C_DH_real_DH_KE f1 f2 :
    (∀ s n, val_subst s n f1 = f1) →
           (∀ s n, val_subst s n f2 = f2) →
           REL f1 ≤ f2 <|T|> {{ (λ v1 v2, ⌜v1 = #()%V⌝ ∧ ⌜v2 = #()%V⌝) }} -∗
           REL F_AUTH channel1 (C getKey1 channel1 DH_real f1) ≤ F_AUTH channel2 (DH_KE getKey2 channel2 f2)  <|Y|> {{ (λ v1 v2, ⌜ v1 = v2 ⌝) }}.
  Proof using G.
    iIntros (Hf1closed Hf2closed) "Hff".
    iApply rel_alloc_r. iIntros (l1) "Hl1".
    iApply rel_alloc_r. iIntros (l2) "Hl2".
    iApply rel_alloctape_r. iIntros (α) "Hα". rel_pures_r.
    iApply rel_alloctape_r. iIntros (β) "Hβ". rel_pures_r.
    iApply rel_alloc_r. iIntros (la) "Hla".
    iApply rel_alloc_r. iIntros (lb) "Hlb".
    iApply rel_alloc_l. iIntros (l1') "!> Hl1'".
    iApply rel_alloc_l. iIntros (l2') "!> Hl2'".
    rel_pures_l. 
    do 4 rewrite Hf2closed.
    iApply rel_couple_UT. iFrame "Hα". simpl. iIntros (a) "!> %Hlt Hα".
    iApply rel_couple_UT. iFrame "Hβ". simpl. iIntros (b) "!> %_ Hβ".

    rel_pures_l. rewrite -Nat2Z.inj_mul.
    do 3 rel_exp_l.
    rel_pures_l.
    do 5 rewrite Hf1closed.
    rel_pures_r. do 2 rewrite Hf2closed.

    iApply (rel_na_alloc
              ((β ↪ₛ (n; [b]) ∗ l2 ↦ₛ NONEV ∗ l2' ↦ NONEV ∗ lb ↦ₛ NONEV)
               ∨ (β ↪ₛ□ (n; [])
                  ∗ l2 ↦ₛ□ SOMEV (g ^+ b)%g
                  ∗ l2' ↦□ SOMEV (g ^+ b)%g
                  ∗ lb ↦ₛ□ SOMEV #b))%I
              betaN).
    iSplitL "Hl2 Hl2' Hβ Hlb"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinvb".

    iApply (rel_na_alloc
              ((α ↪ₛ (n; [a]) ∗ l1 ↦ₛ NONEV ∗ l1' ↦ NONEV ∗ la ↦ₛ NONEV)
               ∨ (α ↪ₛ□ (n; [])
                  ∗ l1 ↦ₛ□ SOMEV (g ^+ a)%g
                  ∗ l1' ↦□ SOMEV (g ^+ a)%g
                  ∗ la ↦ₛ□ SOMEV #a))%I
              alphaN).
    iSplitL "Hα Hl1 Hl1' Hla"; [iNext; iFrame; iLeft; iFrame|].
    iIntros "#Hinva".
    
    iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
    iLöb as "IH".
    
    iSplit; [iIntros (v1 v2) "(-> & ->)"; rel_pures_l; by rel_pures_r|].
    iIntros (e1 e2 ?)
      "[%e1' [%e2' [%k1 [%k2 [%S
        (-> & %Hk1 & -> & %Hk2 & [(-> & -> & (#Hnone & #Hsome)) | (-> & -> & (#Hnone & #Hsome))] & #HQ)
       ]]]]] #Hk".
    
    (* getKey1 first time *)
    1 : {
    do 2 rel_pures_r; [apply Hk2; set_solver|]. 
    do 2rel_pures_l; [split;[apply Hk1; set_solver|set_solver]|].
    iApply (rel_na_inv _ _ alphaN ); [set_solver|].
    iFrame "Hinva". 
    iIntros "(>[(Hα & Hl1 & Hl1' & Hla) | #(Hα & Hl1 & Hl1' &Hla)] & Hclose)".
    - iApply (rel_load_r_with_mask _ _ _ _ [HandleCtx _ _ _ ; AppRCtx _; CaseCtx _ _] with "Hla").
      iIntros "Hla". rel_pures_r.
      iAssert (α ↪ₛN (n; [fin_to_nat a]))%I with "[Hα]" as "Hα".
      { iExists [a]. simpl. iFrame. done. }
      iApply (rel_rand_r [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hα").
      iIntros "Hα ?". rel_pures_r.
      iApply (rel_store_r _ _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hla"). iIntros "Hla".
      rel_pures_r.
      iApply (rel_exp_r _ [HandleCtx _ _ _; AppRCtx _]).
      rel_pures_r; [set_solver|]. 
      iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1"). iIntros "Hl1".
      iApply (rel_load_l_mask [CaseCtx _ _]). iFrame. iIntros "!> Hl1'".
      rel_pures_l. rel_pures_r.
      iApply (rel_store_r _ _ _ _ [AppRCtx _] with "Hl1"). iIntros "Hl1".
      iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1'"). iIntros "!>Hl1'".
      rel_pures_l.
      rel_pures_r.
    
      (* Send gA first time *)
      iApply (rel_bind_mask _ [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|iApply iThy_le_refl| ].
      iApply fupd_rel.
      iMod (ghost_map_elem_persist with "Hl1'") as "#Hl1'".
      iMod (ghost_map_elem_persist with "Hl1") as "#Hl1".
      iMod (ghost_map_elem_persist with "Hla") as "#Hla".
      iDestruct "Hα" as (ns) "(%Hf & Hα)". apply map_eq_nil in Hf. simplify_eq.
      iMod (ghost_map_elem_persist with "Hα") as "#Hα".
      iModIntro.
      iApply rel_na_close. iFrame.
      iSplitL; [iRight; iFrame "#"|].
      
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iLeft. iRight.
      iExists _. do 2 (iSplit; try (iPureIntro; done)).
      iModIntro.
      iApply rel_value.
      rel_pures_l; [set_solver|]. 
      rel_pures_r; [set_solver|]. 
      
      (* Recv bob first time (either none or some) *)
      iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iRight. iRight.
      do 2 (iSplit; try (iPureIntro; done)). iModIntro.
      iSplit; last first.

    (* Recv bob = None *)
      + iApply rel_value.
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "Hnone") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".

        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]"). iApply "IH".

      + iIntros (b1 b2). iApply rel_value.
        rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ betaN ); [set_solver|].
        iFrame "Hinvb". 
        iIntros "(>[(Hβ & Hl2 & Hl2' & Hlb) | #(Hβ & Hl2 & Hl2' &Hlb)] & Hclose)". 
        * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2'".
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2". rel_pures_l.
          iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame; iDestruct "Hβ" as (ms) "(%Hf' & Hβ)"; apply map_eq_nil in Hf'; simplify_eq; done|].
          iDestruct ("HQ" with "Hnone") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
          
          (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".

        * iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
          iApply (rel_load_l with "Hl2'"). iIntros "!> _".
          iApply (rel_load_r with "Hl2"). iIntros "_". rel_pures_l.
          rel_pures_r. rel_exp_r. rel_pures_r.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
          
          (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".

    - iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
      iApply (rel_bind [_] [_;_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
      iApply (rel_load_r with "Hla"). iIntros "_".
      iApply (rel_load_l with "Hl1'"). iIntros "!> _".
      rel_pures_r. iModIntro. rel_pures_r. rel_exp_r.
      rel_pures_l; [set_solver|].
      rel_pures_r; [set_solver|].
      iApply (rel_load_r with "Hl1"). iIntros "_".
      rel_pures_r; [set_solver|]. 

      iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iRight. iRight.
      do 2 (iSplit; try (iPureIntro; done)). iModIntro.
      iSplit.
      2 : { iApply rel_value. rel_pures_l. rel_pures_r.
            iDestruct ("HQ" with "Hnone") as "HQfill".
            iDestruct ("Hk" with "HQfill") as "Hfillrel".
            iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
            iApply "IH". }
      iIntros (b1' b2').
      iApply rel_value. rel_pures_l. rel_pures_r.
      iApply (rel_na_inv _ _ betaN ); [set_solver|].
      iFrame "Hinvb". 
      iIntros "(>[(Hβ & Hl2 & Hl2s & Hlb) | (Hβ & Hl2 & Hl2s &Hlb)] & Hclose)". 
      -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2s".
         iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2".
         iApply rel_na_close. iFrame. iSplitR "Hla"; [iLeft; iFrame| ]. 
         rel_pures_l. rel_pures_r.
         iDestruct ("HQ" with "Hnone") as "HQnone".
         iDestruct ("Hk" with "HQnone") as "Hknone".
         iApply (rel_exhaustion [_;_] [_;_] with "[$]").
         iApply "IH".
      -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2s".
         iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2".
         iApply rel_na_close. iFrame. iSplitR "Hla"; [iRight; iFrame| ]. simpl.
         rel_pures_l. rel_pures_r.
         rel_exp_r. rel_pures_r.
         rewrite -expgM. rewrite -ssrnat.multE.
         rewrite -Nat.mul_comm.
         iDestruct ("HQ" with "Hsome") as "HQsome".
         iDestruct ("Hk" with "HQsome") as "Hksome".
         iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
         iApply "IH". }

     (* getKey2 *)
    1 : {
    do 2 rel_pures_r; [apply Hk2; set_solver|]. 
    do 2rel_pures_l; [split;[apply Hk1; set_solver|set_solver]|].
    iApply (rel_na_inv _ _ betaN ); [set_solver|].
    iFrame "Hinvb". 
    iIntros "(>[(Hβ & Hl1 & Hl1' & Hlb) | #(Hβ & Hl1 & Hl1' &Hlb)] & Hclose)".
    - iApply (rel_load_r_with_mask _ _ _ _ [HandleCtx _ _ _ ; AppRCtx _; CaseCtx _ _] with "Hlb").
      iIntros "Hlb". rel_pures_r.
      iAssert (β ↪ₛN (n; [fin_to_nat b]))%I with "[Hβ]" as "Hβ".
      { iExists [b]. simpl. iFrame. done. }
      iApply (rel_rand_r [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hβ").
      iIntros "Hβ ?". rel_pures_r.
      iApply (rel_store_r _ _ _ _ [HandleCtx _ _ _; AppRCtx _; AppRCtx _] with "Hlb"). iIntros "Hlb".
      rel_pures_r.
      iApply (rel_exp_r _ [HandleCtx _ _ _; AppRCtx _]).
      rel_pures_r; [set_solver|]. 
      iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl1"). iIntros "Hl1".
      iApply (rel_load_l_mask [CaseCtx _ _]). iFrame. iIntros "!> Hl1'".
      rel_pures_l. rel_pures_r.
      iApply (rel_store_r _ _ _ _ [AppRCtx _] with "Hl1"). iIntros "Hl1".
      iApply (rel_store_l _ _ _ [AppRCtx _] with "Hl1'"). iIntros "!>Hl1'".
      rel_pures_l.
      rel_pures_r.
    
      (* Send gB first time *)
      iApply (rel_bind_mask _ [AppRCtx _] [AppRCtx _]); [by iApply traversable_iThyTraverse|iApply iThy_le_refl| ].
      iApply fupd_rel.
      iMod (ghost_map_elem_persist with "Hl1'") as "#Hl1'".
      iMod (ghost_map_elem_persist with "Hl1") as "#Hl1".
      iMod (ghost_map_elem_persist with "Hlb") as "#Hlb".
      iDestruct "Hβ" as (ns) "(%Hf & Hβ)". apply map_eq_nil in Hf. simplify_eq.
      iMod (ghost_map_elem_persist with "Hβ") as "#Hβ".
      iModIntro.
      iApply rel_na_close. iFrame.
      iSplitL; [iRight; iFrame "#"|].
      
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iLeft. iLeft.
      iExists _. do 2 (iSplit; try (iPureIntro; done)).
      iModIntro.
      iApply rel_value.
      rel_pures_l; [set_solver|]. 
      rel_pures_r; [set_solver|]. 
      
      (* Recv alice (either none or some) *)
      iApply (rel_bind' [_] [_]); [by iApply traversable_iThyTraverse|].
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iRight. iLeft.
      do 2 (iSplit; try (iPureIntro; done)). iModIntro.
      iSplit; last first.

    (* Recv alice = None *)
      + iApply rel_value.
        rel_pures_l. rel_pures_r.
        iDestruct ("HQ" with "Hnone") as "HQfill".
        iDestruct ("Hk" with "HQfill") as "Hfillrel".
        iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".

        (* First call is done. Can call getKey1 or getKey2 again. *)
        iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]"). iApply "IH".

      + iIntros (b1 b2). iApply rel_value.
        rel_pures_l. rel_pures_r.
        iApply (rel_na_inv _ _ alphaN ); [set_solver|].
        iFrame "Hinva". 
        iIntros "(>[(Hα & Hl2 & Hl2' & Hla) | #(Hα & Hl2 & Hl2' &Hla)] & Hclose)". 
        * iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2'".
          iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2". rel_pures_l.
          iApply rel_na_close. iFrame. iSplitL; [iLeft; iFrame; iDestruct "Hα" as (ms) "(%Hf' & Hα)"; apply map_eq_nil in Hf'; simplify_eq; done|].
          iDestruct ("HQ" with "Hnone") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
          
          (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".

        * iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
          iApply (rel_load_l with "Hl2'"). iIntros "!> _".
          iApply (rel_load_r with "Hl2"). iIntros "_". rel_pures_l.
          rel_pures_r. rel_exp_r. rel_pures_r.
          rewrite -expgM. rewrite -ssrnat.multE.
          rewrite -Nat.mul_comm.
          iDestruct ("HQ" with "Hsome") as "HQfill".
          iDestruct ("Hk" with "HQfill") as "Hfillrel".
          iClear (Hk1 Hk2) "Hnone Hsome HQ Hk HQfill".
          
          (* First call is done. Can call getKey1 or getKey2 again. *)
          iApply (rel_exhaustion_mask _ [_;_] [_;_] _ _ with "[$]"). iApply "IH".

    - iApply rel_na_close. iFrame. iSplitL; [iRight; iFrame "#"|].
      iApply (rel_bind [_] [_;_] _ _ iThyBot); [iApply traversable_bot|iApply iThy_le_bot|].
      iApply (rel_load_r with "Hlb"). iIntros "_".
      iApply (rel_load_l with "Hl1'"). iIntros "!> _".
      rel_pures_r. iModIntro. rel_pures_r. rel_exp_r.
      rel_pures_l; [set_solver|].
      rel_pures_r; [set_solver|].
      iApply (rel_load_r with "Hl1"). iIntros "_".
      rel_pures_r; [set_solver|]. 

      iApply (rel_bind' [_] [_]); [iApply traversable_iThyTraverse|].
      iApply rel_introduction'.
      iExists _, _, [], [], _. do 2 (iSplit; [done|]; iSplit; [iPureIntro; apply _|]).
      iSplitL; [|by iIntros "!>" (??) "H"; iApply "H"].
      iRight. iLeft.
      do 2 (iSplit; try (iPureIntro; done)). iModIntro.
      iSplit.
      2 : { iApply rel_value. rel_pures_l. rel_pures_r.
            iDestruct ("HQ" with "Hnone") as "HQfill".
            iDestruct ("Hk" with "HQfill") as "Hfillrel".
            iApply (rel_exhaustion [_;_] [_;_] _ _ with "[$]").
            iApply "IH". }
      iIntros (b1' b2').
      iApply rel_value. rel_pures_l. rel_pures_r.
      iApply (rel_na_inv _ _ alphaN ); [set_solver|].
      iFrame "Hinva". 
      iIntros "(>[(Hα & Hl2 & Hl2s & Hla) | (Hα & Hl2 & Hl2s &Hla)] & Hclose)". 
      -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2s".
         iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2".
         iApply rel_na_close. iFrame. iSplitR "Hlb"; [iLeft; iFrame| ]. 
         rel_pures_l. rel_pures_r.
         iDestruct ("HQ" with "Hnone") as "HQnone".
         iDestruct ("Hk" with "HQnone") as "Hknone".
         iApply (rel_exhaustion [_;_] [_;_] with "[$]").
         iApply "IH".
      -- iApply (rel_load_l_mask [CaseCtx _ _ ]). iFrame. iIntros "!> Hl2s".
         iApply (rel_load_r_with_mask _ _ _ _ [CaseCtx _ _] with "Hl2"). iIntros "Hl2".
         iApply rel_na_close. iFrame. iSplitR "Hlb"; [iRight; iFrame| ]. simpl.
         rel_pures_l. rel_pures_r.
         rel_exp_r. rel_pures_r.
         rewrite -expgM. rewrite -ssrnat.multE.
         rewrite -Nat.mul_comm.
         iDestruct ("HQ" with "Hsome") as "HQsome".
         iDestruct ("Hk" with "HQsome") as "Hksome".
         iApply (rel_exhaustion [_;_] [_;_] with "[$Hksome]").
         iApply "IH". }
  Qed.
       
  
End handlee_verification.
