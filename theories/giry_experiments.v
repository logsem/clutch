(** Measures and probabilitiy from mathcomp-analysis *)

Require Import Rdefinitions Raxioms RIneq Rbasic_fun Zwf.
Require Import Epsilon FunctionalExtensionality Ranalysis1 Rsqrt_def.
Require Import Rtrigo1 Reals.
From mathcomp Require Import all_ssreflect ssralg poly mxpoly ssrnum.
From mathcomp Require Import all_ssreflect ssralg ssrnum matrix interval.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import all_ssreflect ssralg ssrnum finmap.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import cardinality fsbigop.
From mathcomp Require Import all_ssreflect ssralg ssrnum ssrint interval finmap.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import cardinality fsbigop .
From mathcomp Require Import all_ssreflect all_algebra finmap.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import fsbigop cardinality set_interval.
From mathcomp Require Import all_ssreflect.
From mathcomp Require Import ssralg poly ssrnum ssrint interval finmap.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import cardinality.
From mathcomp Require Import boolp classical_sets functions.
From HB Require Import structures.

From mathcomp.analysis Require Import constructive_ereal ereal reals landau Rstruct topology function_spaces cantor.
From mathcomp.analysis Require Import prodnormedzmodule normedtype realfun sequences exp trigo nsatz_realtype esum.
From mathcomp.analysis Require Import real_interval lebesgue_measure lebesgue_stieltjes_measure forms derive measure numfun lebesgue_integral.
From mathcomp.analysis Require Import ftc hoelder probability summability signed itv convex charge kernel.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.


(** Johanes Hotzel already tried to define the Giry monad, though therey's no too much there *)

Section stolen_giry_monad_attempt.

(* Stolen https://github.com/math-comp/analysis/pull/1177/commits/32261c68d93041da910fd2fe2afd810c7a783ff8 *)
Context d (T : measurableType d) {R : realType} (y : T). (* y is unused... *)
Definition ret (x : T) (A : set T) := @dirac d T x R A.
Definition bind (mu : probability T R) (f : T -> probability T R) :=
  fun (A : set T) => (\int[mu]_x f x A)%E.

Lemma bindT mu f : bind mu f setT = 1%E.
Proof.
rewrite /bind.
under eq_integral => x _ do rewrite probability_setT.
Admitted.

Fail HB.instance Definition _ mu f :=
  Measure_isProbability.Build _ _ _ (bind mu f) (bindT mu f).

Lemma giry_left_id (mu : probability T R) (f : T -> probability T R) (x : T) : bind (ret x) f = f x.
Proof.
rewrite /bind/ret/=.
Admitted.
Lemma giry_right_id (mu : probability T R) A: bind mu (fun x => ret x) A = mu A.
Proof.
rewrite /bind/ret/=.
Admitted.
(* Lemma giry_assoc (mu : probability T R) f g A : bind (bind mu f) g = bind mu (fun x => bind (f x) g).
Admitted. *)

End stolen_giry_monad_attempt.




(** This is from mathcomp-analysis, where they define a generated sigma algebra from interval  *)

Section rgenopens.
Variable R : realType.
Implicit Types x y z : R.

Local Open Scope classical_set_scope.
Local Open Scope ring_scope.


Definition G := [set A | exists x y, A = `]x, y[%classic].

(* Local Lemma measurable_itvoo x y : G.-sigma.-measurable `]x, y[%classic. *)
(* Proof. by apply sub_sigma_algebra; eexists; eexists; reflexivity. Qed. *)

End rgenopens.





(** My Giry attempt *)

Section giry.

  Context d (T : measurableType d) (R : realType). (* d is the display paramter *)
  Local Open Scope classical_set_scope.

  (** 1. The measure space on measures on T is generated by the
         preimage of evaluation functions on the measurable sets of T *)

  (* Maybe good example for defininng comap:
      preimage_classes
      sigma algebra generated by the preimages of f1 and f2
   *)

  Check preimage_classes.

  (* This lets us generate sigma algebras *)
  HB.about salgebraType.
  Check (salgebraType (preimage_class _ _ _)).

  (* Lemma that says the preimage_class is a sigma algebra... *)
  Check sigma_algebra_preimage_class.

  (* We need to generate a sigma algebra from _all evaluation maps_ out of T
     ie << A âˆˆ measurable T | preimage classes of ((ðœ† ðœ‡ : ðœ‡ A) : (measure T -> Borel (extended R))) >>  *)

  (* Borel sigma algebra on extended reals is not defined *)
  (*    One subbasis:       { (-âˆž, a] | a âˆˆ R } âˆª { -âˆž } *)
  (*                         --------------------   ------
                             lift of real sets      single ereal value

       Doing it this way avoids annoying ereal intervals
  *)
  (* A different option?   { [-âˆž, a] | a âˆˆ R }
       As long as the intervals include the actual value -âˆž we could get {-âˆž} by
       a countable intersection, get the last subbasis by a difference. Good enough?
   *)

  Check fun x : \bar R => [set` Interval (BSide false x) +oo%O].
  Check fun x : \bar R => [set` Interval -oo%O (BLeft x)].
  Check fun x : \bar R => [set` Interval (BInfty (extended R) true) (BLeft x)].
  (* I'm not sure if this actually contains -âˆž? The flag in BInfty determines
     +âˆž vs -âˆž, unlike for BSide which determines [ or ]. So I assume it's excluded? *)

  (* A third option, it turns out there _is_ a topology on ereal! *)
  Check ereal_nbhs.
  Print ereal_nbhs.
  (* This set system corresponds to the family (x-ð›¿, x+ð›¿), or (ð›¿, âˆž), or (-âˆž, ð›¿)
     We want the "union" (not really, since no uncountable unions) for all x âˆˆ \bar R. *)

  Definition ereal_borel_subbase : set (set \bar R) := [set N | exists x, ereal_nbhs x N].

  Definition ereal_borel_sets := (smallest (sigma_algebra [set: \bar R]) ereal_borel_subbase).

  Definition borel_sigma_algebra : sigma_algebra [set: \bar R] ereal_borel_sets
    := smallest_sigma_algebra [set: \bar R] ereal_borel_subbase.




  (** 2. Define the type (actually, the _set_) of measures on T? *)

  Definition measure_T_type : Type := @measure d T R.

  Definition measures_on_T : set (measure T R) := [set: measure_T_type].


  (** 3. Define the preimage (pullback? coindiced?) sigma algebra from "evaluation functions" *)

  Definition preimage_class_of_measures (S : set T) : set (set (measure_T_type)) :=
          @preimage_class
            measure_T_type            (* Domain type *)
            (\bar R)                  (* Range type *)
            measures_on_T             (* Domain set *)
            (fun ðœ‡ => ðœ‡ S)              (* Evaluation function *)      (* ????????? !!!!!!!!! *)
            ereal_borel_sets          (* Range sets*).


    (* This is highly confusing. Why am I allowed to give the measure an arbitrary set? *)
    (* What does this application actually do???? *)
    Check fun u : measure_T_type => fun S : set T => u _.

    (* OK... looks like they make you define a "measure" on every subset, but only prove
       the measure axioms for measurable sets. Fine. *)

  (* Define the infinite union of these classes across all measurable sets in T *)
    Definition giry_subbase : set (set (measure_T_type))
      := [set C | exists (S : set T) (_ : measurable S), preimage_class_of_measures S C].



  (* Giry sigma algebra: Genreated by all preimage classes: *)

  Definition giry_measurable_sets := (smallest (sigma_algebra measures_on_T) giry_subbase).

  Definition giry_sigma_algebra : sigma_algebra measures_on_T giry_measurable_sets
    := smallest_sigma_algebra measures_on_T giry_subbase.




End giry.












(* Things we probably care about:


    - isSubProbability
        subdistributions

 *)



(* Dirac measure *)

HB.about dirac.

Check (semi_sigma_additive _).
Check (dirac _).

HB.about Measurable.sort.

(* Measure.v contains the pufhforward measure (is that what we want? or is it pullback?) *)


(* Measureable functions *)

Check measurable_fun.

(* Only depends on sigma algebra, not on measure *)
(* comap: maybe in measure.v? *)

HB.about MeasurableFun.


(* Real numbers *)
HB.about realType.

(* Extended real numbers *)
Print extended.

Check ereal_sup.
Check supremum.
Search eseries.

(* Measure *)
HB.about semiRingOfSetsType.
HB.about measurableI.  (* It seems like the isMeasurable factory is what I want to use, since I'm not defining it by CET *)
HB.about isMeasurable.
(* Something about HB.Builders ... what does that do? *)


(* Generated sigma algebra: Actually this is what I want to implement comap, comap is generated *)

Search smallest.

HB.about isMeasurable.Build.

(* HB.instance Definition _ := isMeasurable.Build _ _. *)

HB.about salgebraType. (* Generated sigma algebra? *)
