(** Measures and probabilitiy from mathcomp-analysis *)

Require Import Rdefinitions Raxioms RIneq Rbasic_fun Zwf.
Require Import Epsilon FunctionalExtensionality Ranalysis1 Rsqrt_def.
Require Import Rtrigo1 Reals.
From mathcomp Require Import all_ssreflect ssralg poly mxpoly ssrnum.
From mathcomp Require Import all_ssreflect ssralg ssrnum matrix interval.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import all_ssreflect ssralg ssrnum finmap.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import cardinality fsbigop.
From mathcomp Require Import all_ssreflect ssralg ssrnum ssrint interval finmap.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import cardinality fsbigop .
From mathcomp Require Import all_ssreflect all_algebra finmap.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import fsbigop cardinality set_interval.
From mathcomp Require Import all_ssreflect.
From mathcomp Require Import ssralg poly ssrnum ssrint interval finmap.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import cardinality.
From mathcomp Require Import boolp classical_sets functions.
From HB Require Import structures.

From mathcomp.analysis Require Import constructive_ereal ereal reals landau Rstruct topology function_spaces cantor.
From mathcomp.analysis Require Import prodnormedzmodule normedtype realfun sequences exp trigo nsatz_realtype esum.
From mathcomp.analysis Require Import real_interval lebesgue_measure lebesgue_stieltjes_measure forms derive measure numfun lebesgue_integral.
From mathcomp.analysis Require Import ftc hoelder probability summability signed itv convex charge kernel.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.


(** Johanes Hotzel already tried to define the Giry monad, though therey's no too much there *)

Section stolen_giry_monad_attempt.

(* Stolen https://github.com/math-comp/analysis/pull/1177/commits/32261c68d93041da910fd2fe2afd810c7a783ff8 *)
Context d (T : measurableType d) {R : realType} (y : T). (* y is unused... *)
Definition ret (x : T) (A : set T) := @dirac d T x R A.
Definition bind (mu : probability T R) (f : T -> probability T R) :=
  fun (A : set T) => (\int[mu]_x f x A)%E.

Lemma bindT mu f : bind mu f setT = 1%E.
Proof.
rewrite /bind.
under eq_integral => x _ do rewrite probability_setT.
Admitted.

Fail HB.instance Definition _ mu f :=
  Measure_isProbability.Build _ _ _ (bind mu f) (bindT mu f).

Lemma giry_left_id (mu : probability T R) (f : T -> probability T R) (x : T) : bind (ret x) f = f x.
Proof.
rewrite /bind/ret/=.
Admitted.
Lemma giry_right_id (mu : probability T R) A: bind mu (fun x => ret x) A = mu A.
Proof.
rewrite /bind/ret/=.
Admitted.
(* Lemma giry_assoc (mu : probability T R) f g A : bind (bind mu f) g = bind mu (fun x => bind (f x) g).
Admitted. *)

End stolen_giry_monad_attempt.




(** This is from mathcomp-analysis, where they define a generated sigma algebra from interval  *)

Section rgenopens.
Variable R : realType.
Implicit Types x y z : R.

Local Open Scope classical_set_scope.
Local Open Scope ring_scope.


Definition G := [set A | exists x y, A = `]x, y[%classic].

(* Local Lemma measurable_itvoo x y : G.-sigma.-measurable `]x, y[%classic. *)
(* Proof. by apply sub_sigma_algebra; eexists; eexists; reflexivity. Qed. *)

End rgenopens.







(** My Giry attempt *)

Section giry.

  Context d (T : measurableType d) (R : realType). (* d is the display paramter *)
  Local Open Scope classical_set_scope.

  (** 1. The measure space on measures on T is generated by the
         preimage of evaluation functions on the measurable sets of T *)

  (* Maybe good example for defininng comap:
      preimage_classes
      sigma algebra generated by the preimages of f1 and f2
   *)

  Check preimage_classes.

  (* This lets us generate sigma algebras *)
  HB.about salgebraType.
  Check (salgebraType (preimage_class _ _ _)).

  (* Lemma that says the preimage_class is a sigma algebra... *)
  Check sigma_algebra_preimage_class.

  (* We need to generate a sigma algebra from _all evaluation maps_ out of T
     ie << A ‚àà measurable T | preimage classes of ((ùúÜ ùúá : ùúá A) : (measure T -> Borel (extended R))) >>  *)

  (* Borel sigma algebra on extended reals is not defined *)
  (*    One subbasis:       { (-‚àû, a] | a ‚àà R } ‚à™ { -‚àû } *)
  (*                         --------------------   ------
                             lift of real sets      single ereal value

       Doing it this way avoids annoying ereal intervals
  *)
  (* A different option?   { [-‚àû, a] | a ‚àà R }
       As long as the intervals include the actual value -‚àû we could get {-‚àû} by
       a countable intersection, get the last subbasis by a difference. Good enough?
   *)

  Check fun x : \bar R => [set` Interval (BSide false x) +oo%O].
  Check fun x : \bar R => [set` Interval -oo%O (BLeft x)].
  Check fun x : \bar R => [set` Interval (BInfty (extended R) true) (BLeft x)].
  (* I'm not sure if this actually contains -‚àû? The flag in BInfty determines
     +‚àû vs -‚àû, unlike for BSide which determines [ or ]. So I assume it's excluded? *)

  (* A third option, it turns out there _is_ a topology on ereal! *)
  Check ereal_nbhs.
  Print ereal_nbhs.

  Search (\bar R).

  (* This set system corresponds to the family (x-ùõø, x+ùõø), or (ùõø, ‚àû), or (-‚àû, ùõø)
     We want the "union" (not really, since no uncountable unions) for all x ‚àà \bar R. *)

  Definition ereal_borel_subbase : set (set \bar R) := [set N | exists x, ereal_nbhs x N].

  Definition ereal_borel_sets := (smallest (sigma_algebra [set: \bar R]) ereal_borel_subbase).

  Definition borel_sigma_algebra : sigma_algebra [set: \bar R] ereal_borel_sets
    := smallest_sigma_algebra [set: \bar R] ereal_borel_subbase.

  (* Err... there is already a measurable type?
     This is a function (set (set R)) -> (set (set \bar R)), use this to lift? Are we already using it to lift? *)
  Check emeasurable.


  (** 2. Define the type (actually, the _set_) of measures on T? *)

  HB.instance Definition _ := @isPointed.Build (@measure d T R) mzero.


  Check setT.

  (*

  Definition zero_T_measure : measure_T_type := @mzero d T R.

  (** 3. Define the preimage (pullback? coindiced?) sigma algebra from "evaluation functions" *)

  Definition preimage_class_of_measures (S : set T) : set (set (measure_T_type)) :=
          @preimage_class
            measure_T_type            (* Domain type *)
            (\bar R)                  (* Range type *)
            measures_on_T             (* Domain set *)
            (fun ùúá => ùúá S)              (* Evaluation function *)      (* ????????? !!!!!!!!! *)
            ereal_borel_sets          (* Range sets*).

  (* Define the infinite union of these classes across all measurable sets in T *)
    Definition giry_subbase : set (set (measure_T_type))
      := [set C | exists (S : set T) (_ : measurable S), preimage_class_of_measures S C].

  Check (@measurable_g_measurableTypeE _).

    
  Check measurable (set0 : set measures_on_T).




    
  (* Giry sigma algebra: Genreated by all preimage classes: *)

  Definition giry_measurable_sets := <<s giry_subbase>>.
  Check giry_measurable_sets .

  (*
  Check (giry_subbase.-sigma).-measurable. *)

  Unset Printing Notations.
  Check (salgebraType giry_subbase).    (* Type *)



  (* What is generated from Measure? Can we try applying it to either G or the salgebraType G*)
  (* The things we care about most probably come from the isMeasurable factory *)
  HB.about measurableType.
  Check @measurable.
  Check @bigcupT_measurable.
  Fail Check @measurable_bigcup.  (* isMeasurable factory field, but nowhere in the real hierarachy *)
  Check @isMeasurable.measurable_bigcup. (* Synthesized *)
  Check @measurable0.
  Check @measurableC. (* Directly declared lemma *)
  Check @isMeasurable.measurableC. (* Synthesized function from isMeasurable *)

  Locate measurable.


  (* EXAMPLE: Can we prove that the empty set is measurable? *)
  Check (measurable_g_measurableTypeE). (* G.-sigma.-measurability is the same as G *)


  (* We can build a measure without plugging it into HB.instnace. Let's do that first. *)
  (* Err.. actually we want the opposite. We want to declare a measurable instance for measure_T_type
     without actually doing any work (getting everything from the generated algebra) *)


  Definition giry_display {T1 : Type} : measure_display.
  Proof. exact. Qed.

  (* OKAY! It's complaining now. I think it wants me to make this type pointed.
     Let's do that, and then hope it changes *)

  HB.about Pointed.
  HB.about isPointed.Build.





(*
    Error:
    Definition illtyped: In environment
    d : measure_display
    T : Measurable.type d
    R : Real.type
    The term "id_phant" has type
    "forall _ : phantom Type (salgebraType giry_subbase),
    phantom Type (salgebraType giry_subbase)" while it is expected to have type
    "structures.unify Type Type (salgebraType giry_subbase) ?t
    (is_not_canonically_a Pointed.type)". *)

  (* Check (@isMeasurable.Build _ (salgebraType giry_subbase) _ _ _ _).
       (giry_display)
       (salgebraType giry_subbase)
       <<s giry_subbase>>
       (@sigma_algebra0 _ setT giry_subbase)
       (@sigma_algebraC)
       (@sigma_algebra_bigcup _ setT giry_subbase)). *)



  HB.instance Definition _ := @isPointed.Build (salgebraType giry_subbase) mzero.

  Search salgebraType.


  Definition gsm (X : set (set measure_T_type)) := (measurable : set (set (salgebraType X))).


  Check @gsm.

  (* HB.instance Definition _ :=
    (@isMeasurable.Build
       (giry_display)
       (salgebraType giry_subbase)
       <<s giry_subbase>>
       (@sigma_algebra0 _ setT giry_subbase)
       (@sigma_algebraC)
       (@sigma_algebra_bigcup _ setT giry_subbase)). *)

  (* EXAMPLE: *)

  (* We need a measurableType on measure_T_type for this! *)
  Print SemiRingOfSets.type.


  Check @measure.measurable (sigma_display giry_subbase) _ set0.


  Definition zms : set (measure_T_type) := set0.


  Fail Check measure.measurable zms.

  (* I need a canonical SemiRingOfSets instance for the giry space *)

  Check measure.measurable (set0 : set _).

  Search SemiRingOfSets.type salgebraType.

  (* SemiRingOfSets.type (sigma_display giry_subbase) *)

  Check measure.


  (* Lemma giry_set0_measurable : (giry_subbase.-sigma).-measurable set0. *)



*)




End giry.















Section simple.
  (* Formalize some simple constructions for measures, measurable functions. *)

  (* Formalize the trivial sigma algebra on a subspace of the set of all elements of a type *)

  Definition MyTrivAlgebraType {T} (Sp : set T) := T.

  Definition MyTrivDisplay {T} : (set T) -> measure_display.
  Proof. exact. Qed.

  Section MyTrivAlgebraInstance.
    Variables (T : pointedType) (Sp : set T).

    Set Default Proof Using "Type*".

    Fail HB.about MyTrivAlgebraType.
    Fail HB.about T.
    (* So this needs MyTrivAlgebraType to be a pointedType (makes sense) *)
    HB.instance Definition _ := Pointed.on (MyTrivAlgebraType Sp).
    HB.about MyTrivAlgebraType. (* Now it has choice, pointed, and equality *)

    Definition MyTrivAlgebraMeasurable : set (set T) := setU [set set0] [set Sp].

    Lemma MyTrivAlgebra0 : MyTrivAlgebraMeasurable set0.
    Proof. rewrite /MyTrivAlgebraMeasurable /=. by left. Qed.

    Lemma MyTrivAlgebraC : forall (A : set T),
      MyTrivAlgebraMeasurable A -> MyTrivAlgebraMeasurable (~` A)%classic.
    Proof.
      move=> A.
      case=>->.
      (* This is wrong! The compliments will take it over [set: T] not Sp.  *)
      (* I'm going to admit it for now, to see if this type is what the HierarchyBuilder
         wants. If so, I need to change the type, if not, I need to change the lemma. *)
    Admitted.

    Lemma MyTrivAlgebra_bigcup :
        forall F : sequence (set T),
        (forall i : nat, MyTrivAlgebraMeasurable (F i)) ->
        MyTrivAlgebraMeasurable (\bigcup_i F i)%classic.
    Proof.
      move=> F HF.
      Locate bigcup_measurable.
      (* Uhh... I should be able to do induction over this? How do they do it in mathcomp analysis *)
    Admitted.



    HB.about isMeasurable.Build.

    HB.instance Definition _ :=
      @isMeasurable.Build
        (MyTrivDisplay Sp)
        (MyTrivAlgebraType Sp)
        MyTrivAlgebraMeasurable
        MyTrivAlgebra0
        MyTrivAlgebraC
        MyTrivAlgebra_bigcup.

    (* Nice! *)


    HB.about isMeasurable.


  End MyTrivAlgebraInstance.




End simple.


















(* Things we probably care about:


    - isSubProbability
        subdistributions

 *)



(* Dirac measure *)

HB.about dirac.

Check (semi_sigma_additive _).
Check (dirac _).

HB.about Measurable.sort.

(* Measure.v contains the pufhforward measure (is that what we want? or is it pullback?) *)


(* Measureable functions *)

Check measurable_fun.

(* Only depends on sigma algebra, not on measure *)
(* comap: maybe in measure.v? *)

HB.about MeasurableFun.


(* Real numbers *)
HB.about realType.

(* Extended real numbers *)
Print extended.

Check ereal_sup.
Check supremum.
Search eseries.

(* Measure *)
HB.about semiRingOfSetsType.
HB.about measurableI.  (* It seems like the isMeasurable factory is what I want to use, since I'm not defining it by CET *)
HB.about isMeasurable.
(* Something about HB.Builders ... what does that do? *)


(* Generated sigma algebra: Actually this is what I want to implement comap, comap is generated *)

Search smallest.

HB.about isMeasurable.Build.

(* HB.instance Definition _ := isMeasurable.Build _ _. *)

HB.about salgebraType. (* Generated sigma algebra? *)
