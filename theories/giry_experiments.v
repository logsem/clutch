(** Measures and probabilitiy from mathcomp-analysis *)

Require Import Rdefinitions Raxioms RIneq Rbasic_fun Zwf.
Require Import Epsilon FunctionalExtensionality Ranalysis1 Rsqrt_def.
Require Import Rtrigo1 Reals.
From mathcomp Require Import all_ssreflect ssralg poly mxpoly ssrnum.
From mathcomp Require Import all_ssreflect ssralg ssrnum matrix interval.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import all_ssreflect ssralg ssrnum finmap.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import cardinality fsbigop.
From mathcomp Require Import all_ssreflect ssralg ssrnum ssrint interval finmap.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import cardinality fsbigop .
From mathcomp Require Import all_ssreflect all_algebra finmap.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import fsbigop cardinality set_interval.
From mathcomp Require Import all_ssreflect.
From mathcomp Require Import ssralg poly ssrnum ssrint interval finmap.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import cardinality.
From mathcomp Require Import boolp classical_sets functions.
From HB Require Import structures.

From mathcomp.analysis Require Import constructive_ereal ereal reals landau Rstruct topology function_spaces cantor.
From mathcomp.analysis Require Import prodnormedzmodule normedtype realfun sequences exp trigo nsatz_realtype esum.
From mathcomp.analysis Require Import real_interval lebesgue_measure lebesgue_stieltjes_measure forms derive measure numfun lebesgue_integral.
From mathcomp.analysis Require Import ftc hoelder probability summability signed itv convex charge kernel.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.


(** Johanes Hotzel already tried to define the Giry monad, though therey's no too much there *)

Section stolen_giry_monad_attempt.

(* Stolen https://github.com/math-comp/analysis/pull/1177/commits/32261c68d93041da910fd2fe2afd810c7a783ff8 *)
Context d (T : measurableType d) {R : realType} (y : T). (* y is unused... *)
Definition ret (x : T) (A : set T) := @dirac d T x R A.
Definition bind (mu : probability T R) (f : T -> probability T R) :=
  fun (A : set T) => (\int[mu]_x f x A)%E.

Lemma bindT mu f : bind mu f setT = 1%E.
Proof.
rewrite /bind.
under eq_integral => x _ do rewrite probability_setT.
Admitted.

Fail HB.instance Definition _ mu f :=
  Measure_isProbability.Build _ _ _ (bind mu f) (bindT mu f).

Lemma giry_left_id (mu : probability T R) (f : T -> probability T R) (x : T) : bind (ret x) f = f x.
Proof.
rewrite /bind/ret/=.
Admitted.
Lemma giry_right_id (mu : probability T R) A: bind mu (fun x => ret x) A = mu A.
Proof.
rewrite /bind/ret/=.
Admitted.
(* Lemma giry_assoc (mu : probability T R) f g A : bind (bind mu f) g = bind mu (fun x => bind (f x) g).
Admitted. *)

End stolen_giry_monad_attempt.




(** This is from mathcomp-analysis, where they define a generated sigma algebra from interval  *)

Section rgenopens.
Variable R : realType.
Implicit Types x y z : R.

Local Open Scope classical_set_scope.
Local Open Scope ring_scope.


Definition G := [set A | exists x y, A = `]x, y[%classic].

(* Local Lemma measurable_itvoo x y : G.-sigma.-measurable `]x, y[%classic. *)
(* Proof. by apply sub_sigma_algebra; eexists; eexists; reflexivity. Qed. *)

End rgenopens.





(** My Giry attempt *)

Section giry.

  Context d (T : measurableType d) (R : realType). (* d is the display paramter *)
  Local Open Scope classical_set_scope.

  (** 1. The measure space on measures on T is generated by the
         preimage of evaluation functions on the measurable sets of T *)

  (* Maybe good example for defininng comap:
      preimage_classes
      sigma algebra generated by the preimages of f1 and f2
   *)

  Check preimage_classes.

  (* This lets us generate sigma algebras *)
  HB.about salgebraType.
  Check (salgebraType (preimage_class _ _ _)).

  (* Lemma that says the preimage_class is a sigma algebra... *)
  Check sigma_algebra_preimage_class.

  (* We need to generate a sigma algebra from _all evaluation maps_ out of T
     ie << A âˆˆ measurable T | preimage classes of ((ğœ† ğœ‡ : ğœ‡ A) : (measure T -> Borel (extended R))) >>  *)

  (* Borel sigma algebra on extended reals is not defined *)
  (*    One subbasis:       { (-âˆ, a] | a âˆˆ R } âˆª { -âˆ } *)
  (*                         --------------------   ------
                             lift of real sets      single ereal value

       Doing it this way avoids annoying ereal intervals
  *)
  (* A different option?   { [-âˆ, a] | a âˆˆ R }
       As long as the intervals include the actual value -âˆ we could get {-âˆ} by
       a countable intersection, get the last subbasis by a difference. Good enough?
   *)

  Check fun x : \bar R => [set` Interval (BSide false x) +oo%O].
  Check fun x : \bar R => [set` Interval -oo%O (BLeft x)].
  Check fun x : \bar R => [set` Interval (BInfty (extended R) true) (BLeft x)].
  (* I'm not sure if this actually contains -âˆ? The flag in BInfty determines
     +âˆ vs -âˆ, unlike for BSide which determines [ or ]. So I assume it's excluded? *)

  (* There _is_ a topology on ereal *)
  Check ereal_nbhs.
  Print ereal_nbhs.
  (* This set system corresponds to the family (x-ğ›¿, x+ğ›¿), or (ğ›¿, âˆ), or (-âˆ, ğ›¿)
     We want the "union" (not really, since no uncountable unions) for all x âˆˆ \bar R. *)

  Definition ereal_borel_subbase : set (set \bar R) := [set N | exists x, ereal_nbhs x N].



  HB.about salgebraType.


  HB.about salgebraType.


  HB.about measurableType.
  (* bigcupT_measurable, and *)
  (* Measurable inherits from: *)
  HB.about SemiRingOfSets.
  (* measurable                     :  set (set T)*)
  (* semi_measurableD               := ??? *)
  (* measurableI                    := measurable is closed under setI (binary intersection) *)
  (* measurable0                    := set0 is measurable *)

  HB.about RingOfSets.
  (* measruableU                    := measurable is clsoed under setU (binary union) *)

  HB.about AlgebraOfSets.
  (* measruableT                    := ???*)


End giry.
(* Things we probably care about:


    - isSubProbability
        subdistributions

 *)



(* Dirac measure *)

HB.about dirac.

Check (semi_sigma_additive _).
Check (dirac _).

HB.about Measurable.sort.

(* Measure.v contains the pufhforward measure (is that what we want? or is it pullback?) *)


(* Measureable functions *)

Check measurable_fun.

(* Only depends on sigma algebra, not on measure *)
(* comap: maybe in measure.v? *)

HB.about MeasurableFun.


(* Real numbers *)
HB.about realType.

(* Extended real numbers *)
Print extended.

Check ereal_sup.
Check supremum.
Search eseries.

(* Measure *)
HB.about semiRingOfSetsType.
HB.about measurableI.  (* It seems like the isMeasurable factory is what I want to use, since I'm not defining it by CET *)
HB.about isMeasurable.
(* Something about HB.Builders ... what does that do? *)


(* Generated sigma algebra: Actually this is what I want to implement comap, comap is generated *)

Search smallest.

HB.about isMeasurable.Build.

(* HB.instance Definition _ := isMeasurable.Build _ _. *)

HB.about salgebraType. (* Generated sigma algebra? *)
