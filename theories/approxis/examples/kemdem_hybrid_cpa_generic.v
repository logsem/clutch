From Ltac2 Require Import Ltac2.
Set Default Proof Mode "Classic".
From clutch.prob_lang Require Import advantage typing.tychk.
From clutch.approxis Require Import map reltac2 approxis option.
From clutch.clutch.examples.crypto Require ElGamal_bijection.
From clutch.approxis.examples Require Import
  valgroup diffie_hellman security_aux option
  ElGamal_defs bounded_oracle pubkey advantage_laws iterable_expression.
(* We use `lrel_input`, etc, defined in prf_local_state is used *)
From clutch.approxis.examples Require symmetric_init prf_local_state.
From mathcomp Require Import ssrbool.
From mathcomp Require fingroup.fingroup.
Set Default Proof Using "All".
Import ElGamal_bijection.bij_nat.
Import valgroup_notation.
Import fingroup.Notations.
Import map.

Section Hybrid_scheme.

Context {vg : val_group}.           (* A group on a subset of values. *)
Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
Context {vgg : @val_group_generator vg}.   (* G is generated by g. *)
Context {cgg : @clutch_group_generator vg cg vgg}. (* g is well-typed *)

Let N := S n''.
Let SymKey := N.
Let Input := N.
Let SymOutput := N.

Local Instance sym_params : symmetric_init.SYM_init_params := {|
    symmetric_init.card_key := SymKey
  ; symmetric_init.card_message := Input
  ; symmetric_init.card_cipher := SymOutput
|}.

Context `{symmetric_init.SYM_init}.

Definition keygen_kem : val := keygen.

Definition encaps : val :=
  Î»: "pk",
    let: "k" := symmetric_init.get_keygen symmetric_init.sym_scheme #() in
    let:m "kg" := vg_of_int "k" in
    let: "c_kem" := enc "pk" "kg" in
    SOME ("c_kem", "k").

Definition decaps : val :=
  Î»: "sk" "c",
    int_of_vg (dec "sk" "c").

Definition enc_hyb : val :=
  Î»: "enc_scheme" "pk" "msg",
    match: encaps "pk" with
      | NONE => NONE
      | SOME "caps" =>
      let: "c_kem" := Fst "caps" in
      let: "k" := Snd "caps" in
      let: "c_dem" := (symmetric_init.get_enc "enc_scheme") "k" "msg" in
      SOME ("c_dem", "c_kem")
    end.

Definition dec_hyb : val :=
  Î»: "enc_scheme" "sk" "msg",
    let:m "msg'" := "msg" in
    let: "c_dem" := Fst "msg'" in
    let: "c_kem" := Snd "msg'" in
    let: "k" := decaps "sk" "c_kem" in
    SOME ((symmetric_init.get_dec "enc_scheme") "k" "c_dem").

Definition pk_rand : expr :=
  let, ("sk", "pk") := keygen #() in
  let: "count" := ref #0 in
  let: "query" := Î»: "msg",
    let: "k" := symmetric_init.get_keygen symmetric_init.sym_scheme #() in
    let:m "kg" := vg_of_int "k" in
    assert (!"count" = #0);;;
    "count" <- !"count"+#1;;
    let: "b" := rand #N in
    let: "x" := rand #N in
    let: "c_kem" := (g^"b", g^"x") in
    let: "c_dem" := (let: "i" := rand #Input in
      let: "o" := rand #SymOutput in
      ("i", "o")) in
    SOME ("c_dem", "c_kem")
  in
  ("pk", "query").

Definition pk_real : expr :=
  Î»: "enc_scheme",
    let, ("sk", "pk") := keygen #() in
    let: "count" := ref #0 in
    let: "query" := Î»: "msg",
      let:m "caps" := encaps "pk" in
      assert (!"count" = #0);;;
      "count" <- !"count"+#1;;
      let: "c_kem" := Fst "caps" in
      let: "k" := Snd "caps" in
      let: "c_dem" := (symmetric_init.get_enc "enc_scheme") "k" "msg" in
      SOME ("c_dem", "c_kem")
    in
    ("pk", "query").

Definition pk_real_tape : expr :=
  Î»: "enc_scheme",
    let: "Î²" := alloc #N in
    let: "sk" := rand #N in
    let: "pk" := g^"sk" in
    let: "count" := ref #0 in
    let: "query" := Î»:"msg",
      let: "k" :=
        symmetric_init.get_keygen symmetric_init.sym_scheme #() in
      let:m "kg" := vg_of_int "k" in
      let: "b" := rand("Î²") #N in
      let: "B" := g^"b" in
      assert (!"count" = #0);;;
      "count" <- !"count"+#1;;
      let: "C" := "pk"^"b" in
      let: "X" := "kg" Â· "C" in
      let: "c_kem" := ("B", "X") in
      let: "c_dem" := (symmetric_init.get_enc "enc_scheme") "k" "msg" in
      SOME ("c_dem", "c_kem")
      in
    ("pk", "query").

Definition eCsenc : val :=
  (Î»: "DDH_real_or_rand",
    Î»: "enc_scheme",
      let, ("pk", "B", "C") := "DDH_real_or_rand" in
      let: "count" := ref #0 in
      let: "query" := Î»: "msg",
        let: "k" :=
          symmetric_init.get_keygen
            symmetric_init.sym_scheme #() in
        let:m "kg" := vg_of_int "k" in
        assert (!"count" = #0) ;;;
        "count" <- #1 ;;
        let: "X" := "kg" Â· "C" in
        let: "c_kem" := ("B", "X") in
        let: "c_dem" := (symmetric_init.get_enc "enc_scheme") "k" "msg" in
        SOME ("c_dem", "c_kem")
      in ("pk", "query")).

Definition pk_rand_senc_delay : expr :=
  Î»: "enc_scheme",
    let: "Î³" := alloc #N in
    let: "sk" := rand #SymKey in
    let: "b" := rand #N in
    let: "pk" := g^"sk" in
    let: "B" := g^"b" in
    let: "count" := ref #0 in
    let: "query" := Î»: "msg",
      let: "k" :=
        symmetric_init.get_keygen symmetric_init.sym_scheme #() in
      let:m "kg" := vg_of_int "k" in
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      let: "c" := rand("Î³") #N in
      let: "C" := g^"c" in
      let: "X" := "kg" Â· "C" in
      let: "c_kem" := ("B", "X") in
      let: "c_dem" := (symmetric_init.get_enc "enc_scheme") "k" "msg" in
      SOME ("c_dem", "c_kem")
    in ("pk", "query").

Definition Csenc : list ectx_item := [AppRCtx eCsenc].
Definition Csenc_DDH_real : expr := fill Csenc DDH_real.
Definition Csenc_DDH_rand : expr := fill Csenc DDH_rand.

Section logrel.
  Section types.

    Definition TInput := TInt.
    Definition TCipher := TInt.
    Definition TOracle := (TInput â†’ TOption (TOption ((TInt * TInt) * (Ï„G * Ï„G))))%ty.

  End types.

  Context `{!approxisRGS Î£}.
  Context {G : clutch_group (vg:=vg) (cg:=cg)}.
  Context {Î” : listO (lrelC Î£)}.
  
  Ltac simpl_exp := try (rel_apply refines_exp_l; rel_pures_l);
    try (rel_apply refines_exp_r; rel_pures_r).
  Ltac simpl_mult := try (rel_apply refines_mult_l; rel_pures_l);
    try (rel_apply refines_mult_r; rel_pures_r).
  Local Tactic Notation "rel_bind" open_constr(pat) :=
    rel_bind_l pat; rel_bind_r pat.

  Definition init_scheme (e : expr) : expr :=
    let: "scheme" := symmetric_init.get_enc_scheme symmetric_init.sym_scheme
      #() in
    e "scheme".

  (* ASSUMPTIONS ON THE SYMMETRIC SCHEME FOR CORRECTNESS *)

  (* the key must be compatible with ElGamal *)
  Definition lrel_key : lrel Î£ := lrel_int_bounded 0 SymKey.
  Variable lrel_input : lrel Î£. (* := lrel_int_bounded 0 Input. *)

  Axiom lrel_input_refl : forall v v', lrel_input v v' -âˆ— lrel_input v v.

  Variable senc : list loc â†’ val.
  Variable sdec : list loc â†’ val.

  Variable P0l : list loc â†’ iProp Î£.
  Variable P0r : list loc â†’ iProp Î£.

  Variable Pl : list loc â†’ iProp Î£.
  Variable Pr : list loc â†’ iProp Î£.
  Variable Plr : list loc â†’ list loc â†’ iProp Î£.

  Definition P0_P_l_prop := âˆ€ lls, P0l lls -âˆ— Pl lls.
  Definition P0_P_r_prop := âˆ€ rls, P0r rls -âˆ— Pr rls.
  Definition P0lr_Plr_prop := âˆ€ lls rls, P0l lls -âˆ— P0r rls -âˆ— Plr lls rls.
  Hypothesis P0_P_l : P0_P_l_prop.
  Hypothesis P0_P_r : P0_P_r_prop.
  Hypothesis P0lr_Plr : P0lr_Plr_prop.

  Definition refines_init_scheme_l_prop := forall K e E A,
    (âˆ€ lls,
      P0l lls -âˆ—
      refines E
        (fill K (senc lls, sdec lls))
        e A)
    âŠ¢ refines E
        (fill K (symmetric_init.get_enc_scheme symmetric_init.sym_scheme #()))
        e A.

  Definition refines_init_scheme_r_prop := forall K e E A,
    (âˆ€ rls,
      P0r rls -âˆ—
      refines E
        e
        (fill K (senc rls, sdec rls))
        A)
    âŠ¢ refines E
        e
        (fill K (symmetric_init.get_enc_scheme symmetric_init.sym_scheme #()))
        A.

  Hypothesis refines_init_scheme_l : refines_init_scheme_l_prop.

  Hypothesis refines_init_scheme_r : refines_init_scheme_r_prop.

  Definition sym_keygen_sem_typed_prop :=
    âŠ¢ refines top
      symmetric_init.keygen
      symmetric_init.keygen
      (() â†’ lrel_key).
  Hypothesis sym_keygen_sem_typed : sym_keygen_sem_typed_prop.

  Definition sym_is_cipher_l {lls : list loc} (msg : val) (c k : val) : iProp Î£ :=
    âˆ€ K e E A,
      (Pl lls -âˆ—
       refines E
        (fill K (Val msg))
        e A)
    -âˆ— refines E
        (fill K (sdec lls k c))
        e A.

  Definition refines_senc_l_prop := âˆ€ (lls : list loc) (msg : val) (k : val) K e E A,
    (lrel_car lrel_input) msg msg âˆ— Pl lls âŠ¢
      ((âˆ€ (c : val),
         @sym_is_cipher_l lls msg c k
      -âˆ— refines E
          (fill K (Val c))
          e A)
    -âˆ— refines E
        (fill K (senc lls k msg))
        e A).

  Hypothesis refines_senc_l : refines_senc_l_prop.
  
  Section Correctness.

    Import mathcomp.fingroup.fingroup.

    Lemma hybrid_scheme_correct :
      âŠ¢ refines top
          (init_scheme (Î»: "scheme", (let, ("sk", "pk") := keygen #() in
          Î»:"msg", dec_hyb "scheme" "sk" (enc_hyb "scheme" "pk" "msg"))))
          (Î»: "msg", let:m "kg" := vg_of_int (symmetric_init.get_keygen symmetric_init.sym_scheme #()) in
            SOME "msg")%V
          (lrel_input â†’ () + lrel_input).
    Proof with rel_pures_l; rel_pures_r.
      rewrite /init_scheme.
      rel_apply refines_init_scheme_l.
      iIntros (lls) "HP0"...
      rewrite /keygen.
      rewrite -/N...
      rel_apply refines_randU_l.
      iIntros (sk Hskbound)...
      simpl_exp.
      set (P := (Pl lls)%I).
      rel_apply (refines_na_alloc P (nroot.@"hybrid_scheme_correct")).
      iSplitL; first (iApply P0_P_l; iFrame).
      iIntros "#Inv".
      rel_arrow_val.
      iIntros (msg1 msg2) "#Hrelmsg"...
      rewrite /enc_hyb...
      rewrite /encaps...
      rewrite /symmetric_init.get_keygen...
      rel_bind (symmetric_init.keygen #()).
      rel_apply refines_bind.
      {
        rel_apply refines_app.
        - rel_apply sym_keygen_sem_typed.
        - rel_vals.
      }
      iIntros (v v' [k [eq1 [eq2 Hkbounds]]]); subst...
      rewrite /SymKey in Hkbounds.
      (* TODO application of det_val_fun, to change when det_val_fun1
        definition is modified for better application (cf. iterable_expression) *)
      rel_apply_l (vg_of_int_correct _ _ k _ (() + lrel_input)%lrel).
      {
        iSplit.
        - iIntros (x). iExists _. iSplit; done.
        - iIntros (x). destruct x as [xv|].
          + iExists _, _; iRight. repeat iSplit; try done.
            iApply vgval_sem_typed.
          + iExists _, _; iLeft. repeat iSplit; try done.
      }
      rel_apply_r (vg_of_int_correct _ _ k _ (() + lrel_input)%lrel).
      {
        iSplit.
        - iIntros (x). iExists _. iSplit; done.
        - iIntros (x). destruct x as [xv|].
          + iExists _, _; iRight. repeat iSplit; try done.
            iApply vgval_sem_typed.
          + iExists _, _; iLeft. repeat iSplit; try done.
      }
      destruct (vg_of_int_sem k) as [kg|] eqn:eqkg; first last.
      - rewrite /dec_hyb... rel_vals.
      - rewrite /enc... rel_apply refines_randU_l. iIntros (b Hbbound)...
        simpl_exp. simpl_exp. simpl_mult.
        (* remember [AppRCtx
          (Î»: "c_dem",
          InjR ("c_dem", ((g ^+ b)%g, (kg * g ^+ sk ^+ b)%g)%V));
          AppRCtx (dec_hyb (senc lls, sdec lls)%V #sk)] as K. *)
        rel_apply refines_na_inv; iSplitL; first iAssumption.
        iIntros "[HPl Hclose]"...
        iAssert (lrel_input msg1 msg1)%I as "Hlrel1".
        { iApply lrel_input_refl. iAssumption. }
        rewrite /symmetric_init.get_enc.
        rel_pure_l.
        iPoseProof (refines_senc_l lls msg1 #k _ (InjRV msg2)
          (âŠ¤ âˆ– â†‘nroot.@"hybrid_scheme_correct") (() + lrel_input)%lrel with "[HPl]") as "Hrelsenc".
        { iFrame. iAssumption. }
        rewrite /P...
        rel_apply "Hrelsenc".
        iIntros (c) "Hcipher".
        simpl...
        rewrite /dec_hyb...
        rewrite /decaps...
        rewrite /dec...
        simpl_exp.
        rel_apply refines_inv_l.
        simpl_mult.
        rewrite -?expgM -ssrnat.multE -mulgA Nat.mul_comm mulgV mulg1.
        rel_bind_l (int_of_vg _).
        rel_apply_l (int_of_vg_correct);
          first (iSplit; iIntros (x); iExists _; iSplit; done)...
        rewrite (vg_of_int_of_vg_sem k); last by apply eqkg.
        rewrite /symmetric_init.get_dec...
        rewrite /sym_is_cipher_l.
        rel_apply "Hcipher". iIntros "HP".
        rel_apply refines_na_close. iFrame. iFrame...
        rel_vals.
    Qed.

  End Correctness.

  Variable lrel_output : lrel Î£. (* := lrel_int_bounded 0 SymOutput. *)

  Definition senc_sem_typed_prop :=
    âˆ€ lls rls (ð’© : namespace) (P : iProp Î£),
    (âˆƒ (Q : iProp Î£),
      P âŠ£âŠ¢
        (Q
      âˆ— Plr lls rls)
    ) â†’
    na_invP ð’© P
     âŠ¢ refines top (senc lls)
      (senc rls) (lrel_key â†’ lrel_input â†’ lrel_output).

  Hypothesis senc_sem_typed : senc_sem_typed_prop.
  
  Lemma pk_real_real_tape :
    âŠ¢ refines top
        (init_scheme pk_real)
        (init_scheme pk_real_tape)
        (lrel_G * (lrel_input â†’ () + (() + lrel_output * (lrel_G * lrel_G)))).
  Proof with (rel_pures_l; rel_pures_r).
    rewrite /init_scheme.
    rel_apply refines_init_scheme_l.
    iIntros (lls) "HP".
    rel_apply refines_init_scheme_r.
    iIntros (rls) "HP'".
    rewrite /pk_real; rewrite /pk_real_tape...
    rewrite /keygen... rewrite -/N.
    rel_alloctape_r Î² as "HÎ²"...
    rel_apply refines_couple_UU; first done.
    iIntros (n Hnbound). iModIntro...
    simpl_exp...
    rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l.
    rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r.
    rel_apply refines_pair.
    { rel_values. }
    rewrite /encaps. rewrite /enc.
    set (P := (
        Plr lls rls
      âˆ— Î² â†ªâ‚›N(N;[])
      âˆ— (cnt â†¦ #0 âˆ— cnt' â†¦â‚› #0 âˆ¨ cnt â†¦ #1 âˆ— cnt' â†¦â‚› #1)
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"pk_real_real_tape")).
    iFrame.
    iSplitL.
    { iSplitL "HP HP'"; last (iLeft; iFrame).
      iApply (P0lr_Plr with "HP HP'").
    }
    iIntros "#Inv". rel_arrow_val.
    iIntros (msg1 msg2) "#Hrel"; subst...
    rewrite /symmetric_init.get_keygen...
    rel_bind (symmetric_init.keygen _).
    rel_apply refines_bind.
    {
      rel_apply refines_app; first rel_apply sym_keygen_sem_typed.
      rel_vals.
    }
    iIntros (v1 v2 [k [eq1 [eq2 Hkbounds]]]); subst...
    rel_bind (vg_of_int #k).
    rel_apply (refines_bind _ _ _ (() + lrel_G)).
    {
      rel_apply (refines_app _ _ _ _ lrel_int); rel_values.
      iModIntro. iApply vg_of_int_lrel_G.
    }
    iIntros (kg1 kg2 [tmp [tmp' [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]); subst;
    try (rel_pures_l; rel_pures_r; rel_vals)...
    rewrite -/N. rel_apply refines_na_inv. iSplitL; first iAssumption.
    iIntros "[[H [HÎ² Hcnts]] Hclose]".
    rel_apply (refines_couple_UT); first done.
    iFrame. simpl; iModIntro; iIntros (b Hbbound) "HÎ²"...
    rel_apply (refines_randT_r with "HÎ²").
    iIntros "HÎ² _"...
    simpl_exp.
    simpl_exp. rel_apply refines_mult_l...
    iDestruct "Hcnts" as "[[Hcnt Hcnt']|[Hcnt Hcnt']]"; rel_load_l; rel_load_r...
    - rel_load_l; rel_load_r; rel_store_l; rel_store_r...
      simpl_exp. rel_apply refines_mult_r...
      rel_apply refines_na_close; iFrame; iSplitL.
      { iFrame. iRight; replace (0+1)%Z with 1%Z by lia; iFrame. }
      rel_apply refines_injr.
      rewrite /symmetric_init.get_enc...
      rel_bind_l (senc _ _ _).
      rel_bind_r (senc _ _ _).
      rel_apply refines_bind.
      2 : {
        iIntros (v v') "#H". rel_pure_l. rel_pure_l.
        rel_pure_r. rel_pure_r. rel_apply refines_injr. rel_apply refines_pair; rel_vals;
        rewrite /lrel_car; simpl; iExists _; done.
      }
      repeat (rel_apply refines_app);
      [|rel_vals|rel_vals].
      + rel_apply senc_sem_typed; last by iApply "Inv".
        eexists. apply bi.equiv_entails. split.
        * iIntros "[HP HQ]". iFrame.
          iApply "HQ".
        * iIntros "[HQ HP]"; iFrame.
      + iExists k; done.
    - rel_apply refines_na_close. iFrame; iSplitL.
      {
        iFrame; iRight; iFrame.
      }
      rel_vals.
  Qed.

  Lemma pk_real_tape_DDH_real :
    âŠ¢ refines top
        (init_scheme pk_real_tape)
        (init_scheme Csenc_DDH_real) 
      (lrel_G * (lrel_input â†’ () + (() + lrel_output * (lrel_G * lrel_G)))).
  Proof with rel_pures_l; rel_pures_r.
    rewrite /init_scheme...
    rel_apply refines_init_scheme_l.
    iIntros (lls) "HP".
    rel_apply refines_init_scheme_r.
    iIntros (rls) "HP'".
    rewrite /pk_real_tape;
    rewrite /Csenc_DDH_real.
    rewrite /DDH_real. simpl.
    rewrite -/N.
    rel_alloctape_l Î² as "HÎ²"...
    rel_apply refines_couple_UU; first done.
    iIntros (n Hnbound). iModIntro...
    rel_apply refines_couple_TU; first done. iFrame.
    iIntros (b Hbbound) "HÎ²"...
    rewrite -Nat2Z.inj_mul.
    simpl_exp. simpl_exp. simpl_exp.
    rewrite /eCsenc...
    rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l.
    rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r.
    rel_apply refines_pair.
    { rel_values. }
    set (P := (
        (cnt â†¦ #0 âˆ— cnt' â†¦â‚› #0 âˆ— Î² â†ªN(N;[b])
        âˆ¨ cnt â†¦ #1 âˆ— cnt' â†¦â‚› #1 âˆ— Î² â†ªN(N;[]))
        âˆ— Plr lls rls
      )%I).
    rel_apply (refines_na_alloc P (nroot.@"pk_real_real_tape")).
    iSplitL.
    { iSplitR "HP HP'"; first (iLeft; iFrame).
      iApply (P0lr_Plr with "HP HP'").
    }
    iIntros "#Inv".
    rel_arrow_val. iIntros (msg1 msg2) "#Hrelmsg"...
    rewrite /symmetric_init.get_keygen...
    rel_bind (symmetric_init.keygen _).
    rel_apply refines_bind.
    {
      rel_apply refines_app; first rel_apply sym_keygen_sem_typed.
      rel_vals.
    }
    iIntros (v1 v2 [k [eq1 [eq2 Hkbounds]]]); subst...
    rel_bind (vg_of_int #k).
    rel_apply refines_bind.
    { rel_apply refines_app; rel_values; try iApply vg_of_int_lrel_G; rel_vals. }
    iIntros (kg1 kg2 [tmp1 [tmp2 [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]); subst...
    { rel_vals. }
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[[Hcnt [Hcnt' HÎ²]]|[Hcnt [Hcnt' HÎ²]]] Hmaps] Hclose]".
    2:{
      rel_apply refines_randT_empty_l. iFrame.
      iModIntro. iIntros (b') "HÎ² _"...
      simpl_exp. rel_load_l. rel_load_r... rel_apply refines_na_close.
      iFrame; iSplitL; first (iRight; iFrame). rel_vals.
    }
    rel_apply refines_randT_l. iFrame. iModIntro; iIntros "HÎ² _"...
    simpl_exp. rel_load_l; rel_load_r...
    rel_load_l. rel_store_l; rel_store_r.
    replace (0+1)%Z with 1%Z by lia...
    simpl_exp. rewrite -fingroup.expgM.
    rewrite /ssrnat.muln. rewrite /ssrnat.muln_rec.
    simpl_mult.
    rel_apply refines_na_close; iFrame; iSplitL; first (iRight; iFrame).
    rewrite /symmetric_init.get_enc...
    rel_bind_l (senc _ _ _).
    rel_bind_r (senc _ _ _).
    rel_apply refines_bind.
    { repeat (rel_apply refines_app); first rel_apply senc_sem_typed; try by rel_vals.
      eexists. apply bi.equiv_entails. split.
      * iIntros "[HQ HP]". iFrame.
        iApply "HQ".
      * iIntros "[HQ HP]"; iFrame.
    }
    iIntros (cdem1 cdem2) "#Hrel".
    rel_apply refines_injr.
    rel_pure_l. rel_pure_l.
    rel_pure_r. rel_pure_r. rel_apply refines_injr.
    rel_apply (refines_pair with "[Hrel]"); first (rel_vals; iAssumption).
    rel_vals; rewrite /lrel_car; simpl; iExists _; done.
  Qed.

  (* here we use the DDH assumption: we replace C[DDHreal] by C[DDHrand] *)

  Lemma Csenc_DDH_rand_pk_rand_senc_delay :
    âŠ¢ refines top
        (init_scheme Csenc_DDH_rand)
        (init_scheme pk_rand_senc_delay)
        (lrel_G *
        (lrel_input â†’ () + (() + lrel_output * (lrel_G * lrel_G)))).
  Proof with rel_pures_l; rel_pures_r.
    rewrite /init_scheme...
    rel_apply refines_init_scheme_l.
    iIntros (lls) "HP".
    rel_apply refines_init_scheme_r.
    iIntros (rls) "HP'"...
    rewrite /eCsenc...
    rel_alloctape_r Î³ as "HÎ³"...
    rewrite /SymKey. rewrite -/N.
    rel_apply refines_couple_UU; first done.
    iIntros (sk Hskbound); iModIntro...
    rel_apply refines_couple_UU; first done.
    iIntros (b Hbbound); iModIntro...
    rel_apply refines_couple_UT; first done.
    iFrame.
    iIntros (c Hcbound); simpl; iModIntro; iIntros "HÎ³"...
    simpl_exp. simpl_exp. simpl_exp.
    rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l.
    rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r.
    rel_apply refines_pair; first rel_vals.
    set (P := (
      (cnt â†¦ #0 âˆ— cnt' â†¦â‚› #0 âˆ— Î³â†ªâ‚›N(N;[c])
      âˆ¨ cnt â†¦ #1 âˆ— cnt' â†¦â‚› #1 âˆ— Î³â†ªâ‚›N(N;[]))
      âˆ— Plr lls rls
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"CDDHrand_pk_rand_senc_delay")).
    iSplitL.
    { iSplitR "HP HP'"; first (iLeft; iFrame).
      iApply (P0lr_Plr with "HP HP'"). }
    iIntros "#Inv".
    rel_arrow_val.
    iIntros (msg1 msg2) "#Hrelmsg"...
    rewrite /symmetric_init.get_keygen...
    rel_bind (symmetric_init.keygen _).
    rel_apply refines_bind.
    {
      rel_apply refines_app; first rel_apply sym_keygen_sem_typed.
      rel_vals.
    }
    iIntros (v1 v2 [k [eq1 [eq2 Hkbounds]]]); subst...
    rel_bind (vg_of_int #k).
    rel_apply refines_bind.
    { rel_apply refines_app; rel_values; try iApply vg_of_int_lrel_G; rel_vals. }
    iIntros (kg1 kg2 [tmp1 [tmp2 [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]); subst...
    { rel_vals. }
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[[Hcnt [Hcnt' HÎ³]]|[Hcnt [Hcnt' HÎ³]]] Hmaps] Hclose]";
    rel_load_l; rel_load_r...
    2:{ rel_apply refines_na_close; iFrame; iSplitL; first (iRight; iFrame); rel_vals. }
    rel_store_l; rel_store_r...
    rel_apply (refines_randT_r with "HÎ³").
    iIntros "HÎ³ _"...
    simpl_exp. simpl_mult.
    rewrite /symmetric_init.get_enc...
    rel_bind_l (senc _ _ _).
    rel_bind_r (senc _ _ _).
    rel_apply (refines_bind with "[-]").
    { 
      rel_apply refines_na_close; iFrame.
      iSplitL; first (iRight; iFrame).
      repeat (rel_apply refines_app); first rel_apply senc_sem_typed; try by rel_vals.
      eexists. apply bi.equiv_entails. split.
      * iIntros "[HQ HP]". iFrame.
        iApply "HQ".
      * iIntros "[HQ HP]"; iFrame.
    }
    iIntros (cdem1 cdem2) "#Hrel".
    rel_apply refines_injr.
    rel_pure_l. rel_pure_l.
    rel_pure_r. rel_pure_r. rel_apply refines_injr.
    rel_apply (refines_pair with "[Hrel]"); first (rel_vals; iAssumption).
    rel_vals; rewrite /lrel_car; simpl; iExists _; done.
  Qed.
(*
  Definition pk_rand_senc_mult_free : expr :=
    Î»: "sym_scheme",
      let: "sk" := rand #N in
      let: "b" := rand #N in
      let: "pk" := g^"sk" in
      let: "B" := g^"b" in
      let: "count" := ref #0 in
      let: "query" := Î»: "msg",
      let: "k" :=
        symmetric_init.get_keygen symmetric_init.sym_scheme #() in
      let:m "kg" := vg_of_int "k" in
      assert (! "count" = #0);;;
      "count" <- #1;;
      let: "X" := g^(rand #N) in
      let: "ckem" := ("B", "X") in
      if: #0 â‰¤ "msg" `and` "msg" â‰¤ #SymOutput then
        let: "cdem" := (symmetric_init.get_enc "sym_scheme") "k" "msg" in
        SOME ("cdem", "ckem")
      else NONEV
      in ("pk", "query").

  Definition pk_rand_srand : expr :=
    let: "sk" := rand #N in
    let: "b" := rand #N in
    let: "pk" := g^"sk" in
    let: "B" := g^"b" in
    let: "count" := ref #0 in
    let: "query" := Î»: "msg",
      let: "k" :=
        symmetric_init.get_keygen symmetric_init.sym_scheme #() in
    let:m "kg" := vg_of_int "k" in
    assert (! "count" = #0);;;
    "count" <- #1;;
    let: "X" := g^(rand #N) in
    let: "ckem" := ("B", "X") in
    if: #0 â‰¤ "msg" `and` "msg" â‰¤ #SymOutput then
      let: "cdem" := (let: "i" := rand #Input in
        let: "o" := rand #SymOutput in
        ("i", "o")) in
      SOME ("cdem", "ckem")
    else NONEV
    in ("pk", "query").

  (* Here, we get rid of the multiplication by
    the public key, using a nontrivial bijection in the coupling, as in
    ElGamal_semantic *)

  Lemma pk_rand_senc_delay_pk_rand_senc_mult_free :
    âŠ¢ refines top 
        (init_scheme pk_rand_senc_delay)
        (init_scheme pk_rand_senc_mult_free)
        (lrel_G *
        (lrel_input â†’ () + (() + lrel_output * (lrel_G * lrel_G)))).
  Proof with rel_pures_l; rel_pures_r.
    rel_init_scheme mapref "Hmap" mapref' "Hmap'"...
    rel_alloctape_l Î³ as "HÎ³"...
    rel_apply refines_couple_UU; first done.
    iModIntro; iIntros (sk Hskbound)...
    rel_apply refines_couple_UU; first done.
    iModIntro; iIntros (b Hbbound)...
    simpl_exp. simpl_exp.
    rel_alloc_l cnt as "Hcnt".
    rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l.
    rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r.
    rel_apply refines_pair; first rel_values.
    set (P := (
      (Î³ â†ªN (N; []) âˆ— ((cnt â†¦ #0 âˆ— cnt' â†¦â‚› #0) âˆ¨ (cnt â†¦ #1 âˆ— cnt' â†¦â‚› #1)))
      âˆ— (âˆƒ (M : gmap nat val),
          map_list  mapref  M
        âˆ— map_slist mapref' M
        âˆ— âŒœ âˆ€ y, y âˆˆ @map_img nat val (gmap nat val) _ (gset val) _ _ _ M
          â†’ âˆƒ k : nat, y = #k âˆ§ k <= card_output âŒ
        âˆ— âŒœ âˆ€ x, x âˆˆ elements (dom M) -> (x < S card_input)%nat âŒ)
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"pk_rand_delay_tape")).
    iSplitL.
    { iSplitR "Hmap Hmap'"; first (iFrame; iLeft; iFrame).
      iExists âˆ…. iFrame. iPureIntro; split.
      - intros y Hy. rewrite map_img_empty in Hy.
        rewrite elem_of_empty in Hy. exfalso; apply Hy.
      - intros y Hy. rewrite elements_empty in Hy.
        rewrite elem_of_nil in Hy. exfalso; apply Hy. }
    iIntros "#Inv".
    rel_arrow_val.
    iIntros (v1 v2 [x [eq1 [eq2 Hxbound]]]); subst...
    rewrite /card_input in Hxbound; simpl in Hxbound.
    rel_apply refines_couple_UU; first done.
    iModIntro; iIntros (k Hkbound)...
    rel_bind (vg_of_int #k).
    rel_apply refines_bind.
    { rel_apply refines_app; rel_values; try iApply vg_of_int_lrel_G; rel_vals. }
    iIntros (kg1 kg2 [tmp1 [tmp2 [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]); subst...
    { rel_vals. }
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[HÎ³ [[Hcnt Hcnt']|[Hcnt Hcnt']]] Hmaps] Hclose]"...
    - rel_load_l; rel_load_r...
      rel_store_l; rel_store_r...
      (* Rewrite msg into g^k_msg for some k_msg. *)
      destruct (log_g kg) as [k_msg ->].
      rel_apply (refines_couple_TU N (mod_plus _ k_msg)); first apply mod_plus_lt.
      iFrame.
      iIntros (logX HlogXbound) "HÎ³"; simpl.
      rel_rand_l. iIntros "_"...
      simpl_exp. simpl_mult.
      assert (Hxbound' : bool_decide (0 â‰¤ x)%Z && bool_decide (x â‰¤ SymOutput)%Z = true).
      { rewrite andb_true_iff; split; apply bool_decide_eq_true; lia. }
      rewrite Hxbound'...
      rewrite /symmetric_init.get_enc...
      rel_bind_l (prf_enc _ _ _ _ _ _).
      rel_bind_r (prf_enc _ _ _ _ _ _).
      rel_apply (refines_bind with "[-]").
      {
        rel_apply refines_na_close; iFrame.
        iSplitL; iFrame; first (iRight; iFrame).
        repeat (rel_apply refines_app); first rel_apply prf_enc_sem_typed; try by rel_vals.
        rel_arrow_val. iIntros (v1 v2 [tmp [eq1 eq2]]); subst...
        rel_apply random_function_sem_typed_inv; last iAssumption.
        exists (Î³ â†ªN (N; []) âˆ— ((cnt â†¦ #0 âˆ— cnt' â†¦â‚› #0) âˆ¨ (cnt â†¦ #1 âˆ— cnt' â†¦â‚› #1)))%I.
        apply bi.equiv_entails; split; iIntros "H"; rewrite /P; iFrame.
      }
      iIntros (v v') "Hrel"...
      rel_vals; try iAssumption; first last.
      + rewrite -fingroup.expgD -ssrnat.plusE.
        rewrite /mod_plus.
        rewrite -/N.
        assert (H : logX <? S N = true); first (apply Nat.ltb_lt; lia).
        rewrite H; clear H.
        pose proof (e := eq_sym (fingroup.expg_mod_order g (k_msg+logX))).
        rewrite g_nontriv in e.
        rewrite e.
        rewrite -/N.
        rewrite /lrel_car. simpl.
        iExists _. iSplit; iPureIntro; done.
      + iExists _. iSplit; iPureIntro; done.
    - rel_load_l; rel_load_r... rel_apply refines_na_close; iFrame.
      iSplitL; first (iRight; iFrame).
      rel_vals.
  Qed.

  (* from this point on, we need to consider
    an adversary returning a boolean, for
    compatibility with the CPA assumption on
    the symmetric scheme *)
  (* To both be compatble with `rf_is_CPA`,
    and with the type of `adv_rand` and so on,
    We need 2, non equivalent assumption on the boolean
    adversary:
    - Semantic typing with the oracle taking an `lrel_input`, i.e.,
      the boolean adversary can only call the oracle on messages within
      the bounds [0; Input]:
      refines top
        adv
        adv
        ((lrel_G * (lrel_input â†’ () + (() + lrel_int * lrel_int * (lrel_G * lrel_G)))) â†’ lrel_bool).
    - Syntactic typing: âŠ¢áµ¥ adv : ((Ï„G * TOracle) â†’ TBool).
    These are not equivalent because TOracle is a syntactic type,
    it this don't enforce the bounds on the input of the oracle,
    only that it should be an int.
  *)

  Definition adv_rand : val :=
    Î»: "oracle",
      let: "sk" := rand #N in
      let: "b" := rand #N in
      let: "pk" := g^"sk" in
      let: "B" := g^"b" in
      let: "count" := ref #0 in
      let: "query" := Î»: "msg",
        let: "k" :=
          symmetric_init.get_keygen symmetric_init.sym_scheme #() in
        let:m "kg" := vg_of_int "k" in
        assert (! "count" = #0);;;
        "count" <- #1;;
        let: "X" := g^(rand #N) in
        let: "ckem" := ("B", "X") in
        let:m "cdem" := "oracle" "msg" in
        SOME ("cdem", "ckem")
      in ("pk", "query").

  Lemma adv_rand_syn_typed : âŠ¢áµ¥ adv_rand :
    ((TMessage â†’ TOption prf_cpa_with_dec.TCipher) â†’ Ï„G * TOracle).
  Proof.
    rewrite /adv_rand.
    apply Rec_val_typed.
    type_expr 1. 2 : { apply Subsume_int_nat. tychk. }
    type_expr 1.
    type_expr 1. 2 : { apply Subsume_int_nat. tychk. }
    type_expr 1.
    type_expr 1; last try tychk; first last.
    { apply g_typed. }
    { apply vexp_typed. }
    type_expr 1.
    type_expr 1; last try tychk; first last.
    { apply g_typed. }
    { apply vexp_typed. }
    type_expr 1.
    type_expr 1; last try tychk.
    type_expr 1.
    type_expr 1; first tychk.
    type_expr 1.
    type_expr 1. 2 : { apply Subsume_int_nat. tychk. }
    type_expr 1.
    type_expr 1.
    { tychk. apply vg_of_int_typed. }
    { tychk. }
    type_expr 1.
    type_expr 1; first tychk.
    2 : { apply InjL_typed. tychk. }
    apply InjR_typed.
    type_expr 1; last tychk.
    type_expr 1.
    type_expr 1. 2 : {
      type_expr 1. 2 : { apply Subsume_int_nat. tychk. }
      tychk.
      { apply vexp_typed. }
      { apply g_typed. }
    }
    type_expr 1.
    type_expr 1; try tychk.
  Qed.

  Lemma pk_rand_senc_mult_free_adv_sym_cpa (adv : val) :
    refines top
      adv
      adv
      ((lrel_G * (lrel_input â†’ () + (() + lrel_int * lrel_int * (lrel_G * lrel_G)))) â†’ lrel_bool)
    âŠ¢ refines top
        (adv (init_scheme pk_rand_senc_mult_free))
        (symmetric_init.CPA #true (Î»: "oracle", adv (adv_rand "oracle"))%V
          (@symmetric_init.sym_scheme (SYM_param SymKey Input SymOutput)
            (sym_rf_scheme SymKey Input SymOutput xor_struct)) #1)
        lrel_bool.
  Proof with rel_pures_l; rel_pures_r.
    iIntros "Hadvtyped".
    rewrite /symmetric_init.sym_scheme/symmetric_init.CPA...
    rewrite /symmetric_init.get_enc_scheme...
    rel_apply refines_rf_scheme_r.
    iIntros (mapref') "Hmap'"...
    rewrite /rf_enc/rf_dec...
    rewrite /symmetric_init.get_keygen/rf_keygen; rel_pures_r.
    rel_init_scheme_l mapref "Hmap"...
    rel_apply refines_randU_r.
    iIntros (k Hkbound); rel_pures_r.
    rewrite /symmetric_init.get_enc/prf_enc; rel_pures_r.
    rewrite /random_function; rel_pures_r.
    rewrite -/random_function; rel_pures_r.
    rewrite /q_calls/symmetric_init.get_card_message; rel_pures_r.
    rel_alloc_r cnt2 as "Hcnt2".
    rel_pure_r. rel_pure_r.
    rel_pure_r. rel_pure_r.
    rel_pure_r. rel_pure_r.
    rewrite /pk_rand_senc_mult_free.
    rel_bind_l (adv _).
    rel_bind_r (adv _).
    rel_apply (refines_bind with "[-]").
    2 : { iIntros (v v') "Hrel"... rel_vals. }
    rel_apply (refines_app with "[Hadvtyped]")...
    { iAssumption. }
    rewrite /adv_rand; rel_pures_r.
    rel_apply refines_couple_UU; first done.
    iIntros (sk Hskbound). iModIntro...
    rel_apply refines_couple_UU; first done.
    iIntros (b Hbbound). iModIntro...
    simpl_exp. simpl_exp.
    rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l; rel_pure_l; rel_pure_l;
    rel_pure_l; rel_pure_l.
    rel_pure_r. rel_pure_r.
    rel_pure_r. rel_pure_r.
    rel_pure_r.
    rel_bind_l _.
    rel_bind_r (_, _)%E.
    rel_apply (refines_bind with "[-]").
    2:{ iIntros (v v') "Hrel"... rel_vals. } simpl.
    rel_apply refines_pair; first (rel_vals; iApply Ï„G_subtype; iExists _; done).
    set (P := (
        ((cnt â†¦ #0 âˆ— cnt' â†¦â‚› #0 âˆ— cnt2 â†¦â‚› #0)
      âˆ¨ (cnt â†¦ #1 âˆ— cnt' â†¦â‚› #1 âˆ— cnt2 â†¦â‚› #1))
      âˆ— (âˆƒ (M : gmap nat val),
          map_list  mapref  M
        âˆ— map_slist mapref' M
        âˆ— âŒœ âˆ€ y, y âˆˆ @map_img nat val (gmap nat val) _ (gset val) _ _ _ M
          â†’ âˆƒ k : nat, y = #k âˆ§ k <= card_output âŒ
        âˆ— âŒœ âˆ€ x, x âˆˆ elements (dom M) -> (x < S card_input)%nat âŒ)
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"prf_rand_adv_cpa")).
    iSplitL.
    { iSplitR "Hmap Hmap'"; first (iFrame; iLeft; iFrame).
      iExists âˆ…. iFrame. iPureIntro; split.
      - intros y Hy. rewrite map_img_empty in Hy.
        rewrite elem_of_empty in Hy. exfalso; apply Hy.
      - intros y Hy. rewrite elements_empty in Hy.
        rewrite elem_of_nil in Hy. exfalso; apply Hy. }
    iIntros "#Inv".
    rel_arrow_val.
    iIntros (v1 v2 [x [eq1 [eq2 Hxbound]]]); subst...
    rewrite /card_input in Hxbound. simpl in Hxbound.
    rel_apply refines_couple_UU; first done.
    iIntros (k_dummy Hkdummy_bound); iModIntro...
    rel_bind (vg_of_int #k_dummy); rel_apply refines_bind.
    { rel_apply refines_app; rel_values; try iApply vg_of_int_lrel_G; rel_vals. }
    iIntros (kg1 kg2 [tmp1 [tmp2 [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]);
    subst; rel_pures_l; rel_pures_r; first rel_vals.
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[[Hcnt [Hcnt' Hcnt2]]|[Hcnt [Hcnt' Hcnt2]]] Hmaps] Hclose]".
    2 : {
      rel_load_l; rel_load_r... rel_apply refines_na_close; iFrame; iSplitL.
      + iRight. iFrame.
      + rel_vals.
    }
    rel_load_l; rel_load_r...
    rel_store_l; rel_store_r...
    rel_apply refines_couple_UU; first done.
    iIntros (logX HlogXbound); iModIntro; simpl_exp...
    rel_load_r...
    assert (Hxbound' : bool_decide (0 â‰¤ x)%Z && bool_decide (x â‰¤ SymOutput)%Z = true).
    { rewrite andb_true_iff; split; apply bool_decide_eq_true; lia. }
    rewrite Hxbound'. clear Hxbound'.
    rel_pures_l; rel_pures_r.
    rel_load_r... rel_store_r...
    rewrite /rf_enc. rewrite /prf_enc.
    rewrite /random_function... (* here, we could see if there is a way to avoid
    having to step through an execution of `random_function` instead of just
    applying `random_function_sem_typed_inv` once again *)
    rel_apply refines_couple_UU; first done.
    iIntros (r Hrbound); iModIntro...
    iDestruct "Hmaps" as (M) "[Hmap [Hmap' [%Himg %Hdom]]]".

    rel_apply (refines_get_l with "[-Hmap]"); last by iAssumption.
    iIntros (res) "Hmap %Heqres".
    rel_apply (refines_get_r with "[-Hmap']"); last by iAssumption.
    iIntros (res') "Hmap' %Heqres'".
    rewrite Heqres' Heqres. clear Heqres res Heqres' res'.
    destruct (M !! r) as [yv|] eqn:eqlookup...
    - eapply elem_of_map_img_2 in eqlookup.
      apply Himg in eqlookup as [y [eqy Hybound]]; subst.
      rewrite /card_output in Hybound. simpl in Hybound.
      rel_apply xor_correct_l; try lia.
      rel_apply xor_correct_r; try lia...
      rel_apply refines_na_close; iFrame.
      iSplitL.
      { replace (0+1)%Z with 1%Z by lia. iFrame.
        iSplitL; first (iRight; iFrame).
        iPureIntro; split; assumption. }
      rel_vals; iExists _; iPureIntro; split; reflexivity.
    - rel_apply refines_couple_UU; first done...
      (* here, just above, it really feels weird to use PRF (strictly equal to OTP)*)
      iIntros (y Hybound); iModIntro...
      rel_apply (refines_set_l with "[-Hmap]"); last by iAssumption.
      iIntros "Hmap"...
      rel_apply (refines_set_r with "[-Hmap']"); last by iAssumption.
      iIntros "Hmap'"...
      rel_apply refines_na_close; iFrame.
      iSplitL.
      { replace (0+1)%Z with 1%Z by lia. iFrame.
        iSplitL; first (iRight; iFrame).
        iPureIntro; split.
        - intros z Hz. rewrite map_img_insert in Hz. rewrite elem_of_union in Hz.
          destruct Hz as [Hz | contra].
          + rewrite elem_of_singleton in Hz; subst. exists y; split; done.
          + apply Himg. eapply map_img_delete_subseteq. apply contra.
        - intros z Hz. rewrite dom_insert in Hz.
          rewrite elements_union_singleton in Hz.
          2:{ apply not_elem_of_dom. apply eqlookup. }
          rewrite elem_of_cons in Hz. destruct Hz as [Hz|  contra]; subst.
          + rewrite /card_input. simpl. lia. 
          + apply Hdom. assumption.
      }
      rel_apply refines_injr...
      rel_bind (#r, xor #x #y)%E; rel_apply (refines_bind _ _ _ (lrel_int * lrel_int)).
      { 
        rel_apply xor_correct_l; last
        rel_apply xor_correct_r; try lia...
        rel_vals. 
      }
      iIntros (cdem cdem') "Hrel"...
      rel_vals; first iAssumption; iExists _; done.
    Unshelve. eapply gset_fin_set.
  Qed.

  Lemma rf_is_CPA_instantiated_adv_rand (adv : val)
    (Hadvtype : âŠ¢áµ¥ adv : ((Ï„G * TOracle) â†’ TBool)) :
    âŠ¢ refines top
        ((symmetric_init.CPA #true (Î»: "oracle", adv (adv_rand "oracle"))%V
          (@symmetric_init.sym_scheme (SYM_param SymKey Input SymOutput)
            (sym_rf_scheme SymKey Input SymOutput xor_struct)) #1))
        ((symmetric_init.CPA #false (Î»: "oracle", adv (adv_rand "oracle"))%V
          (@symmetric_init.sym_scheme (SYM_param SymKey Input SymOutput)
            (sym_rf_scheme SymKey Input SymOutput xor_struct)) #1))
        lrel_bool.
  Proof. iStartProof.
    iPoseProof ec_zero as "Hec".
    iMod "Hec".
    iPoseProof (rf_is_CPA SymKey Input SymOutput xor_struct (Î»: "oracle", adv (adv_rand "oracle")) _ _ 1) as "H".
    rewrite INR_1; simpl.
    rewrite Rminus_diag.
    rewrite Rmult_0_l.
    rewrite Rdiv_0_l.
    replace (Z.of_nat 1) with 1%Z by lia.
    iApply "H". iClear "H".
    iAssumption.
    Unshelve.
    constructor.
    constructor.
    type_expr 1.
    - apply Val_typed. apply Hadvtype.
    - type_expr 1; last tychk. apply Val_typed. apply adv_rand_syn_typed.
  Qed.

  Lemma rf_CPA_pk_rand_srand (adv : val) : 
    refines top
      adv
      adv
      ((lrel_G * (lrel_input â†’ () + (() + lrel_int * lrel_int * (lrel_G * lrel_G)))) â†’ lrel_bool)
    âŠ¢ refines top
        ((symmetric_init.CPA #false (Î»: "oracle", adv (adv_rand "oracle"))%V
          (@symmetric_init.sym_scheme (SYM_param SymKey Input SymOutput)
            (sym_rf_scheme SymKey Input SymOutput xor_struct)) #1))
        (adv pk_rand_srand)
        lrel_bool.
  Proof with rel_pures_l; rel_pures_r. iIntros "Hadvtyped".
    rewrite /symmetric_init.sym_scheme/symmetric_init.CPA...
    rel_init_scheme_l mapref "Hmap"...
    rewrite /symmetric_init.get_keygen/rf_keygen...
    rel_apply refines_randU_l.
    iIntros (k Hkbound)...
    rewrite /symmetric_init.get_rand_cipher/symmetric_init.get_card_message...
    rewrite /q_calls.
    rel_alloc_l cnt2 as "Hcnt2"...
    rewrite /adv_rand...
    rel_bind_l (adv _); rel_bind_r (adv _).
    rel_apply (refines_bind with "[-]").
    2:{ iIntros (v v') "Hrel"... rel_vals. }
    rel_apply (refines_app with "Hadvtyped").
    rewrite /pk_rand_srand.
    rel_apply refines_couple_UU; first done.
    iIntros (sk Hskbound). iModIntro...
    rel_apply refines_couple_UU; first done.
    iIntros (b Hbbound). iModIntro...
    simpl_exp. simpl_exp.
    rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l; rel_pure_l.
    rel_pure_l; rel_pure_l.
    rel_pure_l.
    rel_pure_r; rel_pure_r.
    rel_pure_r; rel_pure_r.
    rel_pure_r.
    rel_apply refines_pair; first rel_vals.
    set (P := (
        (cnt â†¦ #0 âˆ— cnt' â†¦â‚› #0 âˆ— cnt2 â†¦ #0)
      âˆ¨ (cnt â†¦ #1 âˆ— cnt' â†¦â‚› #1 âˆ— cnt2 â†¦ #1)
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"prf_rand_adv_cpa")).
    iSplitL; first (iLeft; iFrame).
    iIntros "#Inv".
    rel_arrow_val.
    iIntros (v1 v2 [msg [eq1 [eq2 Hmsgbound]]]); subst...
    rewrite /card_input in Hmsgbound; simpl in Hmsgbound.
    rel_apply refines_couple_UU; first done; iModIntro.
    iIntros (k_dummy Hkdummybound)...
    rel_bind (vg_of_int #k_dummy); rel_apply refines_bind.
    { rel_apply refines_app; rel_values; try iApply vg_of_int_lrel_G; rel_vals. }
    iIntros (kg1 kg2 [tmp1 [tmp2 [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]);
    subst; rel_pures_l; rel_pures_r; first rel_vals.
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[Hcnt [Hcnt' Hcnt2]]|[Hcnt [Hcnt' Hcnt2]]] Hclose]".
    2 : {
      rel_load_l; rel_load_r... rel_apply refines_na_close; iFrame; iSplitL.
      + iRight. iFrame.
      + rel_vals.
    }
    rel_load_l; rel_load_r...
    rel_store_l; rel_store_r...
    rel_apply refines_couple_UU; first done.
    iIntros (logX HlogXbound). iModIntro...
    simpl_exp.
    rel_load_l...
    assert (Hmsgbound' : bool_decide (0 â‰¤ msg)%Z && bool_decide (msg â‰¤ SymOutput)%Z = true).
    { rewrite andb_true_iff; split; apply bool_decide_eq_true; lia. }
    rewrite Hmsgbound'. clear Hmsgbound'...
    rel_load_l; rel_store_l...
    rewrite /rf_rand_cipher...
    rel_apply refines_couple_UU; first done.
    iIntros (i Hibound); iModIntro...
    rel_apply refines_couple_UU; first done.
    iIntros (o Hobound); iModIntro...
    rel_apply refines_na_close; iFrame; iSplitL.
    { iRight; replace (0+1)%Z with 1%Z by lia; iFrame. }
    rel_vals; iExists _; done.
  Qed.

  Definition pk_rand_tape : expr :=
    let: "Î²" := alloc #N in
    let: "sk" := rand #N in
    let: "pk" := g^"sk" in
    let: "count" := ref #0 in
    let: "query" := Î»: "msg",
      let: "k" :=
        symmetric_init.get_keygen symmetric_init.sym_scheme #() in
      let:m "kg" := vg_of_int "k" in
      assert (! "count" = #0);;;
      "count" <- #1;;
      let: "b" := rand("Î²") #N in
      let: "B" := g^"b" in
      let: "X" := g^(rand #N) in
      let: "ckem" := ("B", "X") in
      let: "cdem" := (let: "i" := rand #Input in
        let: "o" := rand #SymOutput in
        ("i", "o")) in
      SOME ("cdem", "ckem")
    in ("pk", "query").

  Lemma pk_rand_srand_rand_tape (adv : val) :
    refines top
      adv
      adv
      ((lrel_G * (lrel_input â†’ () + (() + lrel_int * lrel_int * (lrel_G * lrel_G)))) â†’ lrel_bool)
    âŠ¢ refines top
        (adv pk_rand_srand)
        (adv pk_rand_tape)
        lrel_bool.
  Proof with rel_pures_l; rel_pures_r.
    iIntros "Hadvtyped".
    rel_apply (refines_app with "Hadvtyped").
    rewrite /pk_rand_srand.
    rewrite /pk_rand_tape.
    rel_alloctape_r Î² as "HÎ²"...
    rel_apply refines_couple_UU; first done.
    iIntros (sk Hskbound); iModIntro...
    rel_apply refines_couple_UT; first done.
    iFrame. iModIntro.
    iIntros (b Hbbound) "HÎ²"...
    simpl_exp. simpl_exp.
    rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l; rel_pure_l; rel_pure_l; rel_pure_l; rel_pure_l.
    rel_pure_r; rel_pure_r; rel_pure_r; rel_pure_r; rel_pure_r.
    rel_apply refines_pair; first rel_vals. simpl.
    set (P := (
        cnt â†¦ #0 âˆ— cnt' â†¦â‚› #0 âˆ— Î²â†ªâ‚›N(N;[b])
      âˆ¨ cnt â†¦ #1 âˆ— cnt' â†¦â‚› #1 âˆ— Î²â†ªâ‚›N(N;[])
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"pk_rand_srand_rand_tape")).
    iSplitL; first (iLeft; iFrame).
    iIntros "#Inv".
    rel_arrow_val.
    iIntros (v1 v2 [msg [eq1 [eq2 Hmsgbound]]]); subst...
    rewrite /card_input in Hmsgbound; simpl in Hmsgbound.
    rel_apply refines_couple_UU; first done.
    iIntros (k Hkbound); iModIntro...
    rel_bind (vg_of_int #k).
    rel_apply (refines_bind _ _ _ (() + lrel_G)).
    {
      rel_apply (refines_app _ _ _ _ lrel_int); rel_values.
      iModIntro. iApply vg_of_int_lrel_G.
    }
    iIntros (kg1 kg2 [tmp [tmp' [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]); subst;
    try (rel_pures_l; rel_pures_r; rel_vals)...
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[Hcnt [Hcnt' HÎ²]]|[Hcnt [Hcnt' HÎ²]]] Hclose]";
    rel_load_l; rel_load_r...
    2:{ rel_apply refines_na_close; iFrame. iSplitL; first (iRight; iFrame); rel_vals. }
    rel_store_l; rel_store_r...
    rel_apply (refines_randT_r with "HÎ²").
    iIntros "HÎ² _"...
    simpl_exp.
    rel_apply refines_couple_UU; first done.
    iModIntro; iIntros (logX HlogXbound)...
    simpl_exp.
    assert (Hmsgbound' : bool_decide (0 â‰¤ msg)%Z && bool_decide (msg â‰¤ SymOutput)%Z = true).
    { rewrite andb_true_iff; split; apply bool_decide_eq_true; lia. }
    rewrite Hmsgbound'. clear Hmsgbound'...
    rel_apply refines_couple_UU; first done.
    iModIntro; iIntros (i Hibound)...
    rel_apply refines_couple_UU; first done.
    iModIntro; iIntros (o Hobound)...
    rel_apply refines_na_close; iFrame; iSplitL; first (iRight; iFrame).
    rel_vals; iExists _; done.
  Qed.

  Lemma pk_rand_tape_pk_rand (adv : val) :
    refines top
      adv
      adv
      ((lrel_G * (lrel_input â†’ () + (() + lrel_int * lrel_int * (lrel_G * lrel_G)))) â†’ lrel_bool)
    âŠ¢ refines top
        (adv pk_rand_tape)
        (adv pk_rand)
        lrel_bool.
  Proof with rel_pures_l; rel_pures_r. iIntros "Hadvtyped".
    rel_apply (refines_app with "Hadvtyped").
    rewrite /pk_rand_tape. rewrite /pk_rand.
    rewrite /keygen...
    rewrite -/N.
    rel_alloctape_l Î² as "HÎ²"...
    rel_apply refines_couple_UU; first done.
    iIntros (sk Hskbound); iModIntro...
    simpl_exp.
    rel_alloc_l cnt as "Hcnt".
    rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l; rel_pure_l; rel_pure_l; rel_pure_l; rel_pure_l.
    rel_pure_r; rel_pure_r; rel_pure_r; rel_pure_r; rel_pure_r.
    rel_apply refines_pair; first (rel_vals; iExists _; done).
    set (P := (
      (cnt â†¦ #0 âˆ— cnt' â†¦â‚› #0 âˆ¨ cnt â†¦ #1 âˆ— cnt' â†¦â‚› #1) âˆ— Î²â†ªN(N;[])
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"pk_rand_tape_pk_rand")).
    iSplitL; first (iFrame; iLeft; iFrame).
    iIntros "#Inv".
    rel_arrow_val.
    iIntros (v1 v2 [msg [eq1 [eq2 Hmsgbound]]]); subst...
    rel_apply refines_couple_UU; first done.
    iIntros (k Hkbound); iModIntro...
    rel_bind (vg_of_int #k); rel_apply refines_bind.
    { rel_apply refines_app; rel_values; try iApply vg_of_int_lrel_G; rel_vals. }
    iIntros (kg1 kg2 [tmp1 [tmp2 [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]);
    subst; rel_pures_l; rel_pures_r; first rel_vals.
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[[Hcnt Hcnt']|[Hcnt Hcnt']] HÎ²] Hclose]";rel_load_l; rel_load_r...
    2 : {
      rel_apply refines_na_close; iFrame; iSplitL.
      + iRight. iFrame.
      + rel_vals.
    }
    rel_load_r... rel_store_l; rel_store_r...
    rel_apply refines_couple_TU; first done; iFrame.
    iIntros (b Hbbound) "HÎ²"; simpl.
    rel_apply refines_randT_l; iFrame.
    iModIntro. iIntros "HÎ² _"...
    simpl_exp.
    rel_apply refines_couple_UU; first done.
    iIntros (x Hxbound); iModIntro...
    simpl_exp. simpl_exp.
    rel_apply refines_couple_UU; first done.
    iIntros (i Hibound); iModIntro...
    rel_apply refines_couple_UU; first done.
    iIntros (o Hobound); iModIntro...
    rel_apply refines_na_close; iFrame; iSplitL.
    { replace (0+1)%Z with 1%Z by lia. iFrame; iRight; iFrame. }
    rel_vals; iExists _; done.
  Qed.
*)
End logrel.

End Hybrid_scheme.