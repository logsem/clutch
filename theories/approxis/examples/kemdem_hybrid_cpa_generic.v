From Ltac2 Require Import Ltac2.
Set Default Proof Mode "Classic".
From clutch.prob_lang Require Import advantage typing.tychk.
From clutch.approxis Require Import map reltac2 approxis option.
From clutch.clutch.examples.crypto Require ElGamal_bijection.
From clutch.approxis.examples Require Import
  valgroup diffie_hellman security_aux option
  ElGamal_defs bounded_oracle pubkey advantage_laws iterable_expression.
(* We use `lrel_input`, etc, defined in prf_local_state is used *)
From clutch.approxis.examples Require symmetric_init prf_local_state.
From mathcomp Require Import ssrbool.
From mathcomp Require fingroup.fingroup.
Set Default Proof Using "All".
Import ElGamal_bijection.bij_nat.
Import valgroup_notation.
Import fingroup.Notations.
Import map.

Section Hybrid_scheme.

Context {vg : val_group}.           (* A group on a subset of values. *)
Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
Context {vgg : @val_group_generator vg}.   (* G is generated by g. *)
Context {cgg : @clutch_group_generator vg cg vgg}. (* g is well-typed *)

Let N := S n''.
Let SymKey := N.
Let Input := N.
Let SymOutput := N.

Local Instance sym_params : symmetric_init.SYM_init_params := {|
    symmetric_init.card_key := SymKey
  ; symmetric_init.card_message := Input
  ; symmetric_init.card_cipher := SymOutput
|}.

Context `{symmetric_init.SYM_init}.

Definition keygen_kem : val := keygen.

Definition encaps : val :=
  λ: "pk",
    let: "k" := symmetric_init.get_keygen symmetric_init.sym_scheme #() in
    let: "ckem" := enc "pk" "k" in
    ("ckem", "k").

Definition decaps : val :=
  λ: "sk" "c",
    (dec "sk" "c").

Definition enc_hyb : val :=
  λ: "enc_scheme" "pk" "msg",
    let: "caps" := encaps "pk" in
    let: "k" := Snd "caps" in
    let: "ckem" := Fst "caps" in
    let: "cdem" := (symmetric_init.get_enc "enc_scheme") "k" "msg" in
    ("cdem", "ckem").

Definition dec_hyb : val :=
  λ: "enc_scheme" "sk" "msg",
    let: "cdem" := Fst "msg" in
    let: "ckem" := Snd "msg" in
    let: "k" := decaps "sk" "ckem" in
    ((symmetric_init.get_dec "enc_scheme") "k" "cdem").

Definition pk_rand : expr :=
  let, ("sk", "pk") := keygen #() in
  let: "count" := ref #0 in
  let: "query" := λ: "msg",
    assert (!"count" = #0);;;
    "count" <- #1;;
    let: "k" := symmetric_init.get_keygen
      symmetric_init.sym_scheme #() in
    let: "b" := rand #N in
    let: "x" := rand #N in
    let: "ckem" := (g^"b", g^"x") in
    let: "cdem" :=
      symmetric_init.get_rand_cipher
        symmetric_init.sym_scheme "msg" in
    ("cdem", "ckem")
  in
  ("pk", "query").

Definition pk_real : expr :=
  λ: "enc_scheme",
    let, ("sk", "pk") := keygen #() in
    let: "count" := ref #0 in
    let: "query" := λ: "msg",
      assert (!"count" = #0);;;
      "count" <- #1;;
      let: "caps" := encaps "pk" in
      let: "ckem" := Fst "caps" in
      let: "k" := Snd "caps" in
      let: "cdem" := (symmetric_init.get_enc "enc_scheme") "k" "msg" in
      ("cdem", "ckem")
    in
    ("pk", "query").

Definition pk_real_tape : expr :=
  λ: "enc_scheme",
    let: "β" := alloc #N in
    let: "sk" := rand #N in
    let: "pk" := g^"sk" in
    let: "count" := ref #0 in
    let: "query" := λ:"msg",
      assert (!"count" = #0);;;
      "count" <- #1;;
      let: "k" := symmetric_init.get_keygen
        symmetric_init.sym_scheme #() in
      let: "b" := rand("β") #N in
      let: "B" := g^"b" in
      let: "C" := "pk"^"b" in
      let: "X" := "k" · "C" in
      let: "ckem" := ("B", "X") in
      let: "cdem" := (symmetric_init.get_enc "enc_scheme") "k" "msg" in
      ("cdem", "ckem")
      in
    ("pk", "query").

Definition eCsenc : val :=
  (λ: "DDH_real_or_rand",
    λ: "enc_scheme",
      let, ("pk", "B", "C") := "DDH_real_or_rand" in
      let: "count" := ref #0 in
      let: "query" := λ: "msg",
        assert (!"count" = #0) ;;;
        "count" <- #1 ;;
        let: "k" :=
          symmetric_init.get_keygen
            symmetric_init.sym_scheme #() in
        let: "X" := "k" · "C" in
        let: "ckem" := ("B", "X") in
        let: "cdem" := (symmetric_init.get_enc "enc_scheme") "k" "msg" in
        ("cdem", "ckem")
      in ("pk", "query")).

Definition pk_rand_senc_delay : expr :=
  λ: "enc_scheme",
    let: "γ" := alloc #N in
    let: "sk" := rand #SymKey in
    let: "b" := rand #N in
    let: "pk" := g^"sk" in
    let: "B" := g^"b" in
    let: "count" := ref #0 in
    let: "query" := λ: "msg",
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      let: "k" :=
        symmetric_init.get_keygen
          symmetric_init.sym_scheme #() in
      let: "c" := rand("γ") #N in
      let: "C" := g^"c" in
      let: "X" := "k" · "C" in
      let: "ckem" := ("B", "X") in
      let: "cdem" := (symmetric_init.get_enc "enc_scheme") "k" "msg" in
      ("cdem", "ckem")
    in ("pk", "query").

Definition Csenc : list ectx_item := [AppRCtx eCsenc].
Definition Csenc_DDH_real : expr := fill Csenc DDH_real.
Definition Csenc_DDH_rand : expr := fill Csenc DDH_rand.

Section logrel.

  Variable TMessage : type.
  Variable TKey : type.
  Variable TOutput : type.
  Variable TInput : type.
  Variable TCipher : type.
  Definition TOracle := (TInput → TOption (TOption (TCipher * (τG * τG))))%ty.

  Context `{!approxisRGS Σ}.
  Context {G : clutch_group (vg:=vg) (cg:=cg)}.
  Context {Δ : listO (lrelC Σ)}.
  
  Ltac simpl_exp := try (rel_apply refines_exp_l; rel_pures_l);
    try (rel_apply refines_exp_r; rel_pures_r).
  Ltac simpl_mult := try (rel_apply refines_mult_l; rel_pures_l);
    try (rel_apply refines_mult_r; rel_pures_r).
  Local Tactic Notation "rel_bind" open_constr(pat) :=
    rel_bind_l pat; rel_bind_r pat.

  Definition init_scheme (e : expr) : expr :=
    let: "scheme" := symmetric_init.get_enc_scheme symmetric_init.sym_scheme
      #() in
    e "scheme".

  (* ASSUMPTIONS ON THE SYMMETRIC SCHEME FOR CORRECTNESS *)

  (* the key must be compatible with ElGamal *)
  Variable lrel_key : lrel Σ.

  Hypothesis lrel_keyG : forall v v', lrel_key v v' -∗ lrel_G v v'.

  Variable lrel_input : lrel Σ. (* := lrel_int_bounded 0 Input. *)

  Axiom lrel_input_refl : forall v v', lrel_input v v' -∗ lrel_input v v.

  Variable senc : list loc → val.
  Variable sdec : list loc → val.

  Variable P0l : list loc → iProp Σ.
  Variable P0r : list loc → iProp Σ.

  Variable Pl : list loc → iProp Σ.
  Variable Pr : list loc → iProp Σ.
  Variable Plr : list loc → list loc → iProp Σ.

  Definition P0_P_l_prop := ∀ lls, P0l lls -∗ Pl lls.
  Definition P0_P_r_prop := ∀ rls, P0r rls -∗ Pr rls.
  Definition P0lr_Plr_prop := ∀ lls rls, P0l lls -∗ P0r rls -∗ Plr lls rls.
  Hypothesis P0_P_l : P0_P_l_prop.
  Hypothesis P0_P_r : P0_P_r_prop.
  Hypothesis P0lr_Plr : P0lr_Plr_prop.

  Definition refines_init_scheme_l_prop := forall K e E A,
    (∀ lls,
      P0l lls -∗
      refines E
        (fill K (senc lls, sdec lls))
        e A)
    ⊢ refines E
        (fill K (symmetric_init.get_enc_scheme symmetric_init.sym_scheme #()))
        e A.

  Definition refines_init_scheme_r_prop := forall K e E A,
    (∀ rls,
      P0r rls -∗
      refines E
        e
        (fill K (senc rls, sdec rls))
        A)
    ⊢ refines E
        e
        (fill K (symmetric_init.get_enc_scheme symmetric_init.sym_scheme #()))
        A.

  Hypothesis refines_init_scheme_l : refines_init_scheme_l_prop.

  Hypothesis refines_init_scheme_r : refines_init_scheme_r_prop.

  Definition refines_sym_keygen_couple_prop := forall K K' E A,
    (∀ key,
      (lrel_car lrel_key) key key -∗
        refines E
          (fill K  (Val key))
          (fill K' (Val key))
          A)
    ⊢ refines E
        (fill K  (symmetric_init.keygen #()))
        (fill K' (symmetric_init.keygen #()))
        A.
  Hypothesis refines_sym_keygen_couple : refines_sym_keygen_couple_prop.

  Definition refines_keygen_l_prop := forall K e E A,
    (∀ key,
      (lrel_car lrel_key) key key -∗
      refines E
        (fill K (Val key))
        e A)
    ⊢ refines E
        (fill K (symmetric_init.keygen #()))
        e A.
  (* Definition refines_keygen_r_prop := forall K e E A,
    (∀ key,
      (lrel_car lrel_key) key key -∗
      refines E
        e
        (fill K (Val key))
        A)
    ⊢ refines E
        e
        (fill K (symmetric_init.keygen #()))
        A. *)
  Hypothesis refines_keygen_l : refines_keygen_l_prop.
  (* Hypothesis refines_keygen_r : refines_keygen_r_prop. *)

  Definition sym_is_cipher_l {lls : list loc} (msg : val) (c k : val) : iProp Σ :=
    ∀ K e E A,
      (Pl lls -∗
       refines E
        (fill K (Val msg))
        e A)
    -∗ refines E
        (fill K (sdec lls k c))
        e A.

    (* TODO check if it's provable for rf/otp *)
  Definition sym_is_cipher_l' {lls : list loc} (msg : val) (c k : val) : iProp Σ :=
    ∀ K e E A,
      (Pl lls -∗
       refines E
        (fill K (senc lls k msg))
        e A)
    -∗ refines E
        (fill K (Val c))
        e A.

  Definition refines_senc_l_prop :=
    ∀ (lls : list loc) (msg : val) (k : val) K e E A,
    (lrel_car lrel_key) k k ∗ (lrel_car lrel_input) msg msg ∗ Pl lls ⊢
      ((∀ (c : val),
         @sym_is_cipher_l lls msg c k
      -∗ refines E
          (fill K (Val c))
          e A)
    -∗ refines E
        (fill K (senc lls k msg))
        e A).

  Hypothesis refines_senc_l : refines_senc_l_prop.
  
  Section Correctness.

    Import mathcomp.fingroup.fingroup.

    Lemma hybrid_scheme_correct :
      ⊢ refines top
          (init_scheme (λ: "scheme", (let, ("sk", "pk") := keygen #() in
          λ:"msg", dec_hyb "scheme" "sk" (enc_hyb "scheme" "pk" "msg"))))
          (λ: "msg", "msg")%V
          (lrel_input → lrel_input).
    Proof with rel_pures_l; rel_pures_r.
      rewrite /init_scheme.
      rel_apply refines_init_scheme_l.
      iIntros (lls) "HP0"...
      rewrite /keygen.
      rewrite -/N...
      rel_apply refines_randU_l.
      iIntros (sk Hskbound)...
      simpl_exp.
      set (P := (Pl lls)%I).
      rel_apply (refines_na_alloc P (nroot.@"hybrid_scheme_correct")).
      iSplitL; first (iApply P0_P_l; iFrame).
      iIntros "#Inv".
      rel_arrow_val.
      iIntros (msg1 msg2) "#Hrelmsg"...
      rewrite /enc_hyb...
      rewrite /encaps...
      rewrite /symmetric_init.get_keygen...
      rel_apply refines_keygen_l.
      iIntros (key) "#Hkrel".
      iPoseProof (lrel_keyG with "Hkrel") as "%HkGrel".
      destruct HkGrel as [kg [eq1 eq2]]; subst...
        rewrite /dec_hyb/enc...
        rel_apply refines_randU_l. iIntros (b Hbbound)...
        simpl_exp. simpl_exp.
        simpl_mult.
        rel_apply refines_na_inv; iSplitL; first iAssumption.
        iIntros "[HPl Hclose]"...
        iAssert (lrel_input msg1 msg1)%I as "Hlrel1".
        { iApply lrel_input_refl. iAssumption. }
        rewrite /symmetric_init.get_enc.
        rel_pure_l...
        rel_apply (refines_senc_l with "[HPl]");
        try iFrame; try iSplitL "Hkrel".
        iIntros (c) "Hcipher".
        simpl...
        rewrite /dec_hyb...
        rewrite /decaps...
        rewrite /dec...
        simpl_exp.
        rel_apply refines_inv_l.
        simpl_mult.
        rewrite -?expgM -ssrnat.multE -mulgA Nat.mul_comm mulgV mulg1.
        rewrite /symmetric_init.get_dec...
        rewrite /sym_is_cipher_l'.
        rel_apply "Hcipher". iIntros "HP".
        rel_apply refines_na_close. iFrame. iFrame...
        rel_vals.
    Qed.

  End Correctness.

  Variable lrel_output : lrel Σ. (* := lrel_int_bounded 0 SymOutput. *)

  Definition senc_sem_typed_prop :=
    ∀ lls rls (𝒩 : namespace) (P : iProp Σ),
    (∃ (Q : iProp Σ),
      P ⊣⊢
        (Q
      ∗ Plr lls rls)
    ) →
    na_invP 𝒩 P
     ⊢ refines top (senc lls)
      (senc rls) (lrel_key → lrel_input → lrel_output).

  Hypothesis senc_sem_typed : senc_sem_typed_prop.
  
  Lemma pk_real_real_tape :
    ⊢ refines top
        (init_scheme pk_real)
        (init_scheme pk_real_tape)
        (lrel_G * (lrel_input → () + lrel_output * (lrel_G * lrel_G))).
  Proof with (rel_pures_l; rel_pures_r).
    rewrite /init_scheme.
    rel_apply refines_init_scheme_l.
    iIntros (lls) "HP".
    rel_apply refines_init_scheme_r.
    iIntros (rls) "HP'".
    rewrite /pk_real; rewrite /pk_real_tape...
    rewrite /keygen... rewrite -/N.
    rel_alloctape_r β as "Hβ"...
    rel_apply refines_couple_UU; first done.
    iIntros (n Hnbound). iModIntro...
    simpl_exp...
    rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l.
    rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r.
    rel_apply refines_pair.
    { rel_values. }
    rewrite /encaps. rewrite /enc.
    set (P := (
        Plr lls rls
      ∗ β ↪ₛN(N;[])
      ∗ (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∨ cnt ↦ #1 ∗ cnt' ↦ₛ #1)
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"pk_real_real_tape")).
    iFrame.
    iSplitL.
    { iSplitL "HP HP'"; last (iLeft; iFrame).
      iApply (P0lr_Plr with "HP HP'").
    }
    iIntros "#Inv". rel_arrow_val.
    iIntros (msg1 msg2) "#Hrel"; subst...
    rewrite -/N. rel_apply refines_na_inv. iSplitL; first iAssumption.
    iIntros "[[H [Hβ [[Hcnt Hcnt']|[Hcnt Hcnt']]]] Hclose]".
    - rel_load_l; rel_load_r; rel_store_l; rel_store_r...
      rewrite /symmetric_init.get_keygen...
      rel_apply refines_sym_keygen_couple.
      iIntros (k) "#Hkrel"...
      iPoseProof (lrel_keyG with "Hkrel") as "%HkGrel".
      destruct HkGrel as [kg [eq1 eq2]]; subst;
      try (rel_pures_l; rel_pures_r; rel_vals)...
      rel_apply (refines_couple_UT); first done.
      iFrame. simpl; iModIntro; iIntros (b Hbbound) "Hβ"...
      rel_apply (refines_randT_r with "Hβ").
      iIntros "Hβ _"...
      simpl_exp.
      simpl_exp. rel_apply refines_mult_l...
      simpl_exp. rel_apply refines_mult_r...
      rel_apply refines_na_close; iFrame; iSplitL.
      { iFrame. iRight; replace (0+1)%Z with 1%Z by lia; iFrame. }
      rel_apply refines_injr.
      rewrite /symmetric_init.get_enc...
      rel_bind_l (senc _ _ _).
      rel_bind_r (senc _ _ _).
      rel_apply refines_bind.
      2 : {
        iIntros (v v') "#H". rel_pure_l. rel_pure_l.
        rel_pure_r. rel_pure_r. rel_apply refines_pair; rel_vals;
        rewrite /lrel_car; simpl; iExists _; done.
      }
      repeat (rel_apply refines_app);
      [|rel_vals|rel_vals].
      + rel_apply senc_sem_typed; last by iApply "Inv".
        eexists. apply bi.equiv_entails. split.
        * iIntros "[HP HQ]". iFrame.
          iApply "HQ".
        * iIntros "[HQ HP]"; iFrame.
    - rel_load_l; rel_load_r...
      rel_apply refines_na_close. iFrame; iSplitL.
      {
        iFrame; iRight; iFrame.
      }
      rel_vals.
  Qed.

  Lemma pk_real_tape_DDH_real :
    ⊢ refines top
        (init_scheme pk_real_tape)
        (init_scheme Csenc_DDH_real) 
      (lrel_G * (lrel_input → () + lrel_output * (lrel_G * lrel_G))).
  Proof with rel_pures_l; rel_pures_r.
    rewrite /init_scheme...
    rel_apply refines_init_scheme_l.
    iIntros (lls) "HP".
    rel_apply refines_init_scheme_r.
    iIntros (rls) "HP'".
    rewrite /pk_real_tape;
    rewrite /Csenc_DDH_real.
    rewrite /DDH_real. simpl.
    rewrite -/N.
    rel_alloctape_l β as "Hβ"...
    rel_apply refines_couple_UU; first done.
    iIntros (n Hnbound). iModIntro...
    rel_apply refines_couple_TU; first done. iFrame.
    iIntros (b Hbbound) "Hβ"...
    rewrite -Nat2Z.inj_mul.
    simpl_exp. simpl_exp. simpl_exp.
    rewrite /eCsenc...
    rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l.
    rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r.
    rel_apply refines_pair.
    { rel_values. }
    set (P := (
        (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∗ β ↪N(N;[b])
        ∨ cnt ↦ #1 ∗ cnt' ↦ₛ #1 ∗ β ↪N(N;[]))
        ∗ Plr lls rls
      )%I).
    rel_apply (refines_na_alloc P (nroot.@"pk_real_real_tape")).
    iSplitL.
    { iSplitR "HP HP'"; first (iLeft; iFrame).
      iApply (P0lr_Plr with "HP HP'").
    }
    iIntros "#Inv".
    rel_arrow_val. iIntros (msg1 msg2) "#Hrelmsg"...
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[[Hcnt [Hcnt' Hβ]]|[Hcnt [Hcnt' Hβ]]] Hmaps] Hclose]".
    2:{
      rel_load_l; rel_load_r... rel_apply refines_na_close.
      iFrame; iSplitL; first (iRight; iFrame). rel_vals.
    }
    rel_load_l; rel_load_r...
    rel_store_l; rel_store_r.
    replace (0+1)%Z with 1%Z by lia...
    rewrite /symmetric_init.get_keygen...
    rel_apply refines_sym_keygen_couple.
    iIntros (k) "#Hkrel"...
    iPoseProof (lrel_keyG with "Hkrel") as "%HkGrel".
    destruct HkGrel as [kg [eq1 eq2]]; subst...
    rel_apply refines_randT_l; iFrame.
    iModIntro. iIntros "Hβ _"...
    simpl_exp. simpl_exp.
    simpl_mult.
    rewrite /ssrnat.muln. rewrite /ssrnat.muln_rec.
    rewrite fingroup.expgM.
    rel_apply refines_na_close; iFrame; iSplitL; first (iRight; iFrame).
    rewrite /symmetric_init.get_enc...
    rel_bind_l (senc _ _ _).
    rel_bind_r (senc _ _ _).
    rel_apply refines_bind.
    { repeat (rel_apply refines_app); first rel_apply senc_sem_typed; try by rel_vals.
      eexists. apply bi.equiv_entails. split.
      * iIntros "[HQ HP]". iFrame.
        iApply "HQ".
      * iIntros "[HQ HP]"; iFrame.
    }
    iIntros (cdem1 cdem2) "#Hrel".
    rel_apply refines_injr.
    rel_pure_l. rel_pure_l.
    rel_pure_r. rel_pure_r.
    rel_apply (refines_pair); first (rel_vals; iAssumption).
    rel_vals; rewrite /lrel_car; simpl; iExists _; done.
  Qed.

  (* here we use the DDH assumption: we replace C[DDHreal] by C[DDHrand] *)

  Lemma Csenc_DDH_rand_pk_rand_senc_delay :
    ⊢ refines top
        (init_scheme Csenc_DDH_rand)
        (init_scheme pk_rand_senc_delay)
        (lrel_G *
        (lrel_input → () + lrel_output * (lrel_G * lrel_G))).
  Proof with rel_pures_l; rel_pures_r.
    rewrite /init_scheme...
    rel_apply refines_init_scheme_l.
    iIntros (lls) "HP".
    rel_apply refines_init_scheme_r.
    iIntros (rls) "HP'"...
    rewrite /eCsenc...
    rel_alloctape_r γ as "Hγ"...
    rewrite /SymKey. rewrite -/N.
    rel_apply refines_couple_UU; first done.
    iIntros (sk Hskbound); iModIntro...
    rel_apply refines_couple_UU; first done.
    iIntros (b Hbbound); iModIntro...
    rel_apply refines_couple_UT; first done.
    iFrame.
    iIntros (c Hcbound); simpl; iModIntro; iIntros "Hγ"...
    simpl_exp. simpl_exp. simpl_exp.
    rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l.
    rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r.
    rel_apply refines_pair; first rel_vals.
    set (P := (
      (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∗ γ↪ₛN(N;[c])
      ∨ cnt ↦ #1 ∗ cnt' ↦ₛ #1 ∗ γ↪ₛN(N;[]))
      ∗ Plr lls rls
    )%I).
    rel_apply (refines_na_alloc P
      (nroot.@"CDDHrand_pk_rand_senc_delay")).
    iSplitL.
    { iSplitR "HP HP'"; first (iLeft; iFrame).
      iApply (P0lr_Plr with "HP HP'"). }
    iIntros "#Inv".
    rel_arrow_val.
    iIntros (msg1 msg2) "#Hrelmsg"...
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[[Hcnt [Hcnt' Hγ]]|[Hcnt [Hcnt' Hγ]]] Hmaps] Hclose]";
    rel_load_l; rel_load_r...
    2:{ rel_apply refines_na_close; iFrame; iSplitL;
      first (iRight; iFrame); rel_vals. }
    rel_store_l; rel_store_r...
    rewrite /symmetric_init.get_keygen...
    rel_apply refines_sym_keygen_couple.
    iIntros (k) "#Hkrel"...
    iPoseProof (lrel_keyG with "Hkrel") as "%HkGrel".
    destruct HkGrel as [kg [eq1 eq2]]; subst...
    rel_apply (refines_randT_r with "Hγ").
    iIntros "Hγ _"...
    simpl_exp.
    simpl_mult.
    rewrite /symmetric_init.get_enc...
    rel_bind_l (senc _ _ _).
    rel_bind_r (senc _ _ _).
    rel_apply (refines_bind with "[-]").
    { 
      rel_apply refines_na_close; iFrame.
      iSplitL; first (iRight; iFrame).
      repeat (rel_apply refines_app); first rel_apply senc_sem_typed; try by rel_vals.
      eexists. apply bi.equiv_entails. split.
      * iIntros "[HQ HP]". iFrame.
        iApply "HQ".
      * iIntros "[HQ HP]"; iFrame.
    }
    iIntros (cdem1 cdem2) "#Hrel".
    rel_apply refines_injr.
    rel_pure_l. rel_pure_l.
    rel_pure_r. rel_pure_r.
    rel_apply (refines_pair with "[Hrel]"); first (rel_vals; iAssumption).
    rel_vals; rewrite /lrel_car; simpl; iExists _; done.
  Qed.

  Definition pk_rand_senc_mult_free : expr :=
    λ: "sym_scheme",
      let: "γ" := alloc #N in
      let: "sk" := rand #N in
      let: "b" := rand #N in
      let: "pk" := g^"sk" in
      let: "B" := g^"b" in
      let: "count" := ref #0 in
      let: "query" := λ: "msg",
      assert (! "count" = #0);;;
      "count" <- #1;;
      let: "k" :=
        symmetric_init.get_keygen
          symmetric_init.sym_scheme #() in
      let: "X" := g^(rand("γ") #N) in
      let: "cdem" := (symmetric_init.get_enc "sym_scheme") "k" "msg" in
      let: "ckem" := ("B", "X") in
      ("cdem", "ckem")
      in ("pk", "query").

  (* Between those two, we emphasize a major point: 
    From the very construction of the hybrid scheme,
    the initial form of the scheme enforces the order
    of operation to be as described on the left, whereas
    to extract the OTS assumption on the symemtric scheme,
    the order of operations should be as on the right.
    1. sym_keygen #()     1. sym_keygen #()
    2. aenc pk symkey     2. senc symkey msg
    3. senc symkey msg    3. aenc pk symkey
    This is the only difference between
    `pk_rand_senc_mult_free` and `pk_rand_senc_mult_free_delay`
  *)
  Definition pk_rand_senc_mult_free_delay : expr :=
    λ: "sym_scheme",
      let: "γ" := alloc #N in
      let: "sk" := rand #N in
      let: "b" := rand #N in
      let: "pk" := g^"sk" in
      let: "B" := g^"b" in
      let: "count" := ref #0 in
      let: "query" := λ: "msg",
      assert (! "count" = #0);;;
      "count" <- #1;;
      let: "X" := g^(rand("γ") #N) in
      let: "k" :=
        symmetric_init.get_keygen
          symmetric_init.sym_scheme #() in
      let: "cdem" := (symmetric_init.get_enc "sym_scheme") "k" "msg" in
      let: "ckem" := ("B", "X") in
      ("cdem", "ckem")
      in ("pk", "query").

  Definition pk_rand_srand : expr :=
    let: "sk" := rand #N in
    let: "b" := rand #N in
    let: "pk" := g^"sk" in
    let: "B" := g^"b" in
    let: "count" := ref #0 in
    let: "query" := λ: "msg",
    assert (! "count" = #0);;;
    "count" <- #1;;
    let: "X" := g^(rand #N) in
    let: "k" :=
      symmetric_init.get_keygen
        symmetric_init.sym_scheme #() in
    let: "ckem" := ("B", "X") in
    let: "cdem" :=
      symmetric_init.get_rand_cipher
        symmetric_init.sym_scheme "msg" in
    ("cdem", "ckem")
    in ("pk", "query").

  (* Here, we get rid of the multiplication by
    the public key, using a nontrivial bijection in the coupling, as in
    ElGamal_semantic *)

  Lemma pk_rand_senc_delay_pk_rand_senc_mult_free :
    ⊢ refines top 
        (init_scheme pk_rand_senc_delay)
        (init_scheme pk_rand_senc_mult_free)
        (lrel_G *
        (lrel_input → () + lrel_output * (lrel_G * lrel_G))).
  Proof with rel_pures_l; rel_pures_r.
    rewrite /init_scheme...
    rel_apply refines_init_scheme_l.
    iIntros (lls) "HP".
    rel_apply refines_init_scheme_r.
    iIntros (rls) "HP'"...
    rel_alloctape_l γ as "Hγ"...
    rel_alloctape_r γ' as "Hγ'"...
    rel_apply refines_couple_UU; first done.
    iModIntro; iIntros (sk Hskbound)...
    rel_apply refines_couple_UU; first done.
    iModIntro; iIntros (b Hbbound)...
    simpl_exp. simpl_exp.
    rel_alloc_l cnt as "Hcnt".
    rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l.
    rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r.
    rel_apply refines_pair; first rel_values.
    set (P := (
      (γ ↪N (N; []) ∗ γ' ↪ₛN (N; []) ∗ ((cnt ↦ #0 ∗ cnt' ↦ₛ #0) ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1)))
      ∗ Plr lls rls
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"pk_rand_delay_tape")).
    iSplitL.
    { iFrame; iSplitR "HP HP'"; last (iApply (P0lr_Plr with "HP HP'")).
      iLeft. iFrame. }
    iIntros "#Inv".
    rel_arrow_val.
    iIntros (msg1 msg2) "#Hmsgrel"...
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[Hγ [Hγ' [[Hcnt Hcnt']|[Hcnt Hcnt']]]] Hmaps] Hclose]"...
    - rel_load_l; rel_load_r...
      rel_store_l; rel_store_r...
      rewrite /symmetric_init.get_keygen...
      rel_apply refines_sym_keygen_couple.
      iIntros (k) "#Hkrel"...
      iPoseProof (lrel_keyG with "Hkrel") as "%HkGrel".
      destruct HkGrel as [kg [eq1 eq2]]; subst...
      (* Rewrite msg into g^k_msg for some k_msg. *)
      destruct (log_g kg) as [k_msg ->].
      (* maybe we'll need to change the ordre of argument: 
        λ x, mod_minus _ x k_msg (?) *)
      rel_apply (refines_couple_TT_frag N N (mod_minus _ k_msg)); first lia;
      first apply mod_minus_lt.
      (* rel_apply (refines_couple_TT N (mod_plus _ k_msg)); *)
      iFrame.
      iIntros (logX HlogXbound); simpl.
      assert (Hbij :
          bool_decide (∃ m : nat, (m ≤ N ∧ mod_minus (S n'') k_msg m = logX)%type)
        = true).
      {
        apply bool_decide_eq_true. About k_msg.
        exists (mod_plus _ k_msg logX); rewrite -/N.
        split.
        - apply PeanoNat.lt_n_Sm_le. apply mod_plus_lt; lia.
        - apply mod_minus_plus_cancel.
      }
      rewrite Hbij.
      iIntros (m) "[Hγ [Hγ' [%Hmodmbound %Hmbound]]]".
      apply bool_decide_eq_true in Hbij.
      rel_rand_l. iIntros "_"...
      rel_rand_r. iIntros "_"...
      simpl_exp. simpl_mult.
      (* assert (Hxbound' : bool_decide (0 ≤ x)%Z && bool_decide (x ≤ SymOutput)%Z = true).
      { rewrite andb_true_iff; split; apply bool_decide_eq_true; lia. }
      rewrite Hxbound'... *)
      rewrite /symmetric_init.get_enc...
      rel_bind_l (senc _ _ _).
      rel_bind_r (senc _ _ _).
      rel_apply (refines_bind with "[-]").
      {
        rel_apply refines_na_close; iFrame.
        iSplitL; iFrame; first (iRight; iFrame).
        repeat (rel_apply refines_app); first rel_apply senc_sem_typed; try by rel_vals.
        eexists. apply bi.equiv_entails; split.
        - iIntros "HP". iFrame.
        - iIntros "HP"; iFrame.
      }
      iIntros (v v') "Hrel"...
      rel_vals; try iAssumption; first last.
      + rewrite -fingroup.expgD -ssrnat.plusE.
        pose proof (e := eq_sym (fingroup.expg_mod_order g (k_msg + mod_minus (S n'') k_msg m))).
        rewrite g_nontriv in e.
        rewrite e.
        (* rewrite -/mod_plus.
        rewrite /mod_minus.
        rewrite -/N.
        assert (Hlogbound : m <? S N = true); first (apply Nat.ltb_lt; lia).
        rewrite Hlogbound; clear Hlogbound.
        rewrite -/N.
        rewrite /lrel_car. simpl. *)
        iExists _. iSplit; iPureIntro; try done.
        rewrite -/N.
        pose proof (mod_plus_minus_cancel N k_msg m) as Hmodeq.
        rewrite /mod_plus in Hmodeq.
        assert (ineq : mod_minus N k_msg m <? S N = true).
        {
          apply Nat.ltb_lt. apply mod_minus_lt. lia.
        }
        rewrite ineq in Hmodeq. clear ineq.
        rewrite Hmodeq. reflexivity.
      + iExists _. iSplit; iPureIntro; done.
    - rel_load_l; rel_load_r... rel_apply refines_na_close; iFrame.
      iSplitL; first (iRight; iFrame).
      rel_vals.
  Qed.
  
  Local Ltac refines_until tac :=
    repeat (rel_pure_l; rel_pure_r; try rel_apply tac).

  Lemma pk_rand_senc_mult_free_mult_free_delay :
    ⊢ refines top 
        (init_scheme pk_rand_senc_mult_free)
        (init_scheme pk_rand_senc_mult_free_delay)
        (lrel_G *
        (lrel_input → () + lrel_output * (lrel_G * lrel_G))).
  Proof with rel_pures_l; rel_pures_r.
    rewrite /pk_rand_senc_mult_free/pk_rand_senc_mult_free_delay...
    rewrite /init_scheme...
    rel_apply refines_init_scheme_l.
    iIntros (lls) "HP".
    rel_apply refines_init_scheme_r.
    iIntros (rls) "HP'"...
    rel_alloctape_l γ as "Hγ".
    rel_alloctape_r γ' as "Hγ'"...
    rel_apply refines_couple_UU; first done.
    iIntros (sk Hskbound); iModIntro...
    rel_apply refines_couple_UU; first done.
    iIntros (b Hbbound); iModIntro...
    simpl_exp; simpl_exp.
    rel_alloc_l cnt as "Hcnt";
    rel_alloc_r cnt' as "Hcnt'".
    refines_until (refines_pair); first rel_vals.
    set (P := (
        ((cnt ↦ #0 ∗ cnt' ↦ₛ #0)
      ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))
      ∗ Plr lls rls
      ∗ γ↪N(N;[]) ∗ γ'↪ₛN(N;[])
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"mult_free_mult_free_delay")).
    iFrame.
    iSplitL.
    {
      iSplitL "Hcnt Hcnt'"; first iLeft; iFrame.
      iApply (P0lr_Plr with "HP HP'").
    }
    iIntros "#Inv".
    rel_arrow_val.
    iIntros (msg1 msg2) "#Hmsgrel"...
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[[Hcnt Hcnt']|[Hcnt Hcnt']] [HP [Hγ Hγ']]] Hclose]";
      rel_load_l; rel_load_r...
    - rel_store_l; rel_store_r...
      rel_apply refines_couple_TT; iFrame.
      iIntros (c) "[Hγ [Hγ' %Hcbound]]".
      simpl.
      rel_apply (refines_randT_r with "Hγ'").
      iIntros "Hγ' _".
      simpl_exp.
      rewrite /symmetric_init.get_keygen...
      rel_apply refines_sym_keygen_couple.
      iIntros (k) "#Hrelkey"...
      rel_apply refines_randT_l; iFrame.
      iModIntro; iIntros "Hγ _". simpl_exp.
      rewrite /symmetric_init.get_enc...
      rel_bind_l (senc _ _ _).
      rel_bind_r (senc _ _ _).
      rel_apply (refines_bind with "[-]").
      2 : {
        iIntros (v v') "#H". refines_until refines_pair; rel_vals;
        rewrite /lrel_car; simpl; try iExists _; done.
      }
      rel_apply refines_na_close; iFrame.
      iSplitL.
      {
        iFrame. iRight; iFrame.
      }
      repeat rel_apply refines_app; first rel_apply senc_sem_typed;
      try rel_vals; try done.
      eexists. apply bi.equiv_entails. split; first last.
      + iIntros "[HQ HP]". rewrite /P; iFrame. done.
      + iIntros "[Hcnts [HP [Hγ Hγ']]]". iFrame.
    - rel_apply refines_na_close; iFrame; iFrame.
      iSplitL; first (iRight; iFrame).
      rel_vals.
  Qed.
      
  (* from this point on, we need to consider
    an adversary returning a boolean, for
    compatibility with the CPA assumption on
    the symmetric scheme *)

  Definition adv_rand : val :=
    λ: "oracle",
      let: "sk" := rand #N in
      let: "b" := rand #N in
      let: "pk" := g^"sk" in
      let: "B" := g^"b" in
      let: "count" := ref #0 in
      let: "query" := λ: "msg",
        assert (! "count" = #0);;;
        "count" <- #1;;
        let: "X" := g^(rand #N) in
        let: "ckem" := ("B", "X") in
        let:m "cdem" := "oracle" "msg" in
        ("cdem", "ckem")
      in ("pk", "query").

(* Definition sym_OTS_real : val :=
  λ:"msg",
    (* TODO should be using sym.keygen instead of sampling "by hand". *)
    (* let: "key" := sym.keygen #() in *)
    let: "key" := KEM.rnd Sym_SecretKey #() in
    sym.enc "key" "msg".

Definition sym_OTS_rand : val :=
  λ:"msg",
    (* let: "key" := sym.keygen #() in *)
    sym.rand_cipher #(). *)

  (* One Time Secrecy assumption on symmetric encryption scheme
    tweaked version of `CPA _ _ _ #1`, the only difference is
    the place where we generate the key. *)
  (* TODO move glue code in SYM scheme,
    still vg_of_int here and there *)
  Definition OTS : val :=
      λ:"b" "adv" "scheme",
        let: "enc_scheme" := symmetric_init.get_enc_scheme "scheme" #() in
        let: "oracle" :=
          let: "counter" := ref #0 in
          λ: "msg",
            if: ! "counter" = #0 then
              "counter" <- #1;;
              let: "k" := (symmetric_init.get_keygen "scheme" #()) in
                InjR (
                  (if: "b" then
                    symmetric_init.get_enc "enc_scheme" "k"
                  else
                    symmetric_init.get_rand_cipher "scheme") "msg")
            else
              InjLV #()
        in
        let: "b'" := "adv" "oracle" in
        "b'".

  Lemma pk_rand_senc_mult_free_adv_sym_OTS (adv : val) :
    refines top
      adv
      adv
      ((lrel_G * (lrel_input → () + lrel_output * (lrel_G * lrel_G))) → lrel_bool)
    ⊢ refines top
        (adv (init_scheme pk_rand_senc_mult_free_delay))
        (OTS #true (λ: "oracle", adv (adv_rand "oracle"))%V
          symmetric_init.sym_scheme)
        lrel_bool.
  Proof with rel_pures_l; rel_pures_r.
    iIntros "Hadvtyped".
    rewrite /symmetric_init.sym_scheme/OTS...
    rewrite /init_scheme...
    rel_apply refines_init_scheme_l.
    iIntros (lls) "HP".
    rel_apply refines_init_scheme_r.
    iIntros (rls) "HP'"; rel_pures_r...
    rel_alloc_r cnt2 as "Hcnt2"...
    rel_bind_l (adv _).
    rel_bind_r (adv _).
    rel_apply (refines_bind with "[-]").
    2 : { iIntros (v v') "Hrel"... rel_vals. }
    rel_apply (refines_app with "[Hadvtyped]")...
    { iAssumption. }
    rewrite /adv_rand; rel_pures_r.
    rel_alloctape_l γ as "Hγ"...
    rel_apply refines_couple_UU; first done.
    iIntros (sk Hskbound). iModIntro...
    rel_apply refines_couple_UU; first done.
    iIntros (b Hbbound). iModIntro...
    simpl_exp. simpl_exp.
    rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
    refines_until refines_pair;
      first (rel_vals; iApply τG_subtype; iExists _; done).
    set (P := (
        ((cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∗ cnt2 ↦ₛ #0)
      ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1 ∗ cnt2 ↦ₛ #1))
      ∗ Plr lls rls
      ∗ γ ↪N (N; [])
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"prf_rand_adv_cpa")).
    iSplitL.
    { iSplitR "HP HP' Hγ"; first (iFrame; iLeft; iFrame);
      iFrame; iApply (P0lr_Plr with "HP HP'"). }
    iIntros "#Inv".
    rel_arrow_val.
    iIntros (msg1 msg2) "#Hmsgrel"...
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[[Hcnt [Hcnt' Hcnt2]]|[Hcnt [Hcnt' Hcnt2]]] [HP Hγ]] Hclose]".
    2 : {
      rel_load_l; rel_load_r... rel_apply refines_na_close; iFrame; iSplitL.
      + iRight. iFrame.
      + rel_vals.
    }
    rel_load_l; rel_load_r...
    rel_store_l; rel_store_r...
    rel_apply refines_couple_TU; first done; iFrame.
    iIntros (logX HlogXbound) "Hγ".
    rel_apply refines_randT_l; iFrame; iModIntro;
    iIntros "Hγ _"; simpl_exp...
    rel_load_r... rel_store_r...
    rewrite /symmetric_init.get_enc...
    rewrite /symmetric_init.get_keygen...
    rel_apply refines_sym_keygen_couple.
    iIntros (k) "#Hkrel"...
    iPoseProof (lrel_keyG with "Hkrel") as "%HkGrel".
    destruct HkGrel as [kg [eq1 eq2]]; subst...
    (* here we can evaluate aenc delayed between LHS/RHS
      won't be possible anymore with an arbitrary asym scheme
      with minimal assumptions (e.g. semantic typing) *)

    rel_apply refines_na_close; iFrame; iFrame.
    iSplitL; first (iRight; iFrame).
    rel_bind_l (senc _ _ _).
    rel_bind_r (senc _ _ _).
    rel_apply refines_bind.
    {
      repeat (rel_apply refines_app); first
        (rel_apply senc_sem_typed; last by iAssumption);
          try rel_vals.
        eexists. apply bi.equiv_entails. split; first last.
        + iIntros "[HQ HP]". rewrite /P; iFrame. done.
        + iIntros "[Hcnts [HP Hγ]]". iFrame. 
    }
    iIntros (scipher1 scipher2) "#Hcipherrel".
    refines_until (refines_injr)...
    rel_vals; first iAssumption; iExists _;
      iPureIntro; split; done.
  Qed.

  Definition rand_cipher_sem_typed_prop :=
    ⊢ refines top symmetric_init.rand_cipher symmetric_init.rand_cipher (lrel_input → lrel_output).
  Hypothesis rand_cipher_sem_typed : rand_cipher_sem_typed_prop.

  Lemma OTS_pk_rand_srand (adv : val) : 
    refines top
      adv
      adv
      ((lrel_G * (lrel_input → () + lrel_output * (lrel_G * lrel_G))) → lrel_bool)
    ⊢ refines top
        (OTS #false (λ: "oracle", adv (adv_rand "oracle"))%V
          symmetric_init.sym_scheme)
        (adv pk_rand_srand)
        lrel_bool.
  Proof with rel_pures_l; rel_pures_r. iIntros "Hadvtyped".
    rewrite /OTS...
    rel_apply refines_init_scheme_l.
    iIntros (lls) "HP"...
    rel_alloc_l cnt2 as "Hcnt2"...
    rewrite /adv_rand...
    rel_bind_l (adv _); rel_bind_r (adv _).
    rel_apply (refines_bind with "[-]").
    2:{ iIntros (v v') "Hrel"... rel_vals. }
    rel_apply (refines_app with "Hadvtyped").
    rewrite /pk_rand_srand.
    rel_apply refines_couple_UU; first done.
    iIntros (sk Hskbound). iModIntro...
    rel_apply refines_couple_UU; first done.
    iIntros (b Hbbound). iModIntro...
    simpl_exp. simpl_exp.
    rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
    refines_until refines_pair; first rel_vals.
    set (P := (
        (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∗ cnt2 ↦ #0)
      ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1 ∗ cnt2 ↦ #1)
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"prf_rand_adv_cpa")).
    iSplitL; first (iLeft; iFrame).
    iIntros "#Inv".
    rel_arrow_val.
    iIntros (msg1 msg2) "#Hrelmsg"...
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[Hcnt [Hcnt' Hcnt2]]|[Hcnt [Hcnt' Hcnt2]]] Hclose]".
    2 : {
      rel_load_l; rel_load_r... rel_apply refines_na_close; iFrame; iSplitL.
      + iRight. iFrame.
      + rel_vals.
    }
    rel_load_l; rel_load_r...
    rel_store_l; rel_store_r...
    rel_apply refines_couple_UU; first done.
    iIntros (logX HlogXbound). iModIntro...
    simpl_exp.
    rel_load_l... rel_store_l...
    rewrite /symmetric_init.get_rand_cipher/symmetric_init.get_card_message
      /symmetric_init.get_keygen/symmetric_init.sym_scheme...
      rel_apply refines_sym_keygen_couple.
    iIntros (k) "#Hkrel"...
    rel_apply refines_na_close; iFrame.
    iSplitL; first (iRight; iFrame).
    rel_bind_l (symmetric_init.rand_cipher _).
    rel_bind_r (symmetric_init.rand_cipher _).
    rel_apply refines_bind.
    { rel_apply refines_app; first rel_apply rand_cipher_sem_typed; rel_vals. }
    iIntros (r1 r2) "Hrrel"...
    rel_vals; first iAssumption;
    iExists _; iPureIntro; split; done.
  Qed.

  Definition pk_rand_tape : expr :=
    let: "β" := alloc #N in
    let: "sk" := rand #N in
    let: "pk" := g^"sk" in
    let: "count" := ref #0 in
    let: "query" := λ: "msg",
      assert (! "count" = #0);;;
      "count" <- #1;;
      let: "k" :=
        symmetric_init.get_keygen symmetric_init.sym_scheme #() in
      let: "b" := rand("β") #N in
      let: "B" := g^"b" in
      let: "X" := g^(rand("β") #N) in
      let: "ckem" := ("B", "X") in
      let: "cdem" :=
        symmetric_init.get_rand_cipher
          symmetric_init.sym_scheme "msg" in
      ("cdem", "ckem")
    in ("pk", "query").

  Lemma pk_rand_srand_rand_tape (adv : val) :
    refines top
      adv
      adv
      ((lrel_G * (lrel_input → () + lrel_output * (lrel_G * lrel_G))) → lrel_bool)
    ⊢ refines top
        (adv pk_rand_srand)
        (adv pk_rand_tape)
        lrel_bool.
  Proof with rel_pures_l; rel_pures_r.
    iIntros "Hadvtyped".
    rel_apply (refines_app with "Hadvtyped").
    rewrite /pk_rand_srand.
    rewrite /pk_rand_tape.
    rel_alloctape_r β as "Hβ"...
    rel_apply refines_couple_UU; first done.
    iIntros (sk Hskbound); iModIntro...
    rel_apply refines_couple_UT; first done.
    iFrame. iModIntro.
    iIntros (b Hbbound) "Hβ"...
    simpl_exp. simpl_exp.
    rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l; rel_pure_l; rel_pure_l; rel_pure_l; rel_pure_l.
    rel_pure_r; rel_pure_r; rel_pure_r; rel_pure_r; rel_pure_r.
    rel_apply refines_pair; first rel_vals. simpl.
    set (P := (
        cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∗ β↪ₛN(N;[b])
      ∨ cnt ↦ #1 ∗ cnt' ↦ₛ #1 ∗ β↪ₛN(N;[])
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"pk_rand_srand_rand_tape")).
    iSplitL; first (iLeft; iFrame).
    iIntros "#Inv".
    rel_arrow_val.
    iIntros (msg1 msg2) "#Hrelmsg"...
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[Hcnt [Hcnt' Hβ]]|[Hcnt [Hcnt' Hβ]]] Hclose]";
    rel_load_l; rel_load_r...
    2:{ rel_apply refines_na_close; iFrame. iSplitL; first (iRight; iFrame); rel_vals. }
    rel_store_l; rel_store_r...
    rel_apply refines_couple_UT; first done.
    iFrame. iModIntro.
    iIntros (c Hcbound) "Hβ"...
    simpl_exp.
    rewrite /symmetric_init.get_keygen...
    rel_apply refines_sym_keygen_couple.
    iIntros (k) "Hkrel"...
    rel_apply (refines_randT_r with "Hβ").
    iIntros "Hβ _"...
    simpl_exp.
    rel_apply (refines_randT_r with "Hβ").
    iIntros "Hβ _"...
    simpl_exp.
    rewrite /symmetric_init.get_rand_cipher...
    rel_apply refines_na_close; iFrame.
    iSplitL.
    { iRight; iFrame. }
    rel_bind_l (symmetric_init.rand_cipher _);
    rel_bind_r (symmetric_init.rand_cipher _).
    rel_apply refines_bind.
    {
      rel_apply refines_app; last by rel_vals.
      rel_apply rand_cipher_sem_typed.
    }
    iIntros (r1 r2) "#Hrrel"...
    rel_vals; first iAssumption;
    iExists _; iPureIntro; split; done.
  Qed.

  Lemma pk_rand_tape_pk_rand (adv : val) :
    refines top
      adv
      adv
      ((lrel_G * (lrel_input → () + lrel_output * (lrel_G * lrel_G))) → lrel_bool)
    ⊢ refines top
        (adv pk_rand_tape)
        (adv pk_rand)
        lrel_bool.
  Proof with rel_pures_l; rel_pures_r.
    iIntros "Hadvtyped".
    rel_apply (refines_app with "Hadvtyped").
    rewrite /pk_rand_tape. rewrite /pk_rand.
    rewrite /keygen...
    rewrite -/N.
    rel_alloctape_l β as "Hβ"...
    rel_apply refines_couple_UU; first done.
    iIntros (sk Hskbound); iModIntro...
    simpl_exp.
    rel_alloc_l cnt as "Hcnt".
    rel_alloc_r cnt' as "Hcnt'".
    rel_pure_l; rel_pure_l; rel_pure_l; rel_pure_l; rel_pure_l.
    rel_pure_r; rel_pure_r; rel_pure_r; rel_pure_r; rel_pure_r.
    rel_apply refines_pair; first (rel_vals; iExists _; done).
    set (P := (
      (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∨ cnt ↦ #1 ∗ cnt' ↦ₛ #1) ∗ β↪N(N;[])
    )%I).
    rel_apply (refines_na_alloc P (nroot.@"pk_rand_tape_pk_rand")).
    iSplitL; first (iFrame; iLeft; iFrame).
    iIntros "#Inv".
    rel_arrow_val.
    iIntros (msg1 msg2) "#Hrelmsg"; subst...
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[[[[Hcnt Hcnt']|[Hcnt Hcnt']] Hβ] Hclose]";rel_load_l; rel_load_r...
    2 : {
      rel_apply refines_na_close; iFrame; iSplitL.
      + iRight. iFrame.
      + rel_vals.
    }
    rel_store_l; rel_store_r...
    rewrite /symmetric_init.get_keygen...
    rel_apply refines_sym_keygen_couple.
    iIntros (k) "#Hkrel"...
    rel_apply refines_couple_TU; first done; iFrame.
    iIntros (b Hbbound) "Hβ"; simpl.
    rel_apply refines_randT_l; iFrame.
    iModIntro. iIntros "Hβ _"...
    simpl_exp.
    rel_apply refines_couple_TU; first done; iFrame.
    iIntros (c Hcbound) "Hβ"; simpl.
    rel_apply refines_randT_l; iFrame.
    iModIntro. iIntros "Hβ _"...
    simpl_exp. simpl_exp.
    rel_apply refines_na_close; iFrame; iSplitL.
    { replace (0+1)%Z with 1%Z by lia. iFrame; iRight; iFrame. }
    rewrite /symmetric_init.get_rand_cipher...
    rel_bind_l (symmetric_init.rand_cipher _);
    rel_bind_r (symmetric_init.rand_cipher _).
    rel_apply refines_bind.
    {
      rel_apply refines_app; last by rel_vals.
      rel_apply rand_cipher_sem_typed.
    }
    iIntros (r1 r2) "#Hrrel"...
    rel_vals; first iAssumption; iExists _; done.
  Qed.

End logrel.

End Hybrid_scheme.