From Ltac2 Require Import Ltac2.
Set Default Proof Mode "Classic".
From clutch.prob_lang Require Import advantage typing.tychk.
From clutch.approxis Require Import map reltac2 approxis option.
From clutch.clutch.examples.crypto Require ElGamal_bijection.
From clutch.approxis.examples Require Import
  valgroup diffie_hellman prf_local_state prf_cpa_with_dec security_aux option xor
  ElGamal_defs bounded_oracle pubkey advantage_laws.
From mathcomp Require Import ssrbool.
From mathcomp Require fingroup.fingroup.
Set Default Proof Using "All".
Import ElGamal_bijection.bij_nat.
Import valgroup_notation.
Import fingroup.Notations.
Import map.

Section Hybrid_scheme.

Context {vg : val_group}.           (* A group on a subset of values. *)
Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
Context {vgg : @val_group_generator vg}.   (* G is generated by g. *)
Context {cgg : @clutch_group_generator vg cg vgg}. (* g is well-typed *)

Let N := S n''.
Let SymKey := N.
Let Input := N.
Let SymOutput := N.
Variable xor_struct : XOR (Key := SymOutput) (Support := SymOutput).

#[local] Instance dummy_prf_params : PRF_localstate_params := {
    card_key := SymKey;
    card_input := SymOutput;
    card_output := SymOutput;
  }.

Definition keygen_kem : val := keygen.

Definition pair_int_of_vg : val :=
  λ: "p", (int_of_vg (Fst "p"), int_of_vg (Snd "p")).

Definition pair_vg_of_int : val :=
  λ: "p", (vg_of_int (Fst "p"), vg_of_int (Snd "p")).

Definition encaps : val :=
  λ: "pk",
    let: "k" := rand #SymKey in
    let:m "kg" := vg_of_int "k" in
    let: "c_kem" := enc "pk" "kg" in
    SOME ("c_kem", "k").

Definition decaps : val :=
  λ: "sk" "c",
    int_of_vg (dec "sk" "c").

Definition enc_hyb : val :=
  λ: "sym_scheme" "pk" "msg",
    match: encaps "pk" with
      | NONE => NONE
      | SOME "caps" =>
      let: "c_kem" := Fst "caps" in
      let: "k" := Snd "caps" in
      let: "c_dem" := (Fst "sym_scheme") "k" "msg" in
      SOME ("c_dem", "c_kem")
    end.

Definition dec_hyb : val :=
  λ: "sym_scheme" "sk" "msg",
    let:m "msg'" := "msg" in
    let: "c_dem" := Fst "msg'" in
    let: "c_kem" := Snd "msg'" in
    let: "k" := decaps "sk" "c_kem" in
    SOME ((Snd "sym_scheme") "k" "c_dem").

Definition pk_rand : expr :=
  let, ("sk", "pk") := keygen #() in
  let: "count" := ref #0 in
  let: "query" := λ: "msg",
    let: "k" := rand #SymKey in
    let:m "kg" := vg_of_int "k" in
    assert (!"count" = #0);;;
    "count" <- !"count"+#1;;
    let: "b" := rand #N in
    let: "x" := rand #N in
    let: "c_kem" := (g^"b", g^"x") in
    let: "c_dem" := (let: "i" := rand #Input in
      let: "o" := rand #SymOutput in
      ("i", "o")) in
    SOME ("c_dem", "c_kem")
  in
  ("pk", "query").

Definition pk_real : expr :=
  λ: "sym_scheme",
    let, ("sk", "pk") := keygen #() in
    let: "count" := ref #0 in
    let: "query" := λ: "msg",
      let:m "caps" := encaps "pk" in
      assert (!"count" = #0);;;
      "count" <- !"count"+#1;;
      let: "c_kem" := Fst "caps" in
      let: "k" := Snd "caps" in
      let: "c_dem" := (Fst "sym_scheme") "k" "msg" in
      SOME ("c_dem", "c_kem")
    in
    ("pk", "query").

Definition pk_real_tape : expr :=
  λ: "sym_scheme",
    let: "β" := alloc #N in
    let: "sk" := rand #N in
    let: "pk" := g^"sk" in
    let: "count" := ref #0 in
    let: "query" := λ:"msg",
      let: "k" := rand #N in
      let:m "kg" := vg_of_int "k" in
      let: "b" := rand("β") #N in
      let: "B" := g^"b" in
      assert (!"count" = #0);;;
      "count" <- !"count"+#1;;
      let: "C" := "pk"^"b" in
      let: "X" := "kg" · "C" in
      let: "c_kem" := ("B", "X") in
      let: "c_dem" := (Fst "sym_scheme") "k" "msg" in
      SOME ("c_dem", "c_kem")
      in
    ("pk", "query").

Definition eCsenc : val :=
  (λ: "DDH_real_or_rand",
    λ: "sym_scheme",
      let, ("pk", "B", "C") := "DDH_real_or_rand" in
      let: "count" := ref #0 in
      let: "query" := λ: "msg",
        let: "k" := rand #N in
        let:m "kg" := vg_of_int "k" in
        assert (!"count" = #0) ;;;
        "count" <- #1 ;;
        let: "X" := "kg" · "C" in
        let: "c_kem" := ("B", "X") in
        let: "c_dem" := (Fst "sym_scheme") "k" "msg" in
        SOME ("c_dem", "c_kem")
      in ("pk", "query")).

Definition pk_rand_senc_delay : expr :=
  λ: "sym_scheme",
    let: "γ" := alloc #N in
    let: "sk" := rand #SymKey in
    let: "b" := rand #N in
    let: "pk" := g^"sk" in
    let: "B" := g^"b" in
    let: "count" := ref #0 in
    let: "query" := λ: "msg",
      let: "k" := rand #N in
      let:m "kg" := vg_of_int "k" in
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      let: "c" := rand("γ") #N in
      let: "C" := g^"c" in
      let: "X" := "kg" · "C" in
      let: "c_kem" := ("B", "X") in
      let: "c_dem" := (Fst "sym_scheme") "k" "msg" in
      SOME ("c_dem", "c_kem")
    in ("pk", "query").

Definition Csenc : list ectx_item := [AppRCtx eCsenc].
Definition Csenc_DDH_real : expr := fill Csenc DDH_real.
Definition Csenc_DDH_rand : expr := fill Csenc DDH_rand.

Section logrel.
  Section types.

    Definition TInput := TInt.
    Definition TCipher := TInt.
    Definition TOracle := (TInput → TOption (TOption ((TInt * TInt) * (τG * τG))))%ty.

  End types.

  Context `{!approxisRGS Σ}.
  Context {G : clutch_group (vg:=vg) (cg:=cg)}.
  Context {Δ : listO (lrelC Σ)}.
    Variable xor_spec : XOR_spec.

  Lemma prf_enc_sem_typed : ⊢
    REL (prf_enc SymOutput SymOutput xor_struct) <<
      (prf_enc SymOutput SymOutput xor_struct) :
        (lrel_int → lrel_input → lrel_output) →
        lrel_int → lrel_input → lrel_int * lrel_int.
  Proof with rel_pures_l; rel_pures_r.
    rewrite /prf_enc... rel_arrow_val.
    iIntros (prf1 prf2) "#H"...
    rel_arrow_val.
    iIntros (v1 v2 [x [eq1 eq2]]); subst...
    rel_bind_l (prf1 _); rel_bind_r (prf2 _).
    rel_apply (refines_bind _ _ _ (lrel_input → lrel_output)).
    { rel_apply "H". rewrite /lrel_car. simpl. iExists _. done. }
    clear x; iIntros (prfkeyed1 prfkeyed2) "#H'"...
    rel_arrow_val.
    iIntros (v1 v2 [msg [eq1 [eq2 ineqmsg]]]); subst...
    rel_apply refines_couple_UU; first done.
    iIntros (n Hbound). iModIntro...
    rel_bind_l (prfkeyed1 _); rel_bind_r (prfkeyed2 _).
    rel_apply refines_bind.
    - rel_apply "H'". iPureIntro.
      exists n. repeat split; try done; try (rewrite /card_input; rewrite /dummy_prf_params); try lia.
    - iIntros (v v' [x [eq1 [eq2 ineq]]]); subst...
      rel_apply refines_pair; first rel_values.
      rewrite /card_input in ineqmsg. simpl in ineqmsg.
      rewrite /card_output in ineq. simpl in ineq.
      replace x with (Z.of_nat (Z.to_nat x)) by lia.
      rel_apply_l (xor_correct_l ⊤ []); try lia.
      rel_apply_r (xor_correct_r ⊤ []); try lia.
      rel_values.
  Qed.
      
  Lemma rf_enc_sem_typed lm lm' M :
      map_list lm M ∗ map_slist lm' M
    ∗ ⌜ ∀ y, y ∈ @map_img nat val (gmap nat val) _ (gset val) _ _ _ M
        → ∃ k : nat, y = #k ∧ k <= card_output ⌝
    ∗ ⌜ ∀ x, x ∈ elements (dom M) -> (x < S card_input)%nat ⌝ ⊢
    REL (rf_enc SymOutput SymOutput xor_struct) #lm <<
      (rf_enc SymOutput SymOutput xor_struct) #lm' :
        lrel_int → lrel_input → lrel_int * lrel_int.
  Proof with rel_pures_l; rel_pures_r.
    iIntros "[Hmap [Hmap' [%Himg %Hdom]]]".
    rewrite /rf_enc...
    set (P := ( ∃ (M : gmap nat val),
                    map_list  lm  M
                  ∗ map_slist lm' M
                  ∗ ⌜ ∀ y, y ∈ @map_img nat val (gmap nat val) _ (gset val) _ _ _ M
                           → ∃ k : nat, y = #k ∧ k <= card_output ⌝
                  ∗ ⌜ ∀ x, x ∈ elements (dom M) -> (x < S card_input)%nat ⌝
              )%I).
    rel_apply (refines_na_alloc P
      (nroot.@"RED") with "[Hmap Hmap']") ; iFrame.
    iSplitL. { iPureIntro. split; assumption. }
    iIntros "#Hinv".
    rel_arrow_val.
    iIntros (v1 v2 [x [eq1 eq2]]); subst...
    repeat rel_apply refines_app.
    - rel_apply prf_enc_sem_typed.
    - rel_arrow_val. clear x. lrintro "tmp"...
      rel_apply random_function_sem_typed_inv; last iAssumption.
      exists True%I. rewrite /P.
      apply bi.equiv_entails; split;
      [iIntros "HP"; iSplitR; first done | iIntros "[_ HP]"];
      iAssumption.
    - rel_vals.
Qed.

Ltac simpl_exp := try (rel_apply refines_exp_l; rel_pures_l);
  try (rel_apply refines_exp_r; rel_pures_r).
Ltac simpl_mult := try (rel_apply refines_mult_l; rel_pures_l);
  try (rel_apply refines_mult_r; rel_pures_r).
Ltac rel_bind x := rel_bind_l x; rel_bind_r x.

Definition init_scheme (e : expr) : expr :=
  let: "scheme" := (rf_scheme Input SymOutput xor_struct) in
  e "scheme".

Ltac rel_init_scheme l1 s1 l2 s2 := 
  rewrite /init_scheme;
  rel_apply refines_rf_scheme_l;
  iIntros (l1) s1;
  rel_apply refines_rf_scheme_r;
  iIntros (l2) s2;
  rewrite /rf_enc;
  rewrite /rf_dec.

Ltac rel_init_scheme_l l1 s1 := 
  rewrite /init_scheme;
  rel_apply refines_rf_scheme_l;
  iIntros (l1) s1;
  rewrite /rf_enc;
  rewrite /rf_dec.

Ltac rel_init_scheme_r l2 s2 := 
  rewrite /init_scheme;
  rel_apply refines_rf_scheme_r;
  iIntros (l2) s2;
  rewrite /rf_enc;
  rewrite /rf_dec.

(* cannot write the symmetric decryption: the random function used initializes a
  map that has to stay local to the scheme, otherwise it would compromise its
  security. However, the decryption also needs access to this map.
  Several ways it could work:
  - *)

Import mathcomp.fingroup.fingroup.

Lemma hybrid_scheme_correct :
  ⊢ refines top
      (init_scheme (λ: "scheme", (let, ("sk", "pk") := keygen #() in
       λ:"msg", dec_hyb "scheme" "sk" (enc_hyb "scheme" "pk" "msg"))))
      (λ: "msg", let:m "kg" := vg_of_int (rand #N) in SOME "msg")%V
      (lrel_input → () + lrel_input).
Proof with rel_pures_l; rel_pures_r.
  rewrite /keygen.
  rewrite -/N.
  rel_init_scheme_l mapref "Hmap"...
  rel_apply refines_randU_l.
  iIntros (sk Hskbound)...
  simpl_exp.
  set (P := (∃ (M : gmap nat val),
      map_list  mapref  M
    ∗ ⌜ ∀ y, y ∈ @map_img nat val (gmap nat val) _ (gset val) _ _ _ M
      → ∃ k : nat, y = #k ∧ k <= card_output ⌝
    ∗ ⌜ ∀ x, x ∈ elements (dom M) -> (x < S card_input)%nat ⌝
  )%I).
  rel_apply (refines_na_alloc P (nroot.@"hybrid_scheme_correct")).
  iSplitL; iFrame.
  { iPureIntro; split.
    - intros y Hy. rewrite map_img_empty in Hy.
      rewrite elem_of_empty in Hy. exfalso; apply Hy.
    - intros y Hy. rewrite elements_empty in Hy.
      rewrite elem_of_nil in Hy. exfalso; apply Hy.
  }
  iIntros "#Inv".
  rel_arrow_val.
  iIntros (v1 v2 [msg [eq1 [eq2 Hmsgbound]]]); subst...
  rewrite /enc_hyb...
  rewrite /encaps...
  rewrite /SymKey.
  rel_apply refines_couple_UU; first done.
  iIntros (k Hkbound); iModIntro...
  rel_bind (vg_of_int #k).
  rel_apply refines_bind.
  { rel_apply refines_app.
    - rel_vals. iApply vg_of_int_lrel_G.
    - rel_vals. }
  iIntros (kg1 kg2 [tmp [tmp' [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]); subst...
  - rewrite /dec_hyb... rel_vals.
  - rewrite /enc... rel_apply refines_randU_l. iIntros (b Hbbound)...
    simpl_exp. simpl_exp. simpl_mult.
    rewrite /prf_enc... rewrite /random_function...
    rewrite -/random_function.
    rel_apply refines_randU_l.
    iIntros (r Hrbound)...
    rel_apply refines_na_inv; iSplitL; first iAssumption.
    iIntros "[>[%M [Hmap [%Himg %Hdom]]] Hclose]".
    rel_apply (refines_get_l with "[-Hmap]"); last by iAssumption.
    iIntros (res) "Hmap %eqres"; subst.
    rewrite /card_input in Hmsgbound. simpl in Hmsgbound.
    assert (Hintofvgofint :
      ∀ E K e A, refines E (fill K ((λ: "x", "x") #k)) e A ⊢ refines E (fill K (int_of_vg kg)) e A).
    { admit. } (* here, we lack lemmas stating
    1. that `vg_of_int` can be postponed (i.e. is deterministic)
    2. that `int_of_vf vg_of_int = id` *)
    destruct (M !! r) as [y|] eqn:eqlookup; simpl...
    + eapply elem_of_map_img_2 in eqlookup as Hyimg.
      apply Himg in Hyimg. destruct Hyimg as [yn [eqyn Hynbound]]; subst.
      rewrite /card_output in Hynbound. simpl in Hynbound.
      rel_apply xor_correct_l; try lia...
      rewrite /dec_hyb...
      rewrite /decaps...
      rewrite /dec...
      simpl_exp.
      rel_apply refines_inv_l.
      simpl_mult.
      rewrite -?expgM -ssrnat.multE -mulgA Nat.mul_comm mulgV mulg1.
      rel_bind_l (int_of_vg _).
      rel_apply Hintofvgofint...
      rewrite /prf_dec...
      rewrite /random_function...
      rel_apply (refines_get_l with "[-Hmap]"); last by iAssumption.
      iIntros (res') "Hmap %eqres'"; subst. rewrite eqlookup.
      simpl...
      rel_apply xor_correct_l; try lia.
      { rewrite Nat2Z.id. apply xor_dom; lia. }
      rewrite Nat2Z.id.
      rewrite (xor_sem_inverse_r _ Input SymOutput xor_struct).
      2 : { exact 0. }
      rewrite Z2Nat.id; last lia.
      rel_apply refines_na_close; iFrame.
      iSplitL...
      { iFrame. iPureIntro; split; assumption. }
      rel_vals.
    + rel_apply refines_randU_l. iIntros (y Hybound)...
      rel_apply (refines_set_l with "[-Hmap]"); last by iAssumption.
      iIntros "Hmap"...
      rel_apply xor_correct_l; try lia...
      rewrite /dec_hyb...
      rewrite /decaps...
      rewrite /dec...
      simpl_exp.
      rel_apply refines_inv_l.
      simpl_mult.
      rewrite -?expgM -ssrnat.multE -mulgA Nat.mul_comm mulgV mulg1.
      rel_bind_l (int_of_vg _).
      rel_apply Hintofvgofint...
      rewrite /prf_dec...
      rewrite /random_function...
      rel_apply (refines_get_l with "[-Hmap]"); last by iAssumption.
      iIntros (res') "Hmap %eqres'"; subst.
      rewrite lookup_insert; simpl...
      rel_apply xor_correct_l; try lia.
      { rewrite Nat2Z.id. apply xor_dom; lia. }
      rewrite Nat2Z.id.
      rewrite (xor_sem_inverse_r _ Input SymOutput xor_struct).
      2 : { exact 0. }
      rewrite Z2Nat.id; last lia.
      rel_apply refines_na_close; iFrame.
      iSplitL...
      {
        iFrame. iPureIntro; split.
        - intros x Hx. rewrite map_img_insert in Hx.
          rewrite elem_of_union in Hx.
          destruct Hx as [Hx | Hx].
          + rewrite elem_of_singleton in Hx; subst.
            exists y; split; done.
          + apply Himg. eapply map_img_delete_subseteq. apply Hx.
        - intros x Hx. rewrite dom_insert in Hx.
          rewrite elements_union_singleton in Hx.
          2: { apply not_elem_of_dom_2. assumption. }
          apply elem_of_cons in Hx.
          destruct Hx as [Hx | Hx]; first subst.
          + rewrite /card_input; simpl; lia.
          + apply Hdom. apply Hx.
      }
      rel_vals.
      Unshelve. apply gset_fin_set.
  Admitted.

Lemma pk_real_real_tape : ⊢ refines top (init_scheme pk_real) (init_scheme pk_real_tape)
  (lrel_G * (lrel_input → () + (() + (lrel_int * lrel_int) * (lrel_G * lrel_G)))).
Proof with (rel_pures_l; rel_pures_r).
  rel_init_scheme mapref "Hmap" mapref' "Hmap'"...
  rewrite /pk_real; rewrite /pk_real_tape...
  rewrite /keygen... rewrite -/N.
  rel_alloctape_r β as "Hβ"...
  rel_apply refines_couple_UU; first done.
  iIntros (n Hnbound). iModIntro...
  simpl_exp...
  rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
  rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l.
  rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r.
  rel_apply refines_pair.
  { rel_values. }
  rewrite /encaps. rewrite /enc.
  set (P := (
    (∃ (M : gmap nat val),
      map_list  mapref  M
    ∗ map_slist mapref' M
    ∗ ⌜ ∀ y, y ∈ @map_img nat val (gmap nat val) _ (gset val) _ _ _ M
      → ∃ k : nat, y = #k ∧ k <= card_output ⌝
    ∗ ⌜ ∀ x, x ∈ elements (dom M) -> (x < S card_input)%nat ⌝)
    ∗ β ↪ₛN(N;[])
    ∗ (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∨ cnt ↦ #1 ∗ cnt' ↦ₛ #1)
  )%I).
  rel_apply (refines_na_alloc P (nroot.@"pk_real_real_tape")).
  iFrame.
  iSplitL.
  { iSplitR; last (iLeft; iFrame).
    iPureIntro; split.
    - intros y Hy. rewrite map_img_empty in Hy.
      rewrite elem_of_empty in Hy. exfalso; apply Hy.
    - intros y Hy. rewrite elements_empty in Hy.
      rewrite elem_of_nil in Hy. exfalso; apply Hy.
  }
  iIntros "#Inv". rel_arrow_val.
  iIntros (v1 v2 [msg [eq1 [eq2 Hmsgbound]]]); subst...
  rewrite /SymKey.
  rel_apply refines_couple_UU; first done.
  iIntros (k Hkbound).
  iModIntro...
  rel_bind (vg_of_int #k).
  rel_apply (refines_bind _ _ _ (() + lrel_G)).
  {
    rel_apply (refines_app _ _ _ _ lrel_int); rel_values.
    iModIntro. iApply vg_of_int_lrel_G.
  }
  iIntros (kg1 kg2 [tmp [tmp' [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]); subst;
  try (rel_pures_l; rel_pures_r; rel_vals)...
  rewrite -/N. rel_apply refines_na_inv. iSplitL; first iAssumption.
  iIntros "[[H [Hβ Hcnts]] Hclose]".
  rel_apply (refines_couple_UT); first done.
  iFrame. simpl; iModIntro; iIntros (b Hbbound) "Hβ"...
  rel_apply (refines_randT_r with "Hβ").
  iIntros "Hβ _"...
  simpl_exp.
  simpl_exp. rel_apply refines_mult_l...
  iDestruct "Hcnts" as "[[Hcnt Hcnt']|[Hcnt Hcnt']]"; rel_load_l; rel_load_r...
  - rel_load_l; rel_load_r; rel_store_l; rel_store_r...
    simpl_exp. rel_apply refines_mult_r...
    rel_apply refines_na_close; iFrame; iSplitL.
    { iFrame. iRight; replace (0+1)%Z with 1%Z by lia; iFrame. }
    rel_apply refines_injr.
    rel_bind_l (prf_enc _ _ _ _ _ _).
    rel_bind_r (prf_enc _ _ _ _ _ _).
    rel_apply refines_bind.
    2 : {
      iIntros (v v') "#H". rel_pure_l. rel_pure_l.
      rel_pure_r. rel_pure_r. rel_apply refines_injr. rel_apply refines_pair; rel_vals;
      rewrite /lrel_car; simpl; iExists _; done.
    }
    repeat (rel_apply refines_app);
    first rel_apply prf_enc_sem_typed; [|rel_vals|rel_vals].
    rel_arrow_val.
    iIntros (v1 v2 [tmp [eq1 eq2]]); subst... clear tmp.
    rel_apply random_function_sem_typed_inv; last iAssumption.
    exists (β ↪ₛN (N; []) ∗ (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∨ cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I.
    apply bi.equiv_entails; split.
    + iIntros "[H [Hβ Hcnts]]"; iFrame.
    + iIntros "[HQ HP]"; iFrame.
  - rel_apply refines_na_close. iFrame; iSplitL.
    {
      iFrame; iRight; iFrame.
    }
    rel_vals.
Qed.

Lemma pk_real_tape_DDH_real : ⊢
  refines top (init_scheme pk_real_tape) (init_scheme Csenc_DDH_real) 
  (lrel_G * (lrel_input → () + (() + (lrel_int * lrel_int) * (lrel_G * lrel_G)))).
Proof with rel_pures_l; rel_pures_r.
  rel_init_scheme mapref "Hmap" mapref' "Hmap'"...
  rewrite /pk_real_tape;
  rewrite /Csenc_DDH_real.
  rewrite /DDH_real. simpl.
  rewrite -/N.
  rel_alloctape_l β as "Hβ"...
  rel_apply refines_couple_UU; first done.
  iIntros (n Hnbound). iModIntro...
  rel_apply refines_couple_TU; first done. iFrame.
  iIntros (b Hbbound) "Hβ"...
  rewrite -Nat2Z.inj_mul.
  simpl_exp. simpl_exp. simpl_exp.
  rewrite /eCsenc...
  rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
  rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l.
  rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r.
  rel_apply refines_pair.
  { rel_values. }
  set (P := (
       (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∗ β ↪N(N;[b])
      ∨ cnt ↦ #1 ∗ cnt' ↦ₛ #1 ∗ β ↪N(N;[]))
      ∗ (∃ (M : gmap nat val),
          map_list  mapref  M
        ∗ map_slist mapref' M
        ∗ ⌜ ∀ y, y ∈ @map_img nat val (gmap nat val) _ (gset val) _ _ _ M
          → ∃ k : nat, y = #k ∧ k <= card_output ⌝
        ∗ ⌜ ∀ x, x ∈ elements (dom M) -> (x < S card_input)%nat ⌝)
    )%I).
  rel_apply (refines_na_alloc P (nroot.@"pk_real_real_tape")).
  iSplitL.
  { iSplitR "Hmap Hmap'"; first (iLeft; iFrame).
    iExists ∅. iFrame. iPureIntro; split.
    - intros y Hy. rewrite map_img_empty in Hy.
      rewrite elem_of_empty in Hy. exfalso; apply Hy.
    - intros y Hy. rewrite elements_empty in Hy.
      rewrite elem_of_nil in Hy. exfalso; apply Hy.
  }
  iIntros "#Inv".
  rel_arrow_val. iIntros (v1 v2 [msg [eq1 [eq2 Hmsgbound]]]); subst...
  rel_apply refines_couple_UU; first done.
  iIntros (k Hkbound). iModIntro...
  rel_bind (vg_of_int #k).
  rel_apply refines_bind.
  { rel_apply refines_app; rel_values; try iApply vg_of_int_lrel_G; rel_vals. }
  iIntros (kg1 kg2 [tmp1 [tmp2 [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]); subst...
  { rel_vals. }
  rel_apply refines_na_inv; iSplitL; first iAssumption.
  iIntros "[[[[Hcnt [Hcnt' Hβ]]|[Hcnt [Hcnt' Hβ]]] Hmaps] Hclose]".
  2:{
    rel_apply refines_randT_empty_l. iFrame.
    iModIntro. iIntros (b') "Hβ _"...
    simpl_exp. rel_load_l. rel_load_r... rel_apply refines_na_close.
    iFrame; iSplitL; first (iRight; iFrame). rel_vals.
  }
  rel_apply refines_randT_l. iFrame. iModIntro; iIntros "Hβ _"...
  simpl_exp. rel_load_l; rel_load_r...
  rel_load_l. rel_store_l; rel_store_r.
  replace (0+1)%Z with 1%Z by lia...
  simpl_exp. rewrite -fingroup.expgM.
  rewrite /ssrnat.muln. rewrite /ssrnat.muln_rec.
  simpl_mult.
  rel_apply refines_na_close; iFrame; iSplitL; first (iRight; iFrame).
  rel_bind_l (prf_enc _ _ _ _ _ _).
  rel_bind_r (prf_enc _ _ _ _ _ _).
  rel_apply refines_bind.
  { repeat (rel_apply refines_app); first rel_apply prf_enc_sem_typed; try by rel_vals.
    rel_arrow_val. iIntros (v1 v2 [tmp [eq1 eq2]]); subst...
    rel_apply random_function_sem_typed_inv; last iAssumption.
    exists (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∗ β ↪N (N; [b]) ∨ cnt ↦ #1 ∗ cnt' ↦ₛ #1 ∗ β ↪N (N; []))%I.
    apply bi.equiv_entails; split; iIntros "H"; rewrite /P; iFrame.
  }
  iIntros (cdem1 cdem2) "Hrel".
  rel_apply refines_injr.
  rel_pure_l. rel_pure_l.
  rel_pure_r. rel_pure_r. rel_apply refines_injr.
  rel_apply (refines_pair with "[Hrel]"); first (rel_values; iAssumption).
  rel_vals; rewrite /lrel_car; simpl; iExists _; done.
Qed.

(* here we use the DDH assumption: we replace C[DDHreal] by C[DDHrand] *)

Lemma Csenc_DDH_rand_pk_rand_senc_delay : ⊢
  refines top
  (init_scheme Csenc_DDH_rand)
  (init_scheme pk_rand_senc_delay)
  (lrel_G *
  (lrel_input → () + (() + (lrel_int * lrel_int) * (lrel_G * lrel_G)))).
Proof with rel_pures_l; rel_pures_r.
  rel_init_scheme mapref "Hmap" mapref' "Hmap'"...
  rewrite /eCsenc...
  rel_alloctape_r γ as "Hγ"...
  rewrite /SymKey. rewrite -/N.
  rel_apply refines_couple_UU; first done.
  iIntros (sk Hskbound); iModIntro...
  rel_apply refines_couple_UU; first done.
  iIntros (b Hbbound); iModIntro...
  rel_apply refines_couple_UT; first done.
  iFrame.
  iIntros (c Hcbound); simpl; iModIntro; iIntros "Hγ"...
  simpl_exp. simpl_exp. simpl_exp.
  rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
  rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l.
  rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r.
  rel_apply refines_pair; first rel_vals.
  set (P := (
     (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∗ γ↪ₛN(N;[c])
    ∨ cnt ↦ #1 ∗ cnt' ↦ₛ #1 ∗ γ↪ₛN(N;[]))
    ∗ (∃ (M : gmap nat val),
        map_list  mapref  M
      ∗ map_slist mapref' M
      ∗ ⌜ ∀ y, y ∈ @map_img nat val (gmap nat val) _ (gset val) _ _ _ M
        → ∃ k : nat, y = #k ∧ k <= card_output ⌝
      ∗ ⌜ ∀ x, x ∈ elements (dom M) -> (x < S card_input)%nat ⌝)
  )%I).
  rel_apply (refines_na_alloc P (nroot.@"CDDHrand_pk_rand_senc_delay")).
  iSplitL.
  { iSplitR "Hmap Hmap'"; first (iLeft; iFrame).
    iExists ∅. iFrame. iPureIntro; split.
    - intros y Hy. rewrite map_img_empty in Hy.
      rewrite elem_of_empty in Hy. exfalso; apply Hy.
    - intros y Hy. rewrite elements_empty in Hy.
      rewrite elem_of_nil in Hy. exfalso; apply Hy. }
  iIntros "#Inv".
  rel_arrow_val.
  iIntros (v1 v2 [msg [eq1 [eq2 Hmsgbound]]]); subst...
  rel_apply refines_couple_UU; first done.
  iIntros (k Hkbound); iModIntro...
  rel_bind (vg_of_int #k).
  rel_apply refines_bind.
  { rel_apply refines_app; rel_values; try iApply vg_of_int_lrel_G; rel_vals. }
  iIntros (kg1 kg2 [tmp1 [tmp2 [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]); subst...
  { rel_vals. }
  rel_apply refines_na_inv; iSplitL; first iAssumption.
  iIntros "[[[[Hcnt [Hcnt' Hγ]]|[Hcnt [Hcnt' Hγ]]] Hmaps] Hclose]";
  rel_load_l; rel_load_r...
  2:{ rel_apply refines_na_close; iFrame; iSplitL; first (iRight; iFrame); rel_vals. }
  rel_store_l; rel_store_r...
  rel_apply (refines_randT_r with "Hγ").
  iIntros "Hγ _"...
  simpl_exp. simpl_mult.
  rel_bind_l (prf_enc _ _ _ _ _ _).
  rel_bind_r (prf_enc _ _ _ _ _ _).
  rel_apply (refines_bind with "[-]").
  {
    rel_apply refines_na_close; iFrame.
    iSplitL; iFrame; first (iRight; iFrame).
    repeat (rel_apply refines_app); first rel_apply prf_enc_sem_typed; try by rel_vals.
    rel_arrow_val. iIntros (v1 v2 [tmp [eq1 eq2]]); subst...
    rel_apply random_function_sem_typed_inv; last iAssumption.
    exists (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∗ γ ↪ₛN (N; [c]) ∨ cnt ↦ #1 ∗ cnt' ↦ₛ #1 ∗ γ ↪ₛN (N; []))%I.
    apply bi.equiv_entails; split; iIntros "H"; rewrite /P; iFrame.
  }
  iIntros (v v') "Hrel"...
  rel_vals; first iAssumption; iExists _; done.
Qed.

Definition pk_rand_senc_mult_free : expr :=
  λ: "sym_scheme",
    let: "sk" := rand #N in
    let: "b" := rand #N in
    let: "pk" := g^"sk" in
    let: "B" := g^"b" in
    let: "count" := ref #0 in
    let: "query" := λ: "msg",
    let: "k" := rand #SymKey in
    let:m "kg" := vg_of_int "k" in
    assert (! "count" = #0);;;
    "count" <- #1;;
    let: "X" := g^(rand #N) in
    let: "ckem" := ("B", "X") in
    if: #0 ≤ "msg" `and` "msg" ≤ #SymOutput then
      let: "cdem" := (Fst "sym_scheme") "k" "msg" in
      SOME ("cdem", "ckem")
    else NONEV
    in ("pk", "query").

Definition pk_rand_srand : expr :=
  let: "sk" := rand #N in
  let: "b" := rand #N in
  let: "pk" := g^"sk" in
  let: "B" := g^"b" in
  let: "count" := ref #0 in
  let: "query" := λ: "msg",
  let: "k" := rand #SymKey in
  let:m "kg" := vg_of_int "k" in
  assert (! "count" = #0);;;
  "count" <- #1;;
  let: "X" := g^(rand #N) in
  let: "ckem" := ("B", "X") in
  if: #0 ≤ "msg" `and` "msg" ≤ #SymOutput then
    let: "cdem" := (let: "i" := rand #Input in
      let: "o" := rand #SymOutput in
      ("i", "o")) in
    SOME ("cdem", "ckem")
  else NONEV
  in ("pk", "query").

(* Here, we get rid of the multiplication by
  the public key, using a nontrivial bijection in the coupling, as in
  ElGamal_semantic *)

Lemma pk_rand_senc_delay_pk_rand_senc_mult_free :
  ⊢ refines top 
  (init_scheme pk_rand_senc_delay)
  (init_scheme pk_rand_senc_mult_free)
  (lrel_G *
  (lrel_input → () + (() + (lrel_int * lrel_int) * (lrel_G * lrel_G)))).
Proof with rel_pures_l; rel_pures_r.
  rel_init_scheme mapref "Hmap" mapref' "Hmap'"...
  rel_alloctape_l γ as "Hγ"...
  rel_apply refines_couple_UU; first done.
  iModIntro; iIntros (sk Hskbound)...
  rel_apply refines_couple_UU; first done.
  iModIntro; iIntros (b Hbbound)...
  simpl_exp. simpl_exp.
  rel_alloc_l cnt as "Hcnt".
  rel_alloc_r cnt' as "Hcnt'".
  rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l. rel_pure_l.
  rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r. rel_pure_r.
  rel_apply refines_pair; first rel_values.
  set (P := (
    (γ ↪N (N; []) ∗ ((cnt ↦ #0 ∗ cnt' ↦ₛ #0) ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1)))
    ∗ (∃ (M : gmap nat val),
        map_list  mapref  M
      ∗ map_slist mapref' M
      ∗ ⌜ ∀ y, y ∈ @map_img nat val (gmap nat val) _ (gset val) _ _ _ M
        → ∃ k : nat, y = #k ∧ k <= card_output ⌝
      ∗ ⌜ ∀ x, x ∈ elements (dom M) -> (x < S card_input)%nat ⌝)
  )%I).
  rel_apply (refines_na_alloc P (nroot.@"pk_rand_delay_tape")).
  iSplitL.
  { iSplitR "Hmap Hmap'"; first (iFrame; iLeft; iFrame).
    iExists ∅. iFrame. iPureIntro; split.
    - intros y Hy. rewrite map_img_empty in Hy.
      rewrite elem_of_empty in Hy. exfalso; apply Hy.
    - intros y Hy. rewrite elements_empty in Hy.
      rewrite elem_of_nil in Hy. exfalso; apply Hy. }
  iIntros "#Inv".
  rel_arrow_val.
  iIntros (v1 v2 [x [eq1 [eq2 Hxbound]]]); subst...
  rewrite /card_input in Hxbound; simpl in Hxbound.
  rel_apply refines_couple_UU; first done.
  iModIntro; iIntros (k Hkbound)...
  rel_bind (vg_of_int #k).
  rel_apply refines_bind.
  { rel_apply refines_app; rel_values; try iApply vg_of_int_lrel_G; rel_vals. }
  iIntros (kg1 kg2 [tmp1 [tmp2 [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]); subst...
  { rel_vals. }
  rel_apply refines_na_inv; iSplitL; first iAssumption.
  iIntros "[[[Hγ [[Hcnt Hcnt']|[Hcnt Hcnt']]] Hmaps] Hclose]"...
  - rel_load_l; rel_load_r...
    rel_store_l; rel_store_r...
    (* Rewrite msg into g^k_msg for some k_msg. *)
    destruct (log_g kg) as [k_msg ->].
    rel_apply (refines_couple_TU N (mod_plus _ k_msg)); first apply mod_plus_lt.
    iFrame.
    iIntros (logX HlogXbound) "Hγ"; simpl.
    rel_rand_l. iIntros "_"...
    simpl_exp. simpl_mult.
    assert (Hxbound' : bool_decide (0 ≤ x)%Z && bool_decide (x ≤ SymOutput)%Z = true).
    { rewrite andb_true_iff; split; apply bool_decide_eq_true; lia. }
    rewrite Hxbound'...
    rel_bind_l (prf_enc _ _ _ _ _ _).
    rel_bind_r (prf_enc _ _ _ _ _ _).
    rel_apply (refines_bind with "[-]").
    {
      rel_apply refines_na_close; iFrame.
      iSplitL; iFrame; first (iRight; iFrame).
      repeat (rel_apply refines_app); first rel_apply prf_enc_sem_typed; try by rel_vals.
      rel_arrow_val. iIntros (v1 v2 [tmp [eq1 eq2]]); subst...
      rel_apply random_function_sem_typed_inv; last iAssumption.
      exists (γ ↪N (N; []) ∗ ((cnt ↦ #0 ∗ cnt' ↦ₛ #0) ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1)))%I.
      apply bi.equiv_entails; split; iIntros "H"; rewrite /P; iFrame.
    }
    iIntros (v v') "Hrel"...
    rel_vals; try iAssumption; first last.
    + rewrite -fingroup.expgD -ssrnat.plusE.
      rewrite /mod_plus.
      rewrite -/N.
      assert (H : logX <? S N = true); first (apply Nat.ltb_lt; lia).
      rewrite H; clear H.
      pose proof (e := eq_sym (fingroup.expg_mod_order g (k_msg+logX))).
      rewrite g_nontriv in e.
      rewrite e.
      rewrite -/N.
      rewrite /lrel_car. simpl.
      iExists _. iSplit; iPureIntro; done.
    + iExists _. iSplit; iPureIntro; done.
  - rel_load_l; rel_load_r... rel_apply refines_na_close; iFrame.
    iSplitL; first (iRight; iFrame).
    rel_vals.
Qed.

(* from this point on, we need to consider
  an adversary returning a boolean, for
  compatibility with the CPA assumption on
  the symmetric scheme *)

Definition adv_rand : val :=
  λ: "oracle",
    let: "sk" := rand #N in
    let: "b" := rand #N in
    let: "pk" := g^"sk" in
    let: "B" := g^"b" in
    let: "count" := ref #0 in
    let: "query" := λ: "msg",
      let: "k" := rand #SymKey in
      let:m "kg" := vg_of_int "k" in
      assert (! "count" = #0);;;
      "count" <- #1;;
      let: "X" := g^(rand #N) in
      let: "ckem" := ("B", "X") in
      let:m "cdem" := "oracle" "msg" in
      SOME ("cdem", "ckem")
    in ("pk", "query").

Lemma adv_rand_syn_typed : ⊢ᵥ adv_rand :
  ((TMessage → TOption prf_cpa_with_dec.TCipher) → τG * TOracle).
Proof.
  rewrite /adv_rand.
  apply Rec_val_typed.
  type_expr 1. 2 : { apply Subsume_int_nat. tychk. }
  type_expr 1.
  type_expr 1. 2 : { apply Subsume_int_nat. tychk. }
  type_expr 1.
  type_expr 1; last try tychk; first last.
  { apply g_typed. }
  { apply vexp_typed. }
  type_expr 1.
  type_expr 1; last try tychk; first last.
  { apply g_typed. }
  { apply vexp_typed. }
  type_expr 1.
  type_expr 1; last try tychk.
  type_expr 1.
  type_expr 1; first tychk.
  type_expr 1.
  type_expr 1. 2 : { apply Subsume_int_nat. tychk. }
  type_expr 1.
  type_expr 1.
  { tychk. apply vg_of_int_typed. }
  { tychk. }
  type_expr 1.
  type_expr 1; first tychk.
  2 : { apply InjL_typed. tychk. }
  apply InjR_typed.
  type_expr 1; last tychk.
  type_expr 1.
  type_expr 1. 2 : {
    type_expr 1. 2 : { apply Subsume_int_nat. tychk. }
    tychk.
    { apply vexp_typed. }
    { apply g_typed. }
  }
  type_expr 1.
  type_expr 1; try tychk.
Qed.

Lemma pk_rand_senc_mult_free_adv_sym_cpa (adv : val) :
  refines top adv
    adv ((lrel_G * (lrel_input → () + (() + lrel_int * lrel_int * (lrel_G * lrel_G)))) → lrel_bool)
  ⊢ refines top
    (adv (init_scheme pk_rand_senc_mult_free))
    ((CPA SymKey Input SymOutput) #true (λ: "oracle", adv (adv_rand "oracle"))%V (rf_scheme Input SymOutput xor_struct) #1)
  lrel_bool.
Proof with rel_pures_l; rel_pures_r.
  iIntros "Hadvtyped".
  rewrite /rf_scheme.
  rel_init_scheme mapref "Hmap" mapref' "Hmap'"...
  rewrite /CPA; rel_pures_r.
  rewrite /get_keygen; rel_pures_r.
  rewrite /rf_keygen; rel_pures_r.
  rel_apply refines_randU_r.
  iIntros (k Hkbound); rel_pures_r.
  rewrite /prf_enc; rel_pures_r.
  rewrite /random_function; rel_pures_r.
  rewrite -/random_function; rel_pures_r.
  rewrite /q_calls; rel_pures_r.
  rel_alloc_r cnt2 as "Hcnt2".
  rel_pure_r. rel_pure_r.
  rel_pure_r. rel_pure_r.
  rel_pure_r. rel_pure_r.
  rewrite /pk_rand_senc_mult_free.
  rel_bind_l (adv _).
  rel_bind_r (adv _).
  rel_apply (refines_bind with "[-]").
  2 : { iIntros (v v') "Hrel"... rel_vals. }
  rel_apply (refines_app with "[Hadvtyped]")...
  { iAssumption. }
  rewrite /adv_rand; rel_pures_r.
  rel_apply refines_couple_UU; first done.
  iIntros (sk Hskbound). iModIntro...
  rel_apply refines_couple_UU; first done.
  iIntros (b Hbbound). iModIntro...
  simpl_exp. simpl_exp.
  rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
  rel_pure_l; rel_pure_l; rel_pure_l;
  rel_pure_l; rel_pure_l.
  rel_pure_r. rel_pure_r.
  rel_pure_r. rel_pure_r.
  rel_pure_r.
  rel_bind_l _.
  rel_bind_r (_, _)%E.
  rel_apply (refines_bind with "[-]").
  2:{ iIntros (v v') "Hrel"... rel_vals. } simpl.
  rel_apply refines_pair; first (rel_vals; iApply τG_subtype; iExists _; done).
  set (P := (
      (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∗ cnt2 ↦ₛ #0 ∗ map_list mapref ∅ ∗ map_slist mapref' ∅)
    ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1 ∗ cnt2 ↦ₛ #1 ∗ (∃ (M : gmap nat val),
        map_list  mapref  M
      ∗ map_slist mapref' M
      ∗ ⌜ ∀ y, y ∈ @map_img nat val (gmap nat val) _ (gset val) _ _ _ M
        → ∃ k : nat, y = #k ∧ k <= card_output ⌝
      ∗ ⌜ ∀ x, x ∈ elements (dom M) -> (x < S card_input)%nat ⌝))
  )%I).
  rel_apply (refines_na_alloc P (nroot.@"prf_rand_adv_cpa")).
  iSplitL; first (iLeft; iFrame).
  iIntros "#Inv".
  rel_arrow_val.
  iIntros (v1 v2 [x [eq1 [eq2 Hxbound]]]); subst...
  rewrite /card_input in Hxbound. simpl in Hxbound.
  rel_apply refines_couple_UU; first done.
  iIntros (k_dummy Hkdummy_bound); iModIntro...
  rel_bind (vg_of_int #k_dummy); rel_apply refines_bind.
  { rel_apply refines_app; rel_values; try iApply vg_of_int_lrel_G; rel_vals. }
  iIntros (kg1 kg2 [tmp1 [tmp2 [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]);
  subst; rel_pures_l; rel_pures_r; first rel_vals.
  rel_apply refines_na_inv; iSplitL; first iAssumption.
  iIntros "[[[Hcnt [Hcnt' [Hcnt2 [Hmap Hmap']]]]|[Hcnt [Hcnt' [Hcnt2 Hmaps]]]] Hclose]".
  2 : {
    rel_load_l; rel_load_r... rel_apply refines_na_close; iFrame; iSplitL.
    + iRight. iFrame.
    + rel_vals.
  }
  rel_load_l; rel_load_r...
  rel_store_l; rel_store_r...
  rel_apply refines_couple_UU; first done.
  iIntros (logX HlogXbound); iModIntro; simpl_exp...
  rel_load_r...
  assert (Hxbound' : bool_decide (0 ≤ x)%Z && bool_decide (x ≤ SymOutput)%Z = true).
  { rewrite andb_true_iff; split; apply bool_decide_eq_true; lia. }
  rewrite Hxbound'. clear Hxbound'.
  rel_pures_l; rel_pures_r.
  rel_load_r... rel_store_r...
  rewrite /rf_enc. rewrite /prf_enc.
  rewrite /random_function... (* here, we could see if there is a way to avoid
  having to step through an execution of `random_function` instead of just
  applying `random_function_sem_typed_inv` once again *)
  rel_apply refines_couple_UU; first done.
  iIntros (r Hrbound); iModIntro...
  rel_apply (refines_get_l with "[-Hmap]"); last by iAssumption.
  iIntros (res) "Hmap %Heqres".
  rewrite lookup_empty in Heqres.
  simpl in Heqres. subst...
  rel_apply (refines_get_r with "[-Hmap']"); last by iAssumption.
  iIntros (res) "Hmap' %Heqres".
  rewrite lookup_empty in Heqres.
  simpl in Heqres. subst...
  rel_apply refines_couple_UU; first done...
  (* here, just above, it really feels weird to use PRF (strictly equal to OTP)*)
  iIntros (y Hybound); iModIntro...
  rel_apply (refines_set_l with "[-Hmap]"); last by iAssumption.
  iIntros "Hmap"...
  rel_apply (refines_set_r with "[-Hmap']"); last by iAssumption.
  iIntros "Hmap'"...
  rel_apply refines_na_close; iFrame.
  iSplitL.
  { iRight. replace (0+1)%Z with 1%Z by lia. iFrame.
    iPureIntro; split.
    - intros z Hz. rewrite map_img_insert in Hz. rewrite elem_of_union in Hz.
      destruct Hz as [Hz | contra].
      + rewrite elem_of_singleton in Hz; subst. exists y; split; done.
      + rewrite delete_empty in contra. rewrite map_img_empty in contra.
        inversion contra.
    - intros z Hz. rewrite dom_insert in Hz.
      rewrite elements_union_singleton in Hz; last done.
      rewrite elem_of_cons in Hz. destruct Hz as [Hz|  contra]; subst.
      + rewrite /card_input. simpl. lia. 
      + rewrite elements_empty in contra.
        inversion contra.
  }
  rel_apply refines_injr...
  rel_bind (#r, xor #x #y)%E; rel_apply (refines_bind _ _ _ (lrel_int * lrel_int)).
  { 
    rel_apply xor_correct_l; last
    rel_apply xor_correct_r; try lia...
    rel_vals. 
  }
  iIntros (cdem cdem') "Hrel"...
  rel_vals; first iAssumption; iExists _; done.
Qed.

Lemma rf_is_CPA_instantiated_adv_rand (adv : val)
  (Hadvtype : ⊢ᵥ adv : ((τG * TOracle) → TBool)) :
  ⊢
  (refines top
  ((CPA SymKey Input SymOutput) #true (λ: "oracle", adv (adv_rand "oracle"))%V (rf_scheme Input SymOutput xor_struct) #1)
  ((CPA SymKey Input SymOutput) #false (λ: "oracle", adv (adv_rand "oracle"))%V (rf_scheme Input SymOutput xor_struct) #1)
  lrel_bool).
Proof. iStartProof.
  iPoseProof ec_zero as "Hec".
  iMod "Hec".
  iPoseProof (rf_is_CPA SymKey Input SymOutput xor_struct (λ: "oracle", adv (adv_rand "oracle")) _ _ 1) as "H".
  rewrite INR_1; simpl.
  rewrite Rminus_diag.
  rewrite Rmult_0_l.
  rewrite Rdiv_0_l.
  replace (Z.of_nat 1) with 1%Z by lia.
  iApply "H". iClear "H".
  iAssumption.
  Unshelve.
  constructor.
  constructor.
  type_expr 1.
  - apply Val_typed. apply Hadvtype.
  - type_expr 1; last tychk. apply Val_typed. apply adv_rand_syn_typed.
Qed.

Lemma rf_CPA_pk_rand_srand (adv : val) : 
  refines top adv
    adv ((lrel_G * (lrel_input → () + (() + lrel_int * lrel_int * (lrel_G * lrel_G)))) → lrel_bool)
  ⊢
  refines top
  ((CPA SymKey Input SymOutput) #false (λ: "oracle", adv (adv_rand "oracle"))%V (rf_scheme Input SymOutput xor_struct) #1)
  (adv pk_rand_srand)
  lrel_bool.
Proof with rel_pures_l; rel_pures_r. iIntros "Hadvtyped".
  rewrite /rf_scheme.
  rel_init_scheme_l mapref "Hmap".
  rewrite /CPA...
  rewrite /rf_keygen...
  rel_apply refines_randU_l.
  iIntros (k Hkbound)...
  rewrite /q_calls.
  rel_alloc_l cnt2 as "Hcnt2"...
  rewrite /adv_rand...
  rel_bind_l (adv _); rel_bind_r (adv _).
  rel_apply (refines_bind with "[-]").
  2:{ iIntros (v v') "Hrel"... rel_vals. }
  rel_apply (refines_app with "Hadvtyped").
  rewrite /pk_rand_srand.
  rel_apply refines_couple_UU; first done.
  iIntros (sk Hskbound). iModIntro...
  rel_apply refines_couple_UU; first done.
  iIntros (b Hbbound). iModIntro...
  simpl_exp. simpl_exp.
  rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
  rel_pure_l; rel_pure_l.
  rel_pure_l; rel_pure_l.
  rel_pure_l.
  rel_pure_r; rel_pure_r.
  rel_pure_r; rel_pure_r.
  rel_pure_r.
  rel_apply refines_pair; first rel_vals.
  set (P := (
      (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∗ cnt2 ↦ #0)
    ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1 ∗ cnt2 ↦ #1)
  )%I).
  rel_apply (refines_na_alloc P (nroot.@"prf_rand_adv_cpa")).
  iSplitL; first (iLeft; iFrame).
  iIntros "#Inv".
  rel_arrow_val.
  iIntros (v1 v2 [msg [eq1 [eq2 Hmsgbound]]]); subst...
  rewrite /card_input in Hmsgbound; simpl in Hmsgbound.
  rel_apply refines_couple_UU; first done; iModIntro.
  iIntros (k_dummy Hkdummybound)...
  rel_bind (vg_of_int #k_dummy); rel_apply refines_bind.
  { rel_apply refines_app; rel_values; try iApply vg_of_int_lrel_G; rel_vals. }
  iIntros (kg1 kg2 [tmp1 [tmp2 [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]);
  subst; rel_pures_l; rel_pures_r; first rel_vals.
  rel_apply refines_na_inv; iSplitL; first iAssumption.
  iIntros "[[[Hcnt [Hcnt' Hcnt2]]|[Hcnt [Hcnt' Hcnt2]]] Hclose]".
  2 : {
    rel_load_l; rel_load_r... rel_apply refines_na_close; iFrame; iSplitL.
    + iRight. iFrame.
    + rel_vals.
  }
  rel_load_l; rel_load_r...
  rel_store_l; rel_store_r...
  rel_apply refines_couple_UU; first done.
  iIntros (logX HlogXbound). iModIntro...
  simpl_exp.
  rel_load_l...
  assert (Hmsgbound' : bool_decide (0 ≤ msg)%Z && bool_decide (msg ≤ SymOutput)%Z = true).
  { rewrite andb_true_iff; split; apply bool_decide_eq_true; lia. }
  rewrite Hmsgbound'. clear Hmsgbound'...
  rel_load_l; rel_store_l...
  rewrite /rf_rand_cipher...
  rel_apply refines_couple_UU; first done.
  iIntros (i Hibound); iModIntro...
  rel_apply refines_couple_UU; first done.
  iIntros (o Hobound); iModIntro...
  rel_apply refines_na_close; iFrame; iSplitL.
  { iRight; replace (0+1)%Z with 1%Z by lia; iFrame. }
  rel_vals; iExists _; done.
Qed.

Definition pk_rand_tape : expr :=
  let: "β" := alloc #N in
  let: "sk" := rand #N in
  let: "pk" := g^"sk" in
  let: "count" := ref #0 in
  let: "query" := λ: "msg",
    let: "k" := rand #SymKey in
    let:m "kg" := vg_of_int "k" in
    assert (! "count" = #0);;;
    "count" <- #1;;
    let: "b" := rand("β") #N in
    let: "B" := g^"b" in
    let: "X" := g^(rand #N) in
    let: "ckem" := ("B", "X") in
    let: "cdem" := (let: "i" := rand #Input in
      let: "o" := rand #SymOutput in
      ("i", "o")) in
    SOME ("cdem", "ckem")
  in ("pk", "query").

Lemma pk_rand_srand_rand_tape (adv : val) :
  refines top adv
    adv ((lrel_G * (lrel_input → () + (() + lrel_int * lrel_int * (lrel_G * lrel_G)))) → lrel_bool)
  ⊢
  refines top (adv pk_rand_srand) (adv pk_rand_tape) lrel_bool.
Proof with rel_pures_l; rel_pures_r.
  iIntros "Hadvtyped".
  rel_apply (refines_app with "Hadvtyped").
  rewrite /pk_rand_srand.
  rewrite /pk_rand_tape.
  rel_alloctape_r β as "Hβ"...
  rel_apply refines_couple_UU; first done.
  iIntros (sk Hskbound); iModIntro...
  rel_apply refines_couple_UT; first done.
  iFrame. iModIntro.
  iIntros (b Hbbound) "Hβ"...
  simpl_exp. simpl_exp.
  rel_alloc_l cnt as "Hcnt"; rel_alloc_r cnt' as "Hcnt'".
  rel_pure_l; rel_pure_l; rel_pure_l; rel_pure_l; rel_pure_l.
  rel_pure_r; rel_pure_r; rel_pure_r; rel_pure_r; rel_pure_r.
  rel_apply refines_pair; first rel_vals. simpl.
  set (P := (
      cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∗ β↪ₛN(N;[b])
    ∨ cnt ↦ #1 ∗ cnt' ↦ₛ #1 ∗ β↪ₛN(N;[])
  )%I).
  rel_apply (refines_na_alloc P (nroot.@"pk_rand_srand_rand_tape")).
  iSplitL; first (iLeft; iFrame).
  iIntros "#Inv".
  rel_arrow_val.
  iIntros (v1 v2 [msg [eq1 [eq2 Hmsgbound]]]); subst...
  rewrite /card_input in Hmsgbound; simpl in Hmsgbound.
  rel_apply refines_couple_UU; first done.
  iIntros (k Hkbound); iModIntro...
  rel_bind (vg_of_int #k).
  rel_apply (refines_bind _ _ _ (() + lrel_G)).
  {
    rel_apply (refines_app _ _ _ _ lrel_int); rel_values.
    iModIntro. iApply vg_of_int_lrel_G.
  }
  iIntros (kg1 kg2 [tmp [tmp' [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]); subst;
  try (rel_pures_l; rel_pures_r; rel_vals)...
  rel_apply refines_na_inv; iSplitL; first iAssumption.
  iIntros "[[[Hcnt [Hcnt' Hβ]]|[Hcnt [Hcnt' Hβ]]] Hclose]";
  rel_load_l; rel_load_r...
  2:{ rel_apply refines_na_close; iFrame. iSplitL; first (iRight; iFrame); rel_vals. }
  rel_store_l; rel_store_r...
  rel_apply (refines_randT_r with "Hβ").
  iIntros "Hβ _"...
  simpl_exp.
  rel_apply refines_couple_UU; first done.
  iModIntro; iIntros (logX HlogXbound)...
  simpl_exp.
  assert (Hmsgbound' : bool_decide (0 ≤ msg)%Z && bool_decide (msg ≤ SymOutput)%Z = true).
  { rewrite andb_true_iff; split; apply bool_decide_eq_true; lia. }
  rewrite Hmsgbound'. clear Hmsgbound'...
  rel_apply refines_couple_UU; first done.
  iModIntro; iIntros (i Hibound)...
  rel_apply refines_couple_UU; first done.
  iModIntro; iIntros (o Hobound)...
  rel_apply refines_na_close; iFrame; iSplitL; first (iRight; iFrame).
  rel_vals; iExists _; done.
Qed.

Lemma pk_rand_tape_pk_rand (adv : val) :
  refines top adv
    adv ((lrel_G * (lrel_input → () + (() + lrel_int * lrel_int * (lrel_G * lrel_G)))) → lrel_bool)
  ⊢
  refines top (adv pk_rand_tape) (adv pk_rand) lrel_bool.
Proof with rel_pures_l; rel_pures_r. iIntros "Hadvtyped".
  rel_apply (refines_app with "Hadvtyped").
  rewrite /pk_rand_tape. rewrite /pk_rand.
  rewrite /keygen...
  rewrite -/N.
  rel_alloctape_l β as "Hβ"...
  rel_apply refines_couple_UU; first done.
  iIntros (sk Hskbound); iModIntro...
  simpl_exp.
  rel_alloc_l cnt as "Hcnt".
  rel_alloc_r cnt' as "Hcnt'".
   rel_pure_l; rel_pure_l; rel_pure_l; rel_pure_l; rel_pure_l.
   rel_pure_r; rel_pure_r; rel_pure_r; rel_pure_r; rel_pure_r.
   rel_apply refines_pair; first (rel_vals; iExists _; done).
  set (P := (
    (cnt ↦ #0 ∗ cnt' ↦ₛ #0 ∨ cnt ↦ #1 ∗ cnt' ↦ₛ #1) ∗ β↪N(N;[])
  )%I).
  rel_apply (refines_na_alloc P (nroot.@"pk_rand_tape_pk_rand")).
  iSplitL; first (iFrame; iLeft; iFrame).
  iIntros "#Inv".
  rel_arrow_val.
  iIntros (v1 v2 [msg [eq1 [eq2 Hmsgbound]]]); subst...
  rel_apply refines_couple_UU; first done.
  iIntros (k Hkbound); iModIntro...
  rel_bind (vg_of_int #k); rel_apply refines_bind.
  { rel_apply refines_app; rel_values; try iApply vg_of_int_lrel_G; rel_vals. }
  iIntros (kg1 kg2 [tmp1 [tmp2 [[eq1 [eq2 [eq3 eq4]]]|[eq1 [eq2 [kg [eq3 eq4]]]]]]]);
  subst; rel_pures_l; rel_pures_r; first rel_vals.
  rel_apply refines_na_inv; iSplitL; first iAssumption.
  iIntros "[[[[Hcnt Hcnt']|[Hcnt Hcnt']] Hβ] Hclose]";rel_load_l; rel_load_r...
  2 : {
    rel_apply refines_na_close; iFrame; iSplitL.
    + iRight. iFrame.
    + rel_vals.
  }
  rel_load_r... rel_store_l; rel_store_r...
  rel_apply refines_couple_TU; first done; iFrame.
  iIntros (b Hbbound) "Hβ"; simpl.
  rel_apply refines_randT_l; iFrame.
  iModIntro. iIntros "Hβ _"...
  simpl_exp.
  rel_apply refines_couple_UU; first done.
  iIntros (x Hxbound); iModIntro...
  simpl_exp. simpl_exp.
  rel_apply refines_couple_UU; first done.
  iIntros (i Hibound); iModIntro...
  rel_apply refines_couple_UU; first done.
  iIntros (o Hobound); iModIntro...
  rel_apply refines_na_close; iFrame; iSplitL.
  { replace (0+1)%Z with 1%Z by lia. iFrame; iRight; iFrame. }
  rel_vals; iExists _; done.
Qed.

End logrel.

End Hybrid_scheme.