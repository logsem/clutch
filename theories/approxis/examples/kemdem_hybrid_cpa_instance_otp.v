From Ltac2 Require Import Ltac2.
Set Default Proof Mode "Classic".
From clutch.prob_lang Require Import advantage typing.tychk.
From clutch.approxis Require Import map reltac2 approxis option.
From clutch.clutch.examples.crypto Require ElGamal_bijection.
From clutch.approxis.examples Require Import
  valgroup diffie_hellman security_aux option xor
  ElGamal_defs bounded_oracle pubkey advantage_laws iterable_expression.
From clutch.approxis.examples Require symmetric_init kemdem_hybrid_cpa_generic one_time_pad.
From mathcomp Require Import ssrbool.
From mathcomp Require fingroup.fingroup.
Set Default Proof Using "All".
Import ElGamal_bijection.bij_nat.
Import valgroup_notation.
Import fingroup.Notations.
Import map.

Section Hybrid_scheme.

Context {vg : val_group}.           (* A group on a subset of values. *)
Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
Context {vgg : @val_group_generator vg}.   (* G is generated by g. *)
Context {cgg : @clutch_group_generator vg cg vgg}. (* g is well-typed *)

Let N := S n''.
Let SymKey := N.
Let Input := N.
Let SymOutput := N.
Variable xor_struct : XOR (Key := SymOutput) (Support := SymOutput).

Section logrel.

  Context `{!approxisRGS Œ£}.
  Context {G : clutch_group (vg:=vg) (cg:=cg)}.
  Context {Œî : listO (lrelC Œ£)}.

  Definition lrel_sym_key : lrel Œ£ := lrel_int_bounded 0 SymKey. 
  Definition lrel_key : lrel Œ£ := lrel_G.
  Definition lrel_output : lrel Œ£ := lrel_int_bounded 0 SymOutput.
  Definition lrel_input : lrel Œ£ := lrel_int_bounded 0 Input.

  Variable xor_spec : XOR_spec.
  
  Local Tactic Notation "rel_bind" open_constr(pat) :=
    rel_bind_l pat; rel_bind_r pat.

  Local Ltac refines_until tac :=
    repeat (rel_pure_l; rel_pure_r; try (rel_apply tac)).

  Definition vg_of_symkey : val :=
    rec: "rejection" "key" :=
      match: vg_of_int "key" with
        | SOME "kg" => "kg"
        | NONE => "rejection" "key"
      end.

  Lemma vg_of_symkey_sem_typed :
    ‚ä¢ REL vg_of_symkey << vg_of_symkey : lrel_sym_key ‚Üí lrel_G.
  Proof with rel_pures_l; rel_pures_r. rewrite /vg_of_symkey.
    iL√∂b as "IH".
    rel_arrow_val.
    iIntros (v1 v2 [k [eq1 [eq2 Hkbound]]]); subst...
    rel_bind (vg_of_int _). rel_apply refines_bind.
    {
      rel_apply refines_app.
      - rel_vals; iApply vg_of_int_lrel_G.
      - rel_vals.
    }
    iIntros (kg1 kg2 [tmp [tmp' [[eq1 [eq2 [eq3 eq4]]]|
      [eq1 [eq2 [kg [eq3 eq4]]]]]]]); subst.
    - rel_pure_l; rel_pure_l; rel_pure_l;
      rel_pure_r; rel_pure_r; rel_pure_r.
      rel_apply refines_app; first rel_apply "IH".
      rel_vals.
    - rel_pures_l; rel_pures_r; rel_vals.
  Qed.

  Print one_time_pad.otp_dec.

  Definition otp_enc : val := one_time_pad.otp_enc N xor_struct.
  Definition otp_dec : val := one_time_pad.otp_dec N xor_struct.

  (* The four following definition are very similar.
    The only difference is that otp_... takes a value as input within
    the language, whereas senc and sdec take a list of locations
    at the meta-level (as a crocq function )*)
  Definition otp_enc_vg : val := 
    (Œª: "key",
      otp_enc (int_of_vg "key"))%V.

  Definition otp_dec_vg : val := 
    (Œª: "key",
      otp_dec (int_of_vg "key"))%V.

  Definition senc (ls : list loc) : val := otp_enc_vg.

  Definition sdec (ls : list loc) : val := otp_dec_vg.

  Definition otp_scheme_vg : expr :=
    (Val (senc []), Val (sdec [])).

  Local Instance otp_SYM_param : symmetric_init.SYM_init_params :=
    one_time_pad.SYM_otp_param N.

  Local Instance sym_otp_scheme_inst : symmetric_init.SYM_init := {|
      symmetric_init.keygen := Œª: <>, vg_of_symkey (one_time_pad.otp_keygen SymKey #())
    ; symmetric_init.enc_scheme := otp_scheme_vg
    ; symmetric_init.rand_cipher := one_time_pad.otp_rand_cipher N
  |}.

  Ltac simpl_exp := try (rel_apply refines_exp_l; rel_pures_l);
    try (rel_apply refines_exp_r; rel_pures_r).
  Ltac simpl_mult := try (rel_apply refines_mult_l; rel_pures_l);
    try (rel_apply refines_mult_r; rel_pures_r).

  Definition init_scheme (e : expr) : expr :=
    let: "scheme" := symmetric_init.get_enc_scheme symmetric_init.sym_scheme
      #() in
    e "scheme".

  (* ASSUMPTIONS ON THE SYMMETRIC SCHEME FOR CORRECTNESS *)

  Lemma lrel_input_refl : forall v v', lrel_input v v' -‚àó lrel_input v v.
  Proof. intros v v'. iIntros ([x [eq1 [eq2 Hbound]]]).
    iExists x. iPureIntro; done.
  Qed.

  Definition P0l (lls : list loc) : iProp Œ£ := match lls with
    | [] => True%I
    | _ => False%I
  end.
  Definition P0r (rls : list loc) : iProp Œ£ := match rls with
    | [] => True%I
    | _ => False%I
  end.

  Definition Pl (lls : list loc) : iProp Œ£ := match lls with
    | [] => True%I
    | _ => False%I
  end.
  
  Definition Pr (rls : list loc) : iProp Œ£ := match rls with
    | [] => True%I
    | _ => False%I
  end.
  Definition Plr (lls rls : list loc) : iProp Œ£ := match lls, rls with
    | [], [] => True%I
    | _, _ => False%I
  end.

  Lemma otp_enc_sem_typed :
    ‚àÄ lls rls (ùí© : namespace) (P : iProp Œ£),
    (‚àÉ (Q : iProp Œ£),
      P ‚ä£‚ä¢
        (Q
      ‚àó Plr lls rls)
    ) ‚Üí
    na_invP ùí© P
     ‚ä¢ refines top (senc lls)
      (senc rls) (lrel_key ‚Üí lrel_input ‚Üí lrel_output).
  Proof with (rel_pures_l; rel_pures_r).
    intros lls rls ùí© P [Q H].
    apply bi.equiv_entails in H.
    destruct H as [H1 H2].
    iIntros "#Inv".
    rewrite /senc.
    rel_arrow_val.
    iIntros (v1 v2 [kg [eq1 eq2]]); subst.
    rewrite /otp_enc_vg/otp_enc/one_time_pad.otp_enc.
    destruct lls as [|mapref [|tmp lls]];
    destruct rls as [|mapref' [|tmp' rls]];
    try (simpl in H1;
      rel_apply refines_na_inv; iSplitL; first iAssumption;
      iIntros "[HP _]"; rel_pures_l; rel_pures_r;
      iExFalso;
      iPoseProof (H1 with "HP") as "[_ contra]";
      iAssumption)...
    rel_bind (int_of_vg _); rel_apply refines_bind...
    { rel_apply refines_app; rel_vals;
      first iApply int_of_vg_lrel_G; iExists _; done. }
    iIntros (v1 v2 [k [eq1 eq2]]); subst...
    rel_arrow_val.
    iIntros (v1 v2 [msg [eq1 [eq2 Hmsgbounds]]]); subst...
    (* TODO need additional hypothesis over `int_of_vg`,
      or alternatively, require a wrapper of `int_of_vg`
      for this particular proof *)
    Fail rewrite -(Z2Nat.id k); last lia.
    (* rel_apply xor_correct_l. *)
  Admitted.

  Lemma P0_P_l : ‚àÄ lls, P0l lls -‚àó Pl lls.
  Proof. rewrite /P0l/Pl.
    intros [|ll [|tmp lls]]; iIntros "H"; iAssumption.
  Qed.

  Lemma P0_P_r : ‚àÄ rls, P0r rls -‚àó Pr rls.
  Proof. rewrite /P0l/Pl.
    intros [|ll [|tmp lls]]; iIntros "H"; iAssumption.
  Qed.

  Lemma P0lr_Plr : ‚àÄ lls rls, P0l lls -‚àó P0r rls -‚àó Plr lls rls.
  Proof. rewrite /P0l/P0r/Plr. intros [|ll [|tmp lls]] [|rl [|tmp' rls]];
    iIntros "Hl Hr"; iAssumption.
  Qed.

  Lemma refines_init_otp_scheme_l : forall K e E A,
    (‚àÄ lls,
      P0l lls -‚àó
      refines E
        (fill K (senc lls, sdec lls))
        e A)
    ‚ä¢ refines E
        (fill K (symmetric_init.get_enc_scheme symmetric_init.sym_scheme #()))
        e A.
  Proof. intros *. iIntros "H".
    rewrite /symmetric_init.get_enc_scheme.
    rewrite /symmetric_init.sym_scheme.
    rel_pure_l.
    rel_pure_l.
    rel_pure_l.
    rel_pure_l.
    rel_pure_l.
    rewrite /otp_scheme_vg.
    rel_apply "H".
    done.
  Qed.

  Lemma refines_init_otp_scheme_r : forall K e E A,
    (‚àÄ lls,
      P0r lls -‚àó
      refines E
        e
        (fill K (senc lls, sdec lls))
        A)
    ‚ä¢ refines E
        e
        (fill K (symmetric_init.get_enc_scheme symmetric_init.sym_scheme #()))
        A.
  Proof. intros *. iIntros "H".
    rewrite /symmetric_init.get_enc_scheme.
    rewrite /symmetric_init.sym_scheme.
    rel_pure_r.
    rel_pure_r.
    rel_pure_r.
    rel_pure_r.
    rel_pure_r.
    rewrite /otp_scheme_vg.
    rel_apply "H".
    done.
  Qed.

  Lemma refines_otp_keygen_couple :forall K K' E A,
    (‚àÄ key,
      (lrel_car lrel_key) key key -‚àó
        refines E
          (fill K  (Val key))
          (fill K' (Val key))
          A)
    ‚ä¢ refines E
        (fill K  (symmetric_init.keygen #()))
        (fill K' (symmetric_init.keygen #()))
        A.
  Proof with (rel_pures_l; rel_pures_r).
    intros *. iIntros "Hrelkey".
    rewrite /symmetric_init.keygen/sym_otp_scheme_inst...
    rewrite /one_time_pad.otp_keygen...
    rel_apply refines_couple_UU; first done.
    iModIntro; iIntros (k Hkbound).
    rewrite /vg_of_symkey. iL√∂b as "IH"...
    rel_apply_l vg_of_int_correct; last
    rel_apply_r vg_of_int_correct; last first.
    - destruct (vg_of_int_sem k) as [kg|].
      + rel_pures_l; rel_pures_r.
        rel_apply "Hrelkey".
        iApply vgval_sem_typed.
      + rel_pure_l; rel_pure_l; rel_pure_l.
        rel_pure_r; rel_pure_r; rel_pure_r.
        rel_apply "IH". iApply "Hrelkey".
    - rewrite /to_val_type_rel. iSplit.
      + iIntros (x). iExists x. done.
      + iIntros (ox). destruct ox as [x|]; iPureIntro.
        * eexists. eexists. right. repeat split.
          eexists. done.
        * eexists. eexists. left. repeat split.
    - rewrite /to_val_type_rel. iSplit.
      + iIntros (x). iExists x. done.
      + iIntros (ox). destruct ox as [x|]; iPureIntro.
        * eexists. eexists. right. repeat split.
          eexists. done.
        * eexists. eexists. left. repeat split.
  Qed.

  Lemma refines_otp_keygen_l : forall K e E A,
    (‚àÄ key,
      kemdem_hybrid_cpa_generic.left_lrel lrel_key key -‚àó
      refines E
        (fill K (Val key))
        e A)
    ‚ä¢ refines E
        (fill K (symmetric_init.keygen #()))
        e A.
  Proof with rel_pures_l. intros *. iIntros "Hrelkey".
    rewrite /symmetric_init.keygen... simpl.
    rewrite /one_time_pad.otp_keygen...
    rel_apply refines_randU_l.
    iIntros (k Hkbound).
    rewrite /vg_of_symkey. iL√∂b as "IH"...
    rel_apply_l vg_of_int_correct; last first.
    - destruct (vg_of_int_sem k) as [kg|].
      + rel_pures_l; rel_pures_r.
        rel_apply "Hrelkey".
        iExists _.
        iApply vgval_sem_typed.
      + rel_pure_l; rel_pure_l; rel_pure_l.
        rel_apply "IH". iApply "Hrelkey".
    - rewrite /to_val_type_rel. iSplit.
      + iIntros (x). iExists x. done.
      + iIntros (ox). destruct ox as [x|]; iPureIntro.
        * eexists. eexists. right. repeat split.
          eexists. done.
        * eexists. eexists. left. repeat split.
  Qed.

  Lemma refines_otp_keygen_r : forall K e E A,
    (‚àÄ key,
      kemdem_hybrid_cpa_generic.right_lrel lrel_key key -‚àó
      refines E
        e
        (fill K (Val key))
        A)
    ‚ä¢ refines E
        e
        (fill K (symmetric_init.keygen #()))
        A.
  Proof with rel_pures_r. intros *. iIntros "Hrelkey".
    rewrite /symmetric_init.keygen... simpl.
    rewrite /one_time_pad.otp_keygen...
    rel_apply refines_randU_r.
    iIntros (k Hkbound).
    rewrite /vg_of_symkey. iL√∂b as "IH"...
    rel_apply_r vg_of_int_correct; last first.
    - destruct (vg_of_int_sem k) as [kg|].
      + rel_pures_l; rel_pures_r.
        rel_apply "Hrelkey".
        iExists _.
        iApply vgval_sem_typed.
      + rel_pure_r; rel_pure_r; rel_pure_r.
        Fail rel_pure_l. (* is there a way to say "e still has some computing left" ?
        I think there as a mention of sth like that in the paper... *)
        Fail rel_apply "IH"; iApply "Hrelkey".
        admit.
    - rewrite /to_val_type_rel. iSplit.
      + iIntros (x). iExists x. done.
      + iIntros (ox). destruct ox as [x|]; iPureIntro.
        * eexists. eexists. right. repeat split.
          eexists. done.
        * eexists. eexists. left. repeat split.
  Admitted.

  Lemma refines_otp_senc_l : (kemdem_hybrid_cpa_generic.refines_senc_l_prop lrel_key lrel_input senc sdec Pl).
  Proof with rel_pures_l.
    rewrite /kemdem_hybrid_cpa_generic.refines_senc_l_prop.
    iIntros (lls msg k K e E A) "[[%vk' %Hrelk] [%Hrelmsg HP]] H".
    rewrite /senc/otp_enc_vg/otp_enc/one_time_pad.otp_enc.
    destruct lls as [|mapref [|tmp lls]]; try (iExFalso; done)...
    destruct Hrelk as [kg [eqkg _]]; subst.
    rel_apply_l int_of_vg_correct...
    {
      rewrite /to_val_type_rel. iSplit.
      - iIntros (x). iExists _. iPureIntro. split; done.
      - iIntros (x). iExists _. iPureIntro; split; done.
    }
    (* TODO cf otp_enc_sem_typed *)
    Fail rel_apply xor_correct_l.
    (* rel_apply "H".
    done *)
  Admitted.

Section Correctness.

  Import mathcomp.fingroup.fingroup.

  Lemma hybrid_scheme_correct :
      ‚ä¢ refines top
          (init_scheme (Œª: "scheme", (let, ("sk", "pk") := keygen #() in
          Œª:"msg", kemdem_hybrid_cpa_generic.dec_hyb "scheme" "sk"
            (kemdem_hybrid_cpa_generic.enc_hyb "scheme" "pk" "msg"))))
          (Œª: "msg", "msg")%V
          (lrel_input ‚Üí lrel_input).
  Proof.
    rel_apply kemdem_hybrid_cpa_generic.hybrid_scheme_correct.
    - exact one_time_pad.TMessage.
    - exact one_time_pad.TKey.
    - exact one_time_pad.TInput.
    - exact one_time_pad.TOutput.
    - exact one_time_pad.TCipher.
    - exact Œî.
    - { Unshelve. 1: shelve.
    - exact lrel_key.
    - exact senc.
    - exact sdec.
    - exact P0l.
    - exact P0r.
    - exact Pl.
    - exact Pr.
    - exact Plr. } Unshelve.
      unfold lrel_key. iIntros (v v') "H"; iAssumption.
    - iIntros (x); iApply P0_P_l.
    - iIntros (x); iApply P0_P_r.
    - iIntros (x y); iApply P0lr_Plr.
    - iIntros (x y z t). iApply refines_init_otp_scheme_l.
    - iIntros (x y z t). iApply refines_init_otp_scheme_r.
    - iIntros (x y z t). iApply refines_otp_keygen_couple.
    - iIntros (x y z t). iApply refines_otp_keygen_l.
    - iIntros (x y z t). iApply refines_otp_keygen_r.
    - iIntros (x y z t x' y' z'). iApply refines_otp_senc_l.
  Qed.

End Correctness.

Lemma otp_pk_real_real_tape :
  ‚ä¢ refines top
      (init_scheme kemdem_hybrid_cpa_generic.pk_real)
      (init_scheme kemdem_hybrid_cpa_generic.pk_real_tape)
      (lrel_G * (lrel_input ‚Üí () + lrel_output * (lrel_G * lrel_G))).
Proof with (rel_pures_l; rel_pures_r).
  rel_apply kemdem_hybrid_cpa_generic.pk_real_real_tape.
  - exact one_time_pad.TMessage.
  - exact one_time_pad.TKey.
  - exact one_time_pad.TInput.
  - exact one_time_pad.TOutput.
  - exact one_time_pad.TCipher.
  - exact Œî.
  - { Unshelve. 1: shelve.
  - exact lrel_key.
  - exact senc.
  - exact sdec.
  - exact P0l.
  - exact P0r.
  - exact Pl.
  - exact Pr.
  - exact Plr. } Unshelve.
    unfold lrel_key. iIntros (v v') "H"; iAssumption.
  - iIntros (x); iApply P0_P_l.
  - iIntros (x); iApply P0_P_r.
  - iIntros (x y); iApply P0lr_Plr.
  - iIntros (x y z t). iApply refines_init_otp_scheme_l.
  - iIntros (x y z t). iApply refines_init_otp_scheme_r.
  - iIntros (x y z t). iApply refines_otp_keygen_couple.
  - iIntros (x y z t). iApply refines_otp_keygen_l.
  - iIntros (x y z t). iApply refines_otp_keygen_r.
  - iIntros (x y z t x' y' z'). iApply refines_otp_senc_l.
  - iIntros (x y z x' y'). iApply otp_enc_sem_typed. assumption.
Qed.

Lemma otp_pk_real_tape_DDH_real :
  ‚ä¢ refines top
      (init_scheme kemdem_hybrid_cpa_generic.pk_real_tape)
      (init_scheme kemdem_hybrid_cpa_generic.Csenc_DDH_real) 
    (lrel_G * (lrel_input ‚Üí () + lrel_output * (lrel_G * lrel_G))).
Proof with rel_pures_l; rel_pures_r.
  rel_apply kemdem_hybrid_cpa_generic.pk_real_tape_DDH_real.
  - exact one_time_pad.TMessage.
  - exact one_time_pad.TKey.
  - exact one_time_pad.TInput.
  - exact one_time_pad.TOutput.
  - exact one_time_pad.TCipher.
  - exact Œî.
  - { Unshelve. 1: shelve.
  - exact lrel_key.
  - exact senc.
  - exact sdec.
  - exact P0l.
  - exact P0r.
  - exact Pl.
  - exact Pr.
  - exact Plr. } Unshelve.
    unfold lrel_key. iIntros (v v') "H"; iAssumption.
  - iIntros (x); iApply P0_P_l.
  - iIntros (x); iApply P0_P_r.
  - iIntros (x y); iApply P0lr_Plr.
  - iIntros (x y z t). iApply refines_init_otp_scheme_l.
  - iIntros (x y z t). iApply refines_init_otp_scheme_r.
  - iIntros (x y z t). iApply refines_otp_keygen_couple.
  - iIntros (x y z t). iApply refines_otp_keygen_l.
  - iIntros (x y z t). iApply refines_otp_keygen_r.
  - iIntros (x y z t x' y' z'). iApply refines_otp_senc_l.
  - iIntros (x y z x' y'). iApply otp_enc_sem_typed. assumption.
Qed.

(* here we use the DDH assumption: we replace C[DDHreal] by C[DDHrand] *)

Lemma otp_Csenc_DDH_rand_pk_rand_senc_delay :
  ‚ä¢ refines top
      (init_scheme kemdem_hybrid_cpa_generic.Csenc_DDH_rand)
      (init_scheme kemdem_hybrid_cpa_generic.pk_rand_senc_delay)
      (lrel_G *
      (lrel_input ‚Üí () + lrel_output * (lrel_G * lrel_G))).
Proof with rel_pures_l; rel_pures_r.
  rel_apply kemdem_hybrid_cpa_generic.Csenc_DDH_rand_pk_rand_senc_delay.
  - exact one_time_pad.TMessage.
  - exact one_time_pad.TKey.
  - exact one_time_pad.TInput.
  - exact one_time_pad.TOutput.
  - exact one_time_pad.TCipher.
  - exact Œî.
  - { Unshelve. 1: shelve.
  - exact lrel_key.
  - exact senc.
  - exact sdec.
  - exact P0l.
  - exact P0r.
  - exact Pl.
  - exact Pr.
  - exact Plr. } Unshelve.
    unfold lrel_key. iIntros (v v') "H"; iAssumption.
  - iIntros (x); iApply P0_P_l.
  - iIntros (x); iApply P0_P_r.
  - iIntros (x y); iApply P0lr_Plr.
  - iIntros (x y z t). iApply refines_init_otp_scheme_l.
  - iIntros (x y z t). iApply refines_init_otp_scheme_r.
  - iIntros (x y z t). iApply refines_otp_keygen_couple.
  - iIntros (x y z t). iApply refines_otp_keygen_l.
  - iIntros (x y z t). iApply refines_otp_keygen_r.
  - iIntros (x y z t x' y' z'). iApply refines_otp_senc_l.
  - iIntros (x y z x' y'). iApply otp_enc_sem_typed. assumption.
Qed.

Lemma otp_pk_rand_senc_delay_pk_rand_senc_mult_free :
  ‚ä¢ refines top 
      (init_scheme kemdem_hybrid_cpa_generic.pk_rand_senc_delay)
      (init_scheme kemdem_hybrid_cpa_generic.pk_rand_senc_mult_free)
      (lrel_G *
      (lrel_input ‚Üí () + lrel_output * (lrel_G * lrel_G))).
Proof with rel_pures_l; rel_pures_r.
  rel_apply kemdem_hybrid_cpa_generic.pk_rand_senc_delay_pk_rand_senc_mult_free.
  - exact one_time_pad.TMessage.
  - exact one_time_pad.TKey.
  - exact one_time_pad.TInput.
  - exact one_time_pad.TOutput.
  - exact one_time_pad.TCipher.
  - exact Œî.
  - { Unshelve. 1: shelve.
  - exact lrel_key.
  - exact senc.
  - exact sdec.
  - exact P0l.
  - exact P0r.
  - exact Pl.
  - exact Pr.
  - exact Plr. } Unshelve.
    unfold lrel_key. iIntros (v v') "H"; iAssumption.
  - iIntros (x); iApply P0_P_l.
  - iIntros (x); iApply P0_P_r.
  - iIntros (x y); iApply P0lr_Plr.
  - iIntros (x y z t). iApply refines_init_otp_scheme_l.
  - iIntros (x y z t). iApply refines_init_otp_scheme_r.
  - iIntros (x y z t). iApply refines_otp_keygen_couple.
  - iIntros (x y z t). iApply refines_otp_keygen_l.
  - iIntros (x y z t). iApply refines_otp_keygen_r.
  - iIntros (x y z t x' y' z'). iApply refines_otp_senc_l.
  - iIntros (x y z x' y'). iApply otp_enc_sem_typed. assumption.
Qed.

Lemma adv_rand_syn_typed : ‚ä¢·µ• kemdem_hybrid_cpa_generic.adv_rand :
  ((one_time_pad.TMessage ‚Üí TOption one_time_pad.TCipher) ‚Üí œÑG *
    (kemdem_hybrid_cpa_generic.TOracle TInput one_time_pad.TCipher)).
Proof.
  rewrite /kemdem_hybrid_cpa_generic.adv_rand.
  apply Rec_val_typed.
  type_expr 1. 2 : { apply Subsume_int_nat. tychk. }
  type_expr 1.
  type_expr 1. 2 : { apply Subsume_int_nat. tychk. }
  type_expr 1.
  type_expr 1; last try tychk; first last.
  { apply g_typed. }
  { apply vexp_typed. }
  type_expr 1.
  type_expr 1; last try tychk; first last.
  { apply g_typed. }
  { apply vexp_typed. }
  type_expr 1.
  type_expr 1; last try tychk.
  type_expr 1.
  type_expr 1; first tychk.
  type_expr 1. Admitted.
  (* type_expr 1. 2 : { apply Subsume_int_nat. tychk. }
  type_expr 1.
  type_expr 1.
  { tychk. apply vg_of_int_typed. }
  { tychk. }
  type_expr 1.
  type_expr 1; first tychk.
  2 : { apply InjL_typed. tychk. }
  apply InjR_typed.
  type_expr 1; last tychk.
  type_expr 1.
  type_expr 1. 2 : {
    type_expr 1. 2 : { apply Subsume_int_nat. tychk. }
    tychk.
    { apply vexp_typed. }
    { apply g_typed. }
  }
  type_expr 1.
  type_expr 1; try tychk.
Qed. *)

Lemma otp_pk_rand_senc_mult_free_mult_free_delay :
  ‚ä¢ refines top 
      (init_scheme kemdem_hybrid_cpa_generic.pk_rand_senc_mult_free)
      (init_scheme kemdem_hybrid_cpa_generic.pk_rand_senc_mult_free_delay)
      (lrel_G *
      (lrel_input ‚Üí () + lrel_output * (lrel_G * lrel_G))).
Proof. rel_apply kemdem_hybrid_cpa_generic.pk_rand_senc_mult_free_mult_free_delay.
  - exact one_time_pad.TMessage.
  - exact one_time_pad.TKey.
  - exact one_time_pad.TInput.
  - exact one_time_pad.TOutput.
  - exact one_time_pad.TCipher.
  - exact Œî.
  - { Unshelve. 1: shelve.
  - exact lrel_key.
  - exact senc.
  - exact sdec.
  - exact P0l.
  - exact P0r.
  - exact Pl.
  - exact Pr.
  - exact Plr. } Unshelve.
    unfold lrel_key. iIntros (v v') "H"; iAssumption.
  - iIntros (x); iApply P0_P_l.
  - iIntros (x); iApply P0_P_r.
  - iIntros (x y); iApply P0lr_Plr.
  - iIntros (x y z t). iApply refines_init_otp_scheme_l.
  - iIntros (x y z t). iApply refines_init_otp_scheme_r.
  - iIntros (x y z t). iApply refines_otp_keygen_couple.
  - iIntros (x y z t). iApply refines_otp_keygen_l.
  - iIntros (x y z t). iApply refines_otp_keygen_r.
  - iIntros (x y z t x' y' z'). iApply refines_otp_senc_l.
  - iIntros (x y z x' y'). iApply otp_enc_sem_typed. assumption.
Qed.

(* TODO fetch OTS security equivalence and match it
  with CPA _ _ #1 *)

Lemma otp_pk_rand_senc_mult_free_adv_sym_OTS (adv : val) :
  refines top
    adv
    adv
    ((lrel_G * (lrel_input ‚Üí () + lrel_output * (lrel_G * lrel_G))) ‚Üí lrel_bool)
  ‚ä¢ refines top
      (adv (kemdem_hybrid_cpa_generic.init_scheme kemdem_hybrid_cpa_generic.pk_rand_senc_mult_free_delay))
      (kemdem_hybrid_cpa_generic.OTS #true (Œª: "oracle", adv (kemdem_hybrid_cpa_generic.adv_rand "oracle"))%V
        symmetric_init.sym_scheme)
      lrel_bool.
Proof. iApply kemdem_hybrid_cpa_generic.pk_rand_senc_mult_free_adv_sym_OTS.
  - exact one_time_pad.TMessage.
  - exact one_time_pad.TKey.
  - exact one_time_pad.TInput.
  - exact one_time_pad.TOutput.
  - exact one_time_pad.TCipher.
  - exact Œî.
  - { Unshelve. 1: shelve.
  - exact lrel_key.
  - exact senc.
  - exact sdec.
  - exact P0l.
  - exact P0r.
  - exact Pl.
  - exact Pr.
  - exact Plr. } Unshelve.
    unfold lrel_key. iIntros (v v') "H"; iAssumption.
  - iIntros (x); iApply P0_P_l.
  - iIntros (x); iApply P0_P_r.
  - iIntros (x y); iApply P0lr_Plr.
  - iIntros (x y z t). iApply refines_init_otp_scheme_l.
  - iIntros (x y z t). iApply refines_init_otp_scheme_r.
  - iIntros (x y z t). iApply refines_otp_keygen_couple.
  - iIntros (x y z t). iApply refines_otp_keygen_l.
  - iIntros (x y z t). iApply refines_otp_keygen_r.
  - iIntros (x y z t x' y' z'). iApply refines_otp_senc_l.
  - iIntros (x y z x' y'). iApply otp_enc_sem_typed. assumption.
Qed.

Lemma otp_rand_cipher_sem_typed : 
  ‚ä¢ refines top symmetric_init.rand_cipher
    symmetric_init.rand_cipher (lrel_input ‚Üí lrel_output).
Proof with rel_pures_l; rel_pures_r.
  rewrite /symmetric_init.rand_cipher... simpl.
  rewrite /one_time_pad.otp_rand_cipher.
  rel_arrow_val.
  iIntros (msg1 msg2) "_"...
  rel_apply refines_couple_UU; first done.
  iModIntro; iIntros (ri Hribound)...
  rel_vals. iExists ri. iPureIntro; repeat split; lia.
Qed.

Lemma otp_OTS_pk_rand_srand (adv : val) : 
  refines top
    adv
    adv
    ((lrel_G * (lrel_input ‚Üí () + lrel_output * (lrel_G * lrel_G))) ‚Üí lrel_bool)
  ‚ä¢ refines top
      (kemdem_hybrid_cpa_generic.OTS #false (Œª: "oracle", adv (kemdem_hybrid_cpa_generic.adv_rand "oracle"))%V
        symmetric_init.sym_scheme)
      (adv kemdem_hybrid_cpa_generic.pk_rand_srand)
      lrel_bool.
Proof. iApply kemdem_hybrid_cpa_generic.OTS_pk_rand_srand.
  - exact one_time_pad.TMessage.
  - exact one_time_pad.TKey.
  - exact one_time_pad.TInput.
  - exact one_time_pad.TOutput.
  - exact one_time_pad.TCipher.
  - exact Œî.
  - { Unshelve. 1: shelve.
  - exact lrel_key.
  - exact senc.
  - exact sdec.
  - exact P0l.
  - exact P0r.
  - exact Pl.
  - exact Pr.
  - exact Plr. } Unshelve.
    unfold lrel_key. iIntros (v v') "H"; iAssumption.
  - iIntros (x); iApply P0_P_l.
  - iIntros (x); iApply P0_P_r.
  - iIntros (x y); iApply P0lr_Plr.
  - iIntros (x y z t). iApply refines_init_otp_scheme_l.
  - iIntros (x y z t). iApply refines_init_otp_scheme_r.
  - iIntros (x y z t). iApply refines_otp_keygen_couple.
  - iIntros (x y z t). iApply refines_otp_keygen_l.
  - iIntros (x y z t). iApply refines_otp_keygen_r.
  - iIntros (x y z t x' y' z'). iApply refines_otp_senc_l.
  - iIntros (x y z x' y'). iApply otp_enc_sem_typed. assumption.
  - iApply otp_rand_cipher_sem_typed.
Qed.


Lemma otp_pk_rand_srand_rand_tape (adv : val) :
  refines top
    adv
    adv
    ((lrel_G * (lrel_input ‚Üí () + lrel_output * (lrel_G * lrel_G))) ‚Üí lrel_bool)
  ‚ä¢ refines top
      (adv kemdem_hybrid_cpa_generic.pk_rand_srand)
      (adv kemdem_hybrid_cpa_generic.pk_rand_tape)
      lrel_bool.
Proof with rel_pures_l; rel_pures_r.
  iApply kemdem_hybrid_cpa_generic.pk_rand_srand_rand_tape.
  - exact one_time_pad.TMessage.
  - exact one_time_pad.TKey.
  - exact one_time_pad.TInput.
  - exact one_time_pad.TOutput.
  - exact one_time_pad.TCipher.
  - exact Œî.
  - { Unshelve. 1: shelve.
  - exact lrel_key.
  - exact senc.
  - exact sdec.
  - exact P0l.
  - exact P0r.
  - exact Pl.
  - exact Pr.
  - exact Plr. } Unshelve.
    unfold lrel_key. iIntros (v v') "H"; iAssumption.
  - iIntros (x); iApply P0_P_l.
  - iIntros (x); iApply P0_P_r.
  - iIntros (x y); iApply P0lr_Plr.
  - iIntros (x y z t). iApply refines_init_otp_scheme_l.
  - iIntros (x y z t). iApply refines_init_otp_scheme_r.
  - iIntros (x y z t). iApply refines_otp_keygen_couple.
  - iIntros (x y z t). iApply refines_otp_keygen_l.
  - iIntros (x y z t). iApply refines_otp_keygen_r.
  - iIntros (x y z t x' y' z'). iApply refines_otp_senc_l.
  - iIntros (x y z x' y'). iApply otp_enc_sem_typed. assumption.
  - iApply otp_rand_cipher_sem_typed.
Qed.

Lemma otp_pk_rand_tape_pk_rand (adv : val) :
  refines top
    adv
    adv
    ((lrel_G * (lrel_input ‚Üí () + lrel_output * (lrel_G * lrel_G))) ‚Üí lrel_bool)
  ‚ä¢ refines top
      (adv kemdem_hybrid_cpa_generic.pk_rand_tape)
      (adv kemdem_hybrid_cpa_generic.pk_rand)
      lrel_bool.
Proof with rel_pures_l; rel_pures_r.
  iApply kemdem_hybrid_cpa_generic.pk_rand_tape_pk_rand.
  - exact one_time_pad.TMessage.
  - exact one_time_pad.TKey.
  - exact one_time_pad.TInput.
  - exact one_time_pad.TOutput.
  - exact one_time_pad.TCipher.
  - exact Œî.
  - { Unshelve. 1: shelve.
  - exact lrel_key.
  - exact senc.
  - exact sdec.
  - exact P0l.
  - exact P0r.
  - exact Pl.
  - exact Pr.
  - exact Plr. } Unshelve.
    unfold lrel_key. iIntros (v v') "H"; iAssumption.
  - iIntros (x); iApply P0_P_l.
  - iIntros (x); iApply P0_P_r.
  - iIntros (x y); iApply P0lr_Plr.
  - iIntros (x y z t). iApply refines_init_otp_scheme_l.
  - iIntros (x y z t). iApply refines_init_otp_scheme_r.
  - iIntros (x y z t). iApply refines_otp_keygen_couple.
  - iIntros (x y z t). iApply refines_otp_keygen_l.
  - iIntros (x y z t). iApply refines_otp_keygen_r.
  - iIntros (x y z t x' y' z'). iApply refines_otp_senc_l.
  - iIntros (x y z x' y'). iApply otp_enc_sem_typed. assumption.
  - iApply otp_rand_cipher_sem_typed.
Qed.

End logrel.

End Hybrid_scheme.